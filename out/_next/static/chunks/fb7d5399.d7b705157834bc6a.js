"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[737],{2212:function(a,b,c){c.d(b,{Mig:function(){return cia},m7l:function(){return sea},"N$j":function(){return nU},ZzF:function(){return ul},TlE:function(){return OA},u9r:function(){return HC},uWy:function(){return j},Ilk:function(){return oz},Ox3:function(){return $ha},ehD:function(){return h},pBf:function(){return z},hH6:function(){return lga},Wl3:function(){return f},ZAu:function(){return IQ},QRU:function(){return vja},vpT:function(){return aS},kB5:function(){return tS},"_C8":function(){return mba},Syv:function(){return s},NMF:function(){return t},x12:function(){return dW},nls:function(){return XV},blk:function(){return gX},ejS:function(){return $W},wem:function(){return o},D1R:function(){return q},qyh:function(){return p},aNw:function(){return aga},Zp0:function(){return jja},RsA:function(){return d},F5T:function(){return Sy},M8C:function(){return ca},yGw:function(){return dp},Kj0:function(){return qG},vBJ:function(){return JA},EJi:function(){return Paa},Wid:function(){return Maa},OoA:function(){return k},TyD:function(){return l},aH4:function(){return n},YLQ:function(){return m},dUE:function(){return $da},Tme:function(){return hv},iKG:function(){return gM},cPb:function(){return iI},cek:function(){return Sha},woe:function(){return qX},UY4:function(){return jX},iUV:function(){return Bla},"_fP":function(){return jg},iLg:function(){return oea},UCm:function(){return r},rpg:function(){return i},xsS:function(){return XR},OdW:function(){return DU},TUv:function(){return WT},aLr:function(){return $m},"$V":function(){return Tta},PMe:function(){return Aha},QmN:function(){return e},IOt:function(){return x},xEZ:function(){return Gd},dpR:function(){return Sga},"z$h":function(){return v},UlW:function(){return u},FM8:function(){return da},Pa4:function(){return Qi},yC1:function(){return rea},CP7:function(){return PR},knz:function(){return w}});const d={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},e={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},f=0,g=1,h=2,i=1000,j=1001,k=1002,l=1003,m=1004,n=1005,o=1006,p=1007,q=1008,r=1022,s=2300,t=2301,u=1,v=2,w=3001,x=0,y="300 es";class z{addEventListener(A,B){void 0===this._listeners&&(this._listeners={});const C=this._listeners;void 0===C[A]&&(C[A]=[]),-1===C[A].indexOf(B)&&C[A].push(B)}hasEventListener(D,E){if(void 0===this._listeners)return!1;const F=this._listeners;return void 0!==F[D]&& -1!==F[D].indexOf(E)}removeEventListener(G,H){if(void 0===this._listeners)return;const I=this._listeners,J=I[G];if(void 0!==J){const K=J.indexOf(H);-1!==K&&J.splice(K,1)}}dispatchEvent(L){if(void 0===this._listeners)return;const M=this._listeners,N=M[L.type];if(void 0!==N){L.target=this;const O=N.slice(0);for(let P=0,Q=O.length;P<Q;P++)O[P].call(this,L);L.target=null}}}let R=1234567;const S=Math.PI/180,T=180/Math.PI,U=[];for(let V=0;V<256;V++)U[V]=(V<16?"0":"")+V.toString(16);const W="undefined"!=typeof crypto&&"randomUUID"in crypto;function X(){if(W)return crypto.randomUUID().toUpperCase();const a=4294967295*Math.random()|0,b=4294967295*Math.random()|0,c=4294967295*Math.random()|0,d=4294967295*Math.random()|0,e=U[255&a]+U[a>>8&255]+U[a>>16&255]+U[a>>24&255]+"-"+U[255&b]+U[b>>8&255]+"-"+U[b>>16&15|64]+U[b>>24&255]+"-"+U[63&c|128]+U[c>>8&255]+"-"+U[c>>16&255]+U[c>>24&255]+U[255&d]+U[d>>8&255]+U[d>>16&255]+U[d>>24&255];return e.toUpperCase()}function Y(a,b,c){return Math.max(b,Math.min(c,a))}function Z(a,b){return(a%b+b)%b}function $(a,b,c){return(1-c)*a+c*b}function _(a){return(a&a-1)==0&&0!==a}function aa(a){return Math.pow(2,Math.ceil(Math.log(a)/Math.LN2))}function ba(a){return Math.pow(2,Math.floor(Math.log(a)/Math.LN2))}var ca=Object.freeze({__proto__:null,DEG2RAD:S,RAD2DEG:T,generateUUID:X,clamp:Y,euclideanModulo:Z,mapLinear:function(a,b,c,d,e){return d+(a-b)*(e-d)/(c-b)},inverseLerp:function(a,b,c){return a!==b?(c-a)/(b-a):0},lerp:$,damp:function(a,b,c,d){return $(a,b,1-Math.exp(-c*d))},pingpong:function(a,b=1){return b-Math.abs(Z(a,2*b)-b)},smoothstep:function(a,b,c){return a<=b?0:a>=c?1:(a=(a-b)/(c-b))*a*(3-2*a)},smootherstep:function(a,b,c){return a<=b?0:a>=c?1:(a=(a-b)/(c-b))*a*a*(a*(6*a-15)+10)},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*(0.5-Math.random())},seededRandom:function(a){return void 0!==a&&(R=a%2147483647),((R=16807*R%2147483647)-1)/2147483646},degToRad:function(a){return a*S},radToDeg:function(a){return a*T},isPowerOfTwo:_,ceilPowerOfTwo:aa,floorPowerOfTwo:ba,setQuaternionFromProperEuler:function(a,b,c,d,e){const f=Math.cos,g=Math.sin,h=f(c/2),i=g(c/2),j=f((b+d)/2),k=g((b+d)/2),l=f((b-d)/2),m=g((b-d)/2),n=f((d-b)/2),o=g((d-b)/2);switch(e){case"XYX":a.set(h*k,i*l,i*m,h*j);break;case"YZY":a.set(i*m,h*k,i*l,h*j);break;case"ZXZ":a.set(i*l,i*m,h*k,h*j);break;case"XZX":a.set(h*k,i*o,i*n,h*j);break;case"YXY":a.set(i*n,h*k,i*o,h*j);break;case"ZYZ":a.set(i*o,i*n,h*k,h*j);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+e)}}});class da{constructor(ea=0,fa=0){this.x=ea,this.y=fa}get width(){return this.x}set width(ga){this.x=ga}get height(){return this.y}set height(ha){this.y=ha}set(ia,ja){return this.x=ia,this.y=ja,this}setScalar(ka){return this.x=ka,this.y=ka,this}setX(la){return this.x=la,this}setY(ma){return this.y=ma,this}setComponent(na,oa){switch(na){case 0:this.x=oa;break;case 1:this.y=oa;break;default:throw new Error("index is out of range: "+na)}return this}getComponent(pa){switch(pa){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+pa)}}clone(){return new this.constructor(this.x,this.y)}copy(qa){return this.x=qa.x,this.y=qa.y,this}add(ra,sa){return void 0!==sa?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(ra,sa)):(this.x+=ra.x,this.y+=ra.y,this)}addScalar(ta){return this.x+=ta,this.y+=ta,this}addVectors(ua,va){return this.x=ua.x+va.x,this.y=ua.y+va.y,this}addScaledVector(wa,xa){return this.x+=wa.x*xa,this.y+=wa.y*xa,this}sub(ya,za){return void 0!==za?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(ya,za)):(this.x-=ya.x,this.y-=ya.y,this)}subScalar(Aa){return this.x-=Aa,this.y-=Aa,this}subVectors(Ba,Ca){return this.x=Ba.x-Ca.x,this.y=Ba.y-Ca.y,this}multiply(Da){return this.x*=Da.x,this.y*=Da.y,this}multiplyScalar(Ea){return this.x*=Ea,this.y*=Ea,this}divide(Fa){return this.x/=Fa.x,this.y/=Fa.y,this}divideScalar(Ga){return this.multiplyScalar(1/Ga)}applyMatrix3(Ha){const Ia=this.x,Ja=this.y,Ka=Ha.elements;return this.x=Ka[0]*Ia+Ka[3]*Ja+Ka[6],this.y=Ka[1]*Ia+Ka[4]*Ja+Ka[7],this}min(La){return this.x=Math.min(this.x,La.x),this.y=Math.min(this.y,La.y),this}max(Ma){return this.x=Math.max(this.x,Ma.x),this.y=Math.max(this.y,Ma.y),this}clamp(Na,Oa){return this.x=Math.max(Na.x,Math.min(Oa.x,this.x)),this.y=Math.max(Na.y,Math.min(Oa.y,this.y)),this}clampScalar(Pa,Qa){return this.x=Math.max(Pa,Math.min(Qa,this.x)),this.y=Math.max(Pa,Math.min(Qa,this.y)),this}clampLength(Ra,Sa){const Ta=this.length();return this.divideScalar(Ta||1).multiplyScalar(Math.max(Ra,Math.min(Sa,Ta)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(Ua){return this.x*Ua.x+this.y*Ua.y}cross(Va){return this.x*Va.y-this.y*Va.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){const Wa=Math.atan2(-this.y,-this.x)+Math.PI;return Wa}distanceTo(Xa){return Math.sqrt(this.distanceToSquared(Xa))}distanceToSquared(Ya){const Za=this.x-Ya.x,$a=this.y-Ya.y;return Za*Za+$a*$a}manhattanDistanceTo(_a){return Math.abs(this.x-_a.x)+Math.abs(this.y-_a.y)}setLength(ab){return this.normalize().multiplyScalar(ab)}lerp(bb,cb){return this.x+=(bb.x-this.x)*cb,this.y+=(bb.y-this.y)*cb,this}lerpVectors(db,eb,fb){return this.x=db.x+(eb.x-db.x)*fb,this.y=db.y+(eb.y-db.y)*fb,this}equals(gb){return gb.x===this.x&&gb.y===this.y}fromArray(hb,ib=0){return this.x=hb[ib],this.y=hb[ib+1],this}toArray(jb=[],kb=0){return jb[kb]=this.x,jb[kb+1]=this.y,jb}fromBufferAttribute(lb,mb,nb){return void 0!==nb&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=lb.getX(mb),this.y=lb.getY(mb),this}rotateAround(ob,pb){const qb=Math.cos(pb),rb=Math.sin(pb),sb=this.x-ob.x,tb=this.y-ob.y;return this.x=sb*qb-tb*rb+ob.x,this.y=sb*rb+tb*qb+ob.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}da.prototype.isVector2=!0;class ub{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(vb,wb,xb,yb,zb,Ab,Bb,Cb,Db){const Eb=this.elements;return Eb[0]=vb,Eb[1]=yb,Eb[2]=Bb,Eb[3]=wb,Eb[4]=zb,Eb[5]=Cb,Eb[6]=xb,Eb[7]=Ab,Eb[8]=Db,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(Fb){const Gb=this.elements,Hb=Fb.elements;return Gb[0]=Hb[0],Gb[1]=Hb[1],Gb[2]=Hb[2],Gb[3]=Hb[3],Gb[4]=Hb[4],Gb[5]=Hb[5],Gb[6]=Hb[6],Gb[7]=Hb[7],Gb[8]=Hb[8],this}extractBasis(Ib,Jb,Kb){return Ib.setFromMatrix3Column(this,0),Jb.setFromMatrix3Column(this,1),Kb.setFromMatrix3Column(this,2),this}setFromMatrix4(Lb){const Mb=Lb.elements;return this.set(Mb[0],Mb[4],Mb[8],Mb[1],Mb[5],Mb[9],Mb[2],Mb[6],Mb[10]),this}multiply(Nb){return this.multiplyMatrices(this,Nb)}premultiply(Ob){return this.multiplyMatrices(Ob,this)}multiplyMatrices(Pb,Qb){const Rb=Pb.elements,Sb=Qb.elements,Tb=this.elements,Ub=Rb[0],Vb=Rb[3],Wb=Rb[6],Xb=Rb[1],Yb=Rb[4],Zb=Rb[7],$b=Rb[2],_b=Rb[5],ac=Rb[8],bc=Sb[0],cc=Sb[3],dc=Sb[6],ec=Sb[1],fc=Sb[4],gc=Sb[7],hc=Sb[2],ic=Sb[5],jc=Sb[8];return Tb[0]=Ub*bc+Vb*ec+Wb*hc,Tb[3]=Ub*cc+Vb*fc+Wb*ic,Tb[6]=Ub*dc+Vb*gc+Wb*jc,Tb[1]=Xb*bc+Yb*ec+Zb*hc,Tb[4]=Xb*cc+Yb*fc+Zb*ic,Tb[7]=Xb*dc+Yb*gc+Zb*jc,Tb[2]=$b*bc+_b*ec+ac*hc,Tb[5]=$b*cc+_b*fc+ac*ic,Tb[8]=$b*dc+_b*gc+ac*jc,this}multiplyScalar(kc){const lc=this.elements;return lc[0]*=kc,lc[3]*=kc,lc[6]*=kc,lc[1]*=kc,lc[4]*=kc,lc[7]*=kc,lc[2]*=kc,lc[5]*=kc,lc[8]*=kc,this}determinant(){const mc=this.elements,nc=mc[0],oc=mc[1],pc=mc[2],qc=mc[3],rc=mc[4],sc=mc[5],tc=mc[6],uc=mc[7],vc=mc[8];return nc*rc*vc-nc*sc*uc-oc*qc*vc+oc*sc*tc+pc*qc*uc-pc*rc*tc}invert(){const wc=this.elements,xc=wc[0],yc=wc[1],zc=wc[2],Ac=wc[3],Bc=wc[4],Cc=wc[5],Dc=wc[6],Ec=wc[7],Fc=wc[8],Gc=Fc*Bc-Cc*Ec,Hc=Cc*Dc-Fc*Ac,Ic=Ec*Ac-Bc*Dc,Jc=xc*Gc+yc*Hc+zc*Ic;if(0===Jc)return this.set(0,0,0,0,0,0,0,0,0);const Kc=1/Jc;return wc[0]=Gc*Kc,wc[1]=(zc*Ec-Fc*yc)*Kc,wc[2]=(Cc*yc-zc*Bc)*Kc,wc[3]=Hc*Kc,wc[4]=(Fc*xc-zc*Dc)*Kc,wc[5]=(zc*Ac-Cc*xc)*Kc,wc[6]=Ic*Kc,wc[7]=(yc*Dc-Ec*xc)*Kc,wc[8]=(Bc*xc-yc*Ac)*Kc,this}transpose(){let Lc;const Mc=this.elements;return Lc=Mc[1],Mc[1]=Mc[3],Mc[3]=Lc,Lc=Mc[2],Mc[2]=Mc[6],Mc[6]=Lc,Lc=Mc[5],Mc[5]=Mc[7],Mc[7]=Lc,this}getNormalMatrix(Nc){return this.setFromMatrix4(Nc).invert().transpose()}transposeIntoArray(Oc){const Pc=this.elements;return Oc[0]=Pc[0],Oc[1]=Pc[3],Oc[2]=Pc[6],Oc[3]=Pc[1],Oc[4]=Pc[4],Oc[5]=Pc[7],Oc[6]=Pc[2],Oc[7]=Pc[5],Oc[8]=Pc[8],this}setUvTransform(Qc,Rc,Sc,Tc,Uc,Vc,Wc){const Xc=Math.cos(Uc),Yc=Math.sin(Uc);return this.set(Sc*Xc,Sc*Yc,-Sc*(Xc*Vc+Yc*Wc)+Vc+Qc,-Tc*Yc,Tc*Xc,-Tc*(-Yc*Vc+Xc*Wc)+Wc+Rc,0,0,1),this}scale(Zc,$c){const _c=this.elements;return _c[0]*=Zc,_c[3]*=Zc,_c[6]*=Zc,_c[1]*=$c,_c[4]*=$c,_c[7]*=$c,this}rotate(ad){const bd=Math.cos(ad),cd=Math.sin(ad),dd=this.elements,ed=dd[0],fd=dd[3],gd=dd[6],hd=dd[1],id=dd[4],jd=dd[7];return dd[0]=bd*ed+cd*hd,dd[3]=bd*fd+cd*id,dd[6]=bd*gd+cd*jd,dd[1]=-cd*ed+bd*hd,dd[4]=-cd*fd+bd*id,dd[7]=-cd*gd+bd*jd,this}translate(kd,ld){const md=this.elements;return md[0]+=kd*md[2],md[3]+=kd*md[5],md[6]+=kd*md[8],md[1]+=ld*md[2],md[4]+=ld*md[5],md[7]+=ld*md[8],this}equals(nd){const od=this.elements,pd=nd.elements;for(let qd=0;qd<9;qd++)if(od[qd]!==pd[qd])return!1;return!0}fromArray(rd,sd=0){for(let td=0;td<9;td++)this.elements[td]=rd[td+sd];return this}toArray(ud=[],vd=0){const wd=this.elements;return ud[vd]=wd[0],ud[vd+1]=wd[1],ud[vd+2]=wd[2],ud[vd+3]=wd[3],ud[vd+4]=wd[4],ud[vd+5]=wd[5],ud[vd+6]=wd[6],ud[vd+7]=wd[7],ud[vd+8]=wd[8],ud}clone(){return new this.constructor().fromArray(this.elements)}}function xd(a){if(0===a.length)return-1/0;let b=a[0];for(let c=1,d=a.length;c<d;++c)a[c]>b&&(b=a[c]);return b}function yd(a){return document.createElementNS("http://www.w3.org/1999/xhtml",a)}function zd(a,b=0){let c=3735928559^b,d=1103547991^b;for(let e=0,f;e<a.length;e++)c=Math.imul(c^(f=a.charCodeAt(e)),2654435761),d=Math.imul(d^f,1597334677);return c=Math.imul(c^c>>>16,2246822507)^Math.imul(d^d>>>13,3266489909),d=Math.imul(d^d>>>16,2246822507)^Math.imul(c^c>>>13,3266489909),4294967296*(2097151&d)+(c>>>0)}ub.prototype.isMatrix3=!0;let Ad;class Bd{static getDataURL(Cd){if(/^data:/i.test(Cd.src))return Cd.src;if("undefined"==typeof HTMLCanvasElement)return Cd.src;let Dd;if(Cd instanceof HTMLCanvasElement)Dd=Cd;else{void 0===Ad&&(Ad=yd("canvas")),Ad.width=Cd.width,Ad.height=Cd.height;const Ed=Ad.getContext("2d");Cd instanceof ImageData?Ed.putImageData(Cd,0,0):Ed.drawImage(Cd,0,0,Cd.width,Cd.height),Dd=Ad}return Dd.width>2048||Dd.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",Cd),Dd.toDataURL("image/jpeg",0.6)):Dd.toDataURL("image/png")}}let Fd=0;class Gd extends z{constructor(Hd=Gd.DEFAULT_IMAGE,Id=Gd.DEFAULT_MAPPING,Jd=j,Kd=j,Ld=o,Md=q,Nd=1023,Od=1009,Pd=1,Qd=3000){super(),Object.defineProperty(this,"id",{value:Fd++}),this.uuid=X(),this.name="",this.image=Hd,this.mipmaps=[],this.mapping=Id,this.wrapS=Jd,this.wrapT=Kd,this.magFilter=Ld,this.minFilter=Md,this.anisotropy=Pd,this.format=Nd,this.internalFormat=null,this.type=Od,this.offset=new da(0,0),this.repeat=new da(1,1),this.center=new da(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new ub(),this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=Qd,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(Rd){return this.name=Rd.name,this.image=Rd.image,this.mipmaps=Rd.mipmaps.slice(0),this.mapping=Rd.mapping,this.wrapS=Rd.wrapS,this.wrapT=Rd.wrapT,this.magFilter=Rd.magFilter,this.minFilter=Rd.minFilter,this.anisotropy=Rd.anisotropy,this.format=Rd.format,this.internalFormat=Rd.internalFormat,this.type=Rd.type,this.offset.copy(Rd.offset),this.repeat.copy(Rd.repeat),this.center.copy(Rd.center),this.rotation=Rd.rotation,this.matrixAutoUpdate=Rd.matrixAutoUpdate,this.matrix.copy(Rd.matrix),this.generateMipmaps=Rd.generateMipmaps,this.premultiplyAlpha=Rd.premultiplyAlpha,this.flipY=Rd.flipY,this.unpackAlignment=Rd.unpackAlignment,this.encoding=Rd.encoding,this.userData=JSON.parse(JSON.stringify(Rd.userData)),this}toJSON(Sd){const Td=void 0===Sd||"string"==typeof Sd;if(!Td&& void 0!==Sd.textures[this.uuid])return Sd.textures[this.uuid];const Ud={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(void 0!==this.image){const Vd=this.image;if(void 0===Vd.uuid&&(Vd.uuid=X()),!Td&& void 0===Sd.images[Vd.uuid]){let Wd;if(Array.isArray(Vd)){Wd=[];for(let Xd=0,Yd=Vd.length;Xd<Yd;Xd++)Vd[Xd].isDataTexture?Wd.push(_d(Vd[Xd].image)):Wd.push(_d(Vd[Xd]))}else Wd=_d(Vd);Sd.images[Vd.uuid]={uuid:Vd.uuid,url:Wd}}Ud.image=Vd.uuid}return"{}"!==JSON.stringify(this.userData)&&(Ud.userData=this.userData),Td||(Sd.textures[this.uuid]=Ud),Ud}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(Zd){if(300!==this.mapping)return Zd;if(Zd.applyMatrix3(this.matrix),Zd.x<0||Zd.x>1)switch(this.wrapS){case i:Zd.x=Zd.x-Math.floor(Zd.x);break;case j:Zd.x=Zd.x<0?0:1;break;case k:1===Math.abs(Math.floor(Zd.x)%2)?Zd.x=Math.ceil(Zd.x)-Zd.x:Zd.x=Zd.x-Math.floor(Zd.x);break}if(Zd.y<0||Zd.y>1)switch(this.wrapT){case i:Zd.y=Zd.y-Math.floor(Zd.y);break;case j:Zd.y=Zd.y<0?0:1;break;case k:1===Math.abs(Math.floor(Zd.y)%2)?Zd.y=Math.ceil(Zd.y)-Zd.y:Zd.y=Zd.y-Math.floor(Zd.y);break}return this.flipY&&(Zd.y=1-Zd.y),Zd}set needsUpdate($d){!0===$d&&this.version++}}function _d(a){return"undefined"!=typeof HTMLImageElement&&a instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&a instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&a instanceof ImageBitmap?Bd.getDataURL(a):a.data?{data:Array.prototype.slice.call(a.data),width:a.width,height:a.height,type:a.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}Gd.DEFAULT_IMAGE=void 0,Gd.DEFAULT_MAPPING=300,Gd.prototype.isTexture=!0;class ae{constructor(be=0,ce=0,de=0,ee=1){this.x=be,this.y=ce,this.z=de,this.w=ee}get width(){return this.z}set width(fe){this.z=fe}get height(){return this.w}set height(ge){this.w=ge}set(he,ie,je,ke){return this.x=he,this.y=ie,this.z=je,this.w=ke,this}setScalar(le){return this.x=le,this.y=le,this.z=le,this.w=le,this}setX(me){return this.x=me,this}setY(ne){return this.y=ne,this}setZ(oe){return this.z=oe,this}setW(pe){return this.w=pe,this}setComponent(qe,re){switch(qe){case 0:this.x=re;break;case 1:this.y=re;break;case 2:this.z=re;break;case 3:this.w=re;break;default:throw new Error("index is out of range: "+qe)}return this}getComponent(se){switch(se){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+se)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(te){return this.x=te.x,this.y=te.y,this.z=te.z,this.w=void 0!==te.w?te.w:1,this}add(ue,ve){return void 0!==ve?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(ue,ve)):(this.x+=ue.x,this.y+=ue.y,this.z+=ue.z,this.w+=ue.w,this)}addScalar(we){return this.x+=we,this.y+=we,this.z+=we,this.w+=we,this}addVectors(xe,ye){return this.x=xe.x+ye.x,this.y=xe.y+ye.y,this.z=xe.z+ye.z,this.w=xe.w+ye.w,this}addScaledVector(ze,Ae){return this.x+=ze.x*Ae,this.y+=ze.y*Ae,this.z+=ze.z*Ae,this.w+=ze.w*Ae,this}sub(Be,Ce){return void 0!==Ce?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(Be,Ce)):(this.x-=Be.x,this.y-=Be.y,this.z-=Be.z,this.w-=Be.w,this)}subScalar(De){return this.x-=De,this.y-=De,this.z-=De,this.w-=De,this}subVectors(Ee,Fe){return this.x=Ee.x-Fe.x,this.y=Ee.y-Fe.y,this.z=Ee.z-Fe.z,this.w=Ee.w-Fe.w,this}multiply(Ge){return this.x*=Ge.x,this.y*=Ge.y,this.z*=Ge.z,this.w*=Ge.w,this}multiplyScalar(He){return this.x*=He,this.y*=He,this.z*=He,this.w*=He,this}applyMatrix4(Ie){const Je=this.x,Ke=this.y,Le=this.z,Me=this.w,Ne=Ie.elements;return this.x=Ne[0]*Je+Ne[4]*Ke+Ne[8]*Le+Ne[12]*Me,this.y=Ne[1]*Je+Ne[5]*Ke+Ne[9]*Le+Ne[13]*Me,this.z=Ne[2]*Je+Ne[6]*Ke+Ne[10]*Le+Ne[14]*Me,this.w=Ne[3]*Je+Ne[7]*Ke+Ne[11]*Le+Ne[15]*Me,this}divideScalar(Oe){return this.multiplyScalar(1/Oe)}setAxisAngleFromQuaternion(Pe){this.w=2*Math.acos(Pe.w);const Qe=Math.sqrt(1-Pe.w*Pe.w);return Qe<0.0001?(this.x=1,this.y=0,this.z=0):(this.x=Pe.x/Qe,this.y=Pe.y/Qe,this.z=Pe.z/Qe),this}setAxisAngleFromRotationMatrix(Re){let Se,Te,Ue,Ve;const We=Re.elements,Xe=We[0],Ye=We[4],Ze=We[8],$e=We[1],_e=We[5],af=We[9],bf=We[2],cf=We[6],df=We[10];if(0.01>Math.abs(Ye-$e)&&0.01>Math.abs(Ze-bf)&&0.01>Math.abs(af-cf)){if(0.1>Math.abs(Ye+$e)&&0.1>Math.abs(Ze+bf)&&0.1>Math.abs(af+cf)&&0.1>Math.abs(Xe+_e+df-3))return this.set(1,0,0,0),this;Se=Math.PI;const ef=(Xe+1)/2,ff=(_e+1)/2,gf=(df+1)/2,hf=(Ye+$e)/4,jf=(Ze+bf)/4,kf=(af+cf)/4;return ef>ff&&ef>gf?ef<0.01?(Te=0,Ue=0.707106781,Ve=0.707106781):(Ue=hf/(Te=Math.sqrt(ef)),Ve=jf/Te):ff>gf?ff<0.01?(Te=0.707106781,Ue=0,Ve=0.707106781):(Te=hf/(Ue=Math.sqrt(ff)),Ve=kf/Ue):gf<0.01?(Te=0.707106781,Ue=0.707106781,Ve=0):(Te=jf/(Ve=Math.sqrt(gf)),Ue=kf/Ve),this.set(Te,Ue,Ve,Se),this}let lf=Math.sqrt((cf-af)*(cf-af)+(Ze-bf)*(Ze-bf)+($e-Ye)*($e-Ye));return 0.001>Math.abs(lf)&&(lf=1),this.x=(cf-af)/lf,this.y=(Ze-bf)/lf,this.z=($e-Ye)/lf,this.w=Math.acos((Xe+_e+df-1)/2),this}min(mf){return this.x=Math.min(this.x,mf.x),this.y=Math.min(this.y,mf.y),this.z=Math.min(this.z,mf.z),this.w=Math.min(this.w,mf.w),this}max(nf){return this.x=Math.max(this.x,nf.x),this.y=Math.max(this.y,nf.y),this.z=Math.max(this.z,nf.z),this.w=Math.max(this.w,nf.w),this}clamp(of,pf){return this.x=Math.max(of.x,Math.min(pf.x,this.x)),this.y=Math.max(of.y,Math.min(pf.y,this.y)),this.z=Math.max(of.z,Math.min(pf.z,this.z)),this.w=Math.max(of.w,Math.min(pf.w,this.w)),this}clampScalar(qf,rf){return this.x=Math.max(qf,Math.min(rf,this.x)),this.y=Math.max(qf,Math.min(rf,this.y)),this.z=Math.max(qf,Math.min(rf,this.z)),this.w=Math.max(qf,Math.min(rf,this.w)),this}clampLength(sf,tf){const uf=this.length();return this.divideScalar(uf||1).multiplyScalar(Math.max(sf,Math.min(tf,uf)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(vf){return this.x*vf.x+this.y*vf.y+this.z*vf.z+this.w*vf.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(wf){return this.normalize().multiplyScalar(wf)}lerp(xf,yf){return this.x+=(xf.x-this.x)*yf,this.y+=(xf.y-this.y)*yf,this.z+=(xf.z-this.z)*yf,this.w+=(xf.w-this.w)*yf,this}lerpVectors(zf,Af,Bf){return this.x=zf.x+(Af.x-zf.x)*Bf,this.y=zf.y+(Af.y-zf.y)*Bf,this.z=zf.z+(Af.z-zf.z)*Bf,this.w=zf.w+(Af.w-zf.w)*Bf,this}equals(Cf){return Cf.x===this.x&&Cf.y===this.y&&Cf.z===this.z&&Cf.w===this.w}fromArray(Df,Ef=0){return this.x=Df[Ef],this.y=Df[Ef+1],this.z=Df[Ef+2],this.w=Df[Ef+3],this}toArray(Ff=[],Gf=0){return Ff[Gf]=this.x,Ff[Gf+1]=this.y,Ff[Gf+2]=this.z,Ff[Gf+3]=this.w,Ff}fromBufferAttribute(Hf,If,Jf){return void 0!==Jf&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=Hf.getX(If),this.y=Hf.getY(If),this.z=Hf.getZ(If),this.w=Hf.getW(If),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}ae.prototype.isVector4=!0;class Kf extends z{constructor(Lf,Mf,Nf={}){super(),this.width=Lf,this.height=Mf,this.depth=1,this.scissor=new ae(0,0,Lf,Mf),this.scissorTest=!1,this.viewport=new ae(0,0,Lf,Mf),this.texture=new Gd(void 0,Nf.mapping,Nf.wrapS,Nf.wrapT,Nf.magFilter,Nf.minFilter,Nf.format,Nf.type,Nf.anisotropy,Nf.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:Lf,height:Mf,depth:1},this.texture.generateMipmaps=void 0!==Nf.generateMipmaps&&Nf.generateMipmaps,this.texture.internalFormat=void 0!==Nf.internalFormat?Nf.internalFormat:null,this.texture.minFilter=void 0!==Nf.minFilter?Nf.minFilter:o,this.depthBuffer=void 0===Nf.depthBuffer||Nf.depthBuffer,this.stencilBuffer=void 0!==Nf.stencilBuffer&&Nf.stencilBuffer,this.depthTexture=void 0!==Nf.depthTexture?Nf.depthTexture:null}setTexture(Of){Of.image={width:this.width,height:this.height,depth:this.depth},this.texture=Of}setSize(Pf,Qf,Rf=1){(this.width!==Pf||this.height!==Qf||this.depth!==Rf)&&(this.width=Pf,this.height=Qf,this.depth=Rf,this.texture.image.width=Pf,this.texture.image.height=Qf,this.texture.image.depth=Rf,this.dispose()),this.viewport.set(0,0,Pf,Qf),this.scissor.set(0,0,Pf,Qf)}clone(){return new this.constructor().copy(this)}copy(Sf){return this.width=Sf.width,this.height=Sf.height,this.depth=Sf.depth,this.viewport.copy(Sf.viewport),this.texture=Sf.texture.clone(),this.texture.image={...this.texture.image},this.depthBuffer=Sf.depthBuffer,this.stencilBuffer=Sf.stencilBuffer,this.depthTexture=Sf.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}Kf.prototype.isWebGLRenderTarget=!0,(class extends Kf{constructor(Tf,Uf,Vf){super(Tf,Uf);const Wf=this.texture;this.texture=[];for(let Xf=0;Xf<Vf;Xf++)this.texture[Xf]=Wf.clone()}setSize(Yf,Zf,$f=1){if(this.width!==Yf||this.height!==Zf||this.depth!==$f){this.width=Yf,this.height=Zf,this.depth=$f;for(let _f=0,ag=this.texture.length;_f<ag;_f++)this.texture[_f].image.width=Yf,this.texture[_f].image.height=Zf,this.texture[_f].image.depth=$f;this.dispose()}return this.viewport.set(0,0,Yf,Zf),this.scissor.set(0,0,Yf,Zf),this}copy(bg){this.dispose(),this.width=bg.width,this.height=bg.height,this.depth=bg.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=bg.depthBuffer,this.stencilBuffer=bg.stencilBuffer,this.depthTexture=bg.depthTexture,this.texture.length=0;for(let cg=0,dg=bg.texture.length;cg<dg;cg++)this.texture[cg]=bg.texture[cg].clone();return this}}).prototype.isWebGLMultipleRenderTargets=!0;class eg extends Kf{constructor(fg,gg,hg){super(fg,gg,hg),this.samples=4}copy(ig){return super.copy.call(this,ig),this.samples=ig.samples,this}}eg.prototype.isWebGLMultisampleRenderTarget=!0;class jg{constructor(kg=0,lg=0,mg=0,ng=1){this._x=kg,this._y=lg,this._z=mg,this._w=ng}static slerp(og,pg,qg,rg){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),qg.slerpQuaternions(og,pg,rg)}static slerpFlat(sg,tg,ug,vg,wg,xg,yg){let zg=ug[vg+0],Ag=ug[vg+1],Bg=ug[vg+2],Cg=ug[vg+3];const Dg=wg[xg+0],Eg=wg[xg+1],Fg=wg[xg+2],Gg=wg[xg+3];if(0===yg){sg[tg+0]=zg,sg[tg+1]=Ag,sg[tg+2]=Bg,sg[tg+3]=Cg;return}if(1===yg){sg[tg+0]=Dg,sg[tg+1]=Eg,sg[tg+2]=Fg,sg[tg+3]=Gg;return}if(Cg!==Gg||zg!==Dg||Ag!==Eg||Bg!==Fg){let Hg=1-yg;const Ig=zg*Dg+Ag*Eg+Bg*Fg+Cg*Gg,Jg=Ig>=0?1:-1,Kg=1-Ig*Ig;if(Kg>Number.EPSILON){const Lg=Math.sqrt(Kg),Mg=Math.atan2(Lg,Ig*Jg);Hg=Math.sin(Hg*Mg)/Lg,yg=Math.sin(yg*Mg)/Lg}const Ng=yg*Jg;if(zg=zg*Hg+Dg*Ng,Ag=Ag*Hg+Eg*Ng,Bg=Bg*Hg+Fg*Ng,Cg=Cg*Hg+Gg*Ng,Hg===1-yg){const Og=1/Math.sqrt(zg*zg+Ag*Ag+Bg*Bg+Cg*Cg);zg*=Og,Ag*=Og,Bg*=Og,Cg*=Og}}sg[tg]=zg,sg[tg+1]=Ag,sg[tg+2]=Bg,sg[tg+3]=Cg}static multiplyQuaternionsFlat(Pg,Qg,Rg,Sg,Tg,Ug){const Vg=Rg[Sg],Wg=Rg[Sg+1],Xg=Rg[Sg+2],Yg=Rg[Sg+3],Zg=Tg[Ug],$g=Tg[Ug+1],_g=Tg[Ug+2],ah=Tg[Ug+3];return Pg[Qg]=Vg*ah+Yg*Zg+Wg*_g-Xg*$g,Pg[Qg+1]=Wg*ah+Yg*$g+Xg*Zg-Vg*_g,Pg[Qg+2]=Xg*ah+Yg*_g+Vg*$g-Wg*Zg,Pg[Qg+3]=Yg*ah-Vg*Zg-Wg*$g-Xg*_g,Pg}get x(){return this._x}set x(bh){this._x=bh,this._onChangeCallback()}get y(){return this._y}set y(ch){this._y=ch,this._onChangeCallback()}get z(){return this._z}set z(dh){this._z=dh,this._onChangeCallback()}get w(){return this._w}set w(eh){this._w=eh,this._onChangeCallback()}set(fh,gh,hh,ih){return this._x=fh,this._y=gh,this._z=hh,this._w=ih,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(jh){return this._x=jh.x,this._y=jh.y,this._z=jh.z,this._w=jh.w,this._onChangeCallback(),this}setFromEuler(kh,lh){if(!(kh&&kh.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const mh=kh._x,nh=kh._y,oh=kh._z,ph=kh._order,qh=Math.cos,rh=Math.sin,sh=qh(mh/2),th=qh(nh/2),uh=qh(oh/2),vh=rh(mh/2),wh=rh(nh/2),xh=rh(oh/2);switch(ph){case"XYZ":this._x=vh*th*uh+sh*wh*xh,this._y=sh*wh*uh-vh*th*xh,this._z=sh*th*xh+vh*wh*uh,this._w=sh*th*uh-vh*wh*xh;break;case"YXZ":this._x=vh*th*uh+sh*wh*xh,this._y=sh*wh*uh-vh*th*xh,this._z=sh*th*xh-vh*wh*uh,this._w=sh*th*uh+vh*wh*xh;break;case"ZXY":this._x=vh*th*uh-sh*wh*xh,this._y=sh*wh*uh+vh*th*xh,this._z=sh*th*xh+vh*wh*uh,this._w=sh*th*uh-vh*wh*xh;break;case"ZYX":this._x=vh*th*uh-sh*wh*xh,this._y=sh*wh*uh+vh*th*xh,this._z=sh*th*xh-vh*wh*uh,this._w=sh*th*uh+vh*wh*xh;break;case"YZX":this._x=vh*th*uh+sh*wh*xh,this._y=sh*wh*uh+vh*th*xh,this._z=sh*th*xh-vh*wh*uh,this._w=sh*th*uh-vh*wh*xh;break;case"XZY":this._x=vh*th*uh-sh*wh*xh,this._y=sh*wh*uh-vh*th*xh,this._z=sh*th*xh+vh*wh*uh,this._w=sh*th*uh+vh*wh*xh;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+ph)}return!1!==lh&&this._onChangeCallback(),this}setFromAxisAngle(yh,zh){const Ah=zh/2,Bh=Math.sin(Ah);return this._x=yh.x*Bh,this._y=yh.y*Bh,this._z=yh.z*Bh,this._w=Math.cos(Ah),this._onChangeCallback(),this}setFromRotationMatrix(Ch){const Dh=Ch.elements,Eh=Dh[0],Fh=Dh[4],Gh=Dh[8],Hh=Dh[1],Ih=Dh[5],Jh=Dh[9],Kh=Dh[2],Lh=Dh[6],Mh=Dh[10],Nh=Eh+Ih+Mh;if(Nh>0){const Oh=0.5/Math.sqrt(Nh+1);this._w=0.25/Oh,this._x=(Lh-Jh)*Oh,this._y=(Gh-Kh)*Oh,this._z=(Hh-Fh)*Oh}else if(Eh>Ih&&Eh>Mh){const Ph=2*Math.sqrt(1+Eh-Ih-Mh);this._w=(Lh-Jh)/Ph,this._x=0.25*Ph,this._y=(Fh+Hh)/Ph,this._z=(Gh+Kh)/Ph}else if(Ih>Mh){const Qh=2*Math.sqrt(1+Ih-Eh-Mh);this._w=(Gh-Kh)/Qh,this._x=(Fh+Hh)/Qh,this._y=0.25*Qh,this._z=(Jh+Lh)/Qh}else{const Rh=2*Math.sqrt(1+Mh-Eh-Ih);this._w=(Hh-Fh)/Rh,this._x=(Gh+Kh)/Rh,this._y=(Jh+Lh)/Rh,this._z=0.25*Rh}return this._onChangeCallback(),this}setFromUnitVectors(Sh,Th){let Uh=Sh.dot(Th)+1;return Uh<Number.EPSILON?(Uh=0,Math.abs(Sh.x)>Math.abs(Sh.z)?(this._x=-Sh.y,this._y=Sh.x,this._z=0,this._w=Uh):(this._x=0,this._y=-Sh.z,this._z=Sh.y,this._w=Uh)):(this._x=Sh.y*Th.z-Sh.z*Th.y,this._y=Sh.z*Th.x-Sh.x*Th.z,this._z=Sh.x*Th.y-Sh.y*Th.x,this._w=Uh),this.normalize()}angleTo(Vh){return 2*Math.acos(Math.abs(Y(this.dot(Vh),-1,1)))}rotateTowards(Wh,Xh){const Yh=this.angleTo(Wh);if(0===Yh)return this;const Zh=Math.min(1,Xh/Yh);return this.slerp(Wh,Zh),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot($h){return this._x*$h._x+this._y*$h._y+this._z*$h._z+this._w*$h._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let _h=this.length();return 0===_h?(this._x=0,this._y=0,this._z=0,this._w=1):(_h=1/_h,this._x=this._x*_h,this._y=this._y*_h,this._z=this._z*_h,this._w=this._w*_h),this._onChangeCallback(),this}multiply(ai,bi){return void 0!==bi?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(ai,bi)):this.multiplyQuaternions(this,ai)}premultiply(ci){return this.multiplyQuaternions(ci,this)}multiplyQuaternions(di,ei){const fi=di._x,gi=di._y,hi=di._z,ii=di._w,ji=ei._x,ki=ei._y,li=ei._z,mi=ei._w;return this._x=fi*mi+ii*ji+gi*li-hi*ki,this._y=gi*mi+ii*ki+hi*ji-fi*li,this._z=hi*mi+ii*li+fi*ki-gi*ji,this._w=ii*mi-fi*ji-gi*ki-hi*li,this._onChangeCallback(),this}slerp(ni,oi){if(0===oi)return this;if(1===oi)return this.copy(ni);const pi=this._x,qi=this._y,ri=this._z,si=this._w;let ti=si*ni._w+pi*ni._x+qi*ni._y+ri*ni._z;if(ti<0?(this._w=-ni._w,this._x=-ni._x,this._y=-ni._y,this._z=-ni._z,ti=-ti):this.copy(ni),ti>=1)return this._w=si,this._x=pi,this._y=qi,this._z=ri,this;const ui=1-ti*ti;if(ui<=Number.EPSILON){const vi=1-oi;return this._w=vi*si+oi*this._w,this._x=vi*pi+oi*this._x,this._y=vi*qi+oi*this._y,this._z=vi*ri+oi*this._z,this.normalize(),this._onChangeCallback(),this}const wi=Math.sqrt(ui),xi=Math.atan2(wi,ti),yi=Math.sin((1-oi)*xi)/wi,zi=Math.sin(oi*xi)/wi;return this._w=si*yi+this._w*zi,this._x=pi*yi+this._x*zi,this._y=qi*yi+this._y*zi,this._z=ri*yi+this._z*zi,this._onChangeCallback(),this}slerpQuaternions(Ai,Bi,Ci){this.copy(Ai).slerp(Bi,Ci)}random(){const Di=Math.random(),Ei=Math.sqrt(1-Di),Fi=Math.sqrt(Di),Gi=2*Math.PI*Math.random(),Hi=2*Math.PI*Math.random();return this.set(Ei*Math.cos(Gi),Fi*Math.sin(Hi),Fi*Math.cos(Hi),Ei*Math.sin(Gi))}equals(Ii){return Ii._x===this._x&&Ii._y===this._y&&Ii._z===this._z&&Ii._w===this._w}fromArray(Ji,Ki=0){return this._x=Ji[Ki],this._y=Ji[Ki+1],this._z=Ji[Ki+2],this._w=Ji[Ki+3],this._onChangeCallback(),this}toArray(Li=[],Mi=0){return Li[Mi]=this._x,Li[Mi+1]=this._y,Li[Mi+2]=this._z,Li[Mi+3]=this._w,Li}fromBufferAttribute(Ni,Oi){return this._x=Ni.getX(Oi),this._y=Ni.getY(Oi),this._z=Ni.getZ(Oi),this._w=Ni.getW(Oi),this}_onChange(Pi){return this._onChangeCallback=Pi,this}_onChangeCallback(){}}jg.prototype.isQuaternion=!0;class Qi{constructor(Ri=0,Si=0,Ti=0){this.x=Ri,this.y=Si,this.z=Ti}set(Ui,Vi,Wi){return void 0===Wi&&(Wi=this.z),this.x=Ui,this.y=Vi,this.z=Wi,this}setScalar(Xi){return this.x=Xi,this.y=Xi,this.z=Xi,this}setX(Yi){return this.x=Yi,this}setY(Zi){return this.y=Zi,this}setZ($i){return this.z=$i,this}setComponent(_i,aj){switch(_i){case 0:this.x=aj;break;case 1:this.y=aj;break;case 2:this.z=aj;break;default:throw new Error("index is out of range: "+_i)}return this}getComponent(bj){switch(bj){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+bj)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(cj){return this.x=cj.x,this.y=cj.y,this.z=cj.z,this}add(dj,ej){return void 0!==ej?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(dj,ej)):(this.x+=dj.x,this.y+=dj.y,this.z+=dj.z,this)}addScalar(fj){return this.x+=fj,this.y+=fj,this.z+=fj,this}addVectors(gj,hj){return this.x=gj.x+hj.x,this.y=gj.y+hj.y,this.z=gj.z+hj.z,this}addScaledVector(ij,jj){return this.x+=ij.x*jj,this.y+=ij.y*jj,this.z+=ij.z*jj,this}sub(kj,lj){return void 0!==lj?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(kj,lj)):(this.x-=kj.x,this.y-=kj.y,this.z-=kj.z,this)}subScalar(mj){return this.x-=mj,this.y-=mj,this.z-=mj,this}subVectors(nj,oj){return this.x=nj.x-oj.x,this.y=nj.y-oj.y,this.z=nj.z-oj.z,this}multiply(pj,qj){return void 0!==qj?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(pj,qj)):(this.x*=pj.x,this.y*=pj.y,this.z*=pj.z,this)}multiplyScalar(rj){return this.x*=rj,this.y*=rj,this.z*=rj,this}multiplyVectors(sj,tj){return this.x=sj.x*tj.x,this.y=sj.y*tj.y,this.z=sj.z*tj.z,this}applyEuler(uj){return uj&&uj.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(tl.setFromEuler(uj))}applyAxisAngle(vj,wj){return this.applyQuaternion(tl.setFromAxisAngle(vj,wj))}applyMatrix3(xj){const yj=this.x,zj=this.y,Aj=this.z,Bj=xj.elements;return this.x=Bj[0]*yj+Bj[3]*zj+Bj[6]*Aj,this.y=Bj[1]*yj+Bj[4]*zj+Bj[7]*Aj,this.z=Bj[2]*yj+Bj[5]*zj+Bj[8]*Aj,this}applyNormalMatrix(Cj){return this.applyMatrix3(Cj).normalize()}applyMatrix4(Dj){const Ej=this.x,Fj=this.y,Gj=this.z,Hj=Dj.elements,Ij=1/(Hj[3]*Ej+Hj[7]*Fj+Hj[11]*Gj+Hj[15]);return this.x=(Hj[0]*Ej+Hj[4]*Fj+Hj[8]*Gj+Hj[12])*Ij,this.y=(Hj[1]*Ej+Hj[5]*Fj+Hj[9]*Gj+Hj[13])*Ij,this.z=(Hj[2]*Ej+Hj[6]*Fj+Hj[10]*Gj+Hj[14])*Ij,this}applyQuaternion(Jj){const Kj=this.x,Lj=this.y,Mj=this.z,Nj=Jj.x,Oj=Jj.y,Pj=Jj.z,Qj=Jj.w,Rj=Qj*Kj+Oj*Mj-Pj*Lj,Sj=Qj*Lj+Pj*Kj-Nj*Mj,Tj=Qj*Mj+Nj*Lj-Oj*Kj,Uj=-Nj*Kj-Oj*Lj-Pj*Mj;return this.x=Rj*Qj+ -(Uj*Nj)+ -(Sj*Pj)- -(Tj*Oj),this.y=Sj*Qj+ -(Uj*Oj)+ -(Tj*Nj)- -(Rj*Pj),this.z=Tj*Qj+ -(Uj*Pj)+ -(Rj*Oj)- -(Sj*Nj),this}project(Vj){return this.applyMatrix4(Vj.matrixWorldInverse).applyMatrix4(Vj.projectionMatrix)}unproject(Wj){return this.applyMatrix4(Wj.projectionMatrixInverse).applyMatrix4(Wj.matrixWorld)}transformDirection(Xj){const Yj=this.x,Zj=this.y,$j=this.z,_j=Xj.elements;return this.x=_j[0]*Yj+_j[4]*Zj+_j[8]*$j,this.y=_j[1]*Yj+_j[5]*Zj+_j[9]*$j,this.z=_j[2]*Yj+_j[6]*Zj+_j[10]*$j,this.normalize()}divide(ak){return this.x/=ak.x,this.y/=ak.y,this.z/=ak.z,this}divideScalar(bk){return this.multiplyScalar(1/bk)}min(ck){return this.x=Math.min(this.x,ck.x),this.y=Math.min(this.y,ck.y),this.z=Math.min(this.z,ck.z),this}max(dk){return this.x=Math.max(this.x,dk.x),this.y=Math.max(this.y,dk.y),this.z=Math.max(this.z,dk.z),this}clamp(ek,fk){return this.x=Math.max(ek.x,Math.min(fk.x,this.x)),this.y=Math.max(ek.y,Math.min(fk.y,this.y)),this.z=Math.max(ek.z,Math.min(fk.z,this.z)),this}clampScalar(gk,hk){return this.x=Math.max(gk,Math.min(hk,this.x)),this.y=Math.max(gk,Math.min(hk,this.y)),this.z=Math.max(gk,Math.min(hk,this.z)),this}clampLength(ik,jk){const kk=this.length();return this.divideScalar(kk||1).multiplyScalar(Math.max(ik,Math.min(jk,kk)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(lk){return this.x*lk.x+this.y*lk.y+this.z*lk.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(mk){return this.normalize().multiplyScalar(mk)}lerp(nk,ok){return this.x+=(nk.x-this.x)*ok,this.y+=(nk.y-this.y)*ok,this.z+=(nk.z-this.z)*ok,this}lerpVectors(pk,qk,rk){return this.x=pk.x+(qk.x-pk.x)*rk,this.y=pk.y+(qk.y-pk.y)*rk,this.z=pk.z+(qk.z-pk.z)*rk,this}cross(sk,tk){return void 0!==tk?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(sk,tk)):this.crossVectors(this,sk)}crossVectors(uk,vk){const wk=uk.x,xk=uk.y,yk=uk.z,zk=vk.x,Ak=vk.y,Bk=vk.z;return this.x=xk*Bk-yk*Ak,this.y=yk*zk-wk*Bk,this.z=wk*Ak-xk*zk,this}projectOnVector(Ck){const Dk=Ck.lengthSq();if(0===Dk)return this.set(0,0,0);const Ek=Ck.dot(this)/Dk;return this.copy(Ck).multiplyScalar(Ek)}projectOnPlane(Fk){return sl.copy(this).projectOnVector(Fk),this.sub(sl)}reflect(Gk){return this.sub(sl.copy(Gk).multiplyScalar(2*this.dot(Gk)))}angleTo(Hk){const Ik=Math.sqrt(this.lengthSq()*Hk.lengthSq());if(0===Ik)return Math.PI/2;const Jk=this.dot(Hk)/Ik;return Math.acos(Y(Jk,-1,1))}distanceTo(Kk){return Math.sqrt(this.distanceToSquared(Kk))}distanceToSquared(Lk){const Mk=this.x-Lk.x,Nk=this.y-Lk.y,Ok=this.z-Lk.z;return Mk*Mk+Nk*Nk+Ok*Ok}manhattanDistanceTo(Pk){return Math.abs(this.x-Pk.x)+Math.abs(this.y-Pk.y)+Math.abs(this.z-Pk.z)}setFromSpherical(Qk){return this.setFromSphericalCoords(Qk.radius,Qk.phi,Qk.theta)}setFromSphericalCoords(Rk,Sk,Tk){const Uk=Math.sin(Sk)*Rk;return this.x=Uk*Math.sin(Tk),this.y=Math.cos(Sk)*Rk,this.z=Uk*Math.cos(Tk),this}setFromCylindrical(Vk){return this.setFromCylindricalCoords(Vk.radius,Vk.theta,Vk.y)}setFromCylindricalCoords(Wk,Xk,Yk){return this.x=Wk*Math.sin(Xk),this.y=Yk,this.z=Wk*Math.cos(Xk),this}setFromMatrixPosition(Zk){const $k=Zk.elements;return this.x=$k[12],this.y=$k[13],this.z=$k[14],this}setFromMatrixScale(_k){const al=this.setFromMatrixColumn(_k,0).length(),bl=this.setFromMatrixColumn(_k,1).length(),cl=this.setFromMatrixColumn(_k,2).length();return this.x=al,this.y=bl,this.z=cl,this}setFromMatrixColumn(dl,el){return this.fromArray(dl.elements,4*el)}setFromMatrix3Column(fl,gl){return this.fromArray(fl.elements,3*gl)}equals(hl){return hl.x===this.x&&hl.y===this.y&&hl.z===this.z}fromArray(il,jl=0){return this.x=il[jl],this.y=il[jl+1],this.z=il[jl+2],this}toArray(kl=[],ll=0){return kl[ll]=this.x,kl[ll+1]=this.y,kl[ll+2]=this.z,kl}fromBufferAttribute(ml,nl,ol){return void 0!==ol&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=ml.getX(nl),this.y=ml.getY(nl),this.z=ml.getZ(nl),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const pl=(Math.random()-0.5)*2,ql=Math.random()*Math.PI*2,rl=Math.sqrt(1-pl**2);return this.x=rl*Math.cos(ql),this.y=rl*Math.sin(ql),this.z=pl,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}Qi.prototype.isVector3=!0;const sl=new Qi(),tl=new jg();class ul{constructor(vl=new Qi(Infinity,Infinity,Infinity),wl=new Qi(-1/0,-1/0,-1/0)){this.min=vl,this.max=wl}set(xl,yl){return this.min.copy(xl),this.max.copy(yl),this}setFromArray(zl){let Al=Infinity,Bl=Infinity,Cl=Infinity,Dl=-1/0,El=-1/0,Fl=-1/0;for(let Gl=0,Hl=zl.length;Gl<Hl;Gl+=3){const Il=zl[Gl],Jl=zl[Gl+1],Kl=zl[Gl+2];Il<Al&&(Al=Il),Jl<Bl&&(Bl=Jl),Kl<Cl&&(Cl=Kl),Il>Dl&&(Dl=Il),Jl>El&&(El=Jl),Kl>Fl&&(Fl=Kl)}return this.min.set(Al,Bl,Cl),this.max.set(Dl,El,Fl),this}setFromBufferAttribute(Ll){let Ml=Infinity,Nl=Infinity,Ol=Infinity,Pl=-1/0,Ql=-1/0,Rl=-1/0;for(let Sl=0,Tl=Ll.count;Sl<Tl;Sl++){const Ul=Ll.getX(Sl),Vl=Ll.getY(Sl),Wl=Ll.getZ(Sl);Ul<Ml&&(Ml=Ul),Vl<Nl&&(Nl=Vl),Wl<Ol&&(Ol=Wl),Ul>Pl&&(Pl=Ul),Vl>Ql&&(Ql=Vl),Wl>Rl&&(Rl=Wl)}return this.min.set(Ml,Nl,Ol),this.max.set(Pl,Ql,Rl),this}setFromPoints(Xl){this.makeEmpty();for(let Yl=0,Zl=Xl.length;Yl<Zl;Yl++)this.expandByPoint(Xl[Yl]);return this}setFromCenterAndSize($l,_l){const am=Jm.copy(_l).multiplyScalar(0.5);return this.min.copy($l).sub(am),this.max.copy($l).add(am),this}setFromObject(bm){return this.makeEmpty(),this.expandByObject(bm)}clone(){return new this.constructor().copy(this)}copy(cm){return this.min.copy(cm.min),this.max.copy(cm.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=Infinity,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(dm){return this.isEmpty()?dm.set(0,0,0):dm.addVectors(this.min,this.max).multiplyScalar(0.5)}getSize(em){return this.isEmpty()?em.set(0,0,0):em.subVectors(this.max,this.min)}expandByPoint(fm){return this.min.min(fm),this.max.max(fm),this}expandByVector(gm){return this.min.sub(gm),this.max.add(gm),this}expandByScalar(hm){return this.min.addScalar(-hm),this.max.addScalar(hm),this}expandByObject(im){im.updateWorldMatrix(!1,!1);const jm=im.geometry;void 0!==jm&&(null===jm.boundingBox&&jm.computeBoundingBox(),Km.copy(jm.boundingBox),Km.applyMatrix4(im.matrixWorld),this.union(Km));const km=im.children;for(let lm=0,mm=km.length;lm<mm;lm++)this.expandByObject(km[lm]);return this}containsPoint(nm){return!(nm.x<this.min.x)&&!(nm.x>this.max.x)&&!(nm.y<this.min.y)&&!(nm.y>this.max.y)&&!(nm.z<this.min.z)&&!(nm.z>this.max.z)}containsBox(om){return this.min.x<=om.min.x&&om.max.x<=this.max.x&&this.min.y<=om.min.y&&om.max.y<=this.max.y&&this.min.z<=om.min.z&&om.max.z<=this.max.z}getParameter(pm,qm){return qm.set((pm.x-this.min.x)/(this.max.x-this.min.x),(pm.y-this.min.y)/(this.max.y-this.min.y),(pm.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(rm){return!(rm.max.x<this.min.x)&&!(rm.min.x>this.max.x)&&!(rm.max.y<this.min.y)&&!(rm.min.y>this.max.y)&&!(rm.max.z<this.min.z)&&!(rm.min.z>this.max.z)}intersectsSphere(sm){return this.clampPoint(sm.center,Jm),Jm.distanceToSquared(sm.center)<=sm.radius*sm.radius}intersectsPlane(tm){let um,vm;return tm.normal.x>0?(um=tm.normal.x*this.min.x,vm=tm.normal.x*this.max.x):(um=tm.normal.x*this.max.x,vm=tm.normal.x*this.min.x),tm.normal.y>0?(um+=tm.normal.y*this.min.y,vm+=tm.normal.y*this.max.y):(um+=tm.normal.y*this.max.y,vm+=tm.normal.y*this.min.y),tm.normal.z>0?(um+=tm.normal.z*this.min.z,vm+=tm.normal.z*this.max.z):(um+=tm.normal.z*this.max.z,vm+=tm.normal.z*this.min.z),um<= -tm.constant&&vm>= -tm.constant}intersectsTriangle(wm){if(this.isEmpty())return!1;this.getCenter(Rm),Sm.subVectors(this.max,Rm),Lm.subVectors(wm.a,Rm),Mm.subVectors(wm.b,Rm),Nm.subVectors(wm.c,Rm),Om.subVectors(Mm,Lm),Pm.subVectors(Nm,Mm),Qm.subVectors(Lm,Nm);let xm=[0,-Om.z,Om.y,0,-Pm.z,Pm.y,0,-Qm.z,Qm.y,Om.z,0,-Om.x,Pm.z,0,-Pm.x,Qm.z,0,-Qm.x,-Om.y,Om.x,0,-Pm.y,Pm.x,0,-Qm.y,Qm.x,0];return!!Vm(xm,Lm,Mm,Nm,Sm)&& !!Vm(xm=[1,0,0,0,1,0,0,0,1],Lm,Mm,Nm,Sm)&&(Tm.crossVectors(Om,Pm),Vm(xm=[Tm.x,Tm.y,Tm.z],Lm,Mm,Nm,Sm))}clampPoint(ym,zm){return zm.copy(ym).clamp(this.min,this.max)}distanceToPoint(Am){const Bm=Jm.copy(Am).clamp(this.min,this.max);return Bm.sub(Am).length()}getBoundingSphere(Cm){return this.getCenter(Cm.center),Cm.radius=0.5*this.getSize(Jm).length(),Cm}intersect(Dm){return this.min.max(Dm.min),this.max.min(Dm.max),this.isEmpty()&&this.makeEmpty(),this}union(Em){return this.min.min(Em.min),this.max.max(Em.max),this}applyMatrix4(Fm){return this.isEmpty()||(Im[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(Fm),Im[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(Fm),Im[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(Fm),Im[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(Fm),Im[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(Fm),Im[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(Fm),Im[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(Fm),Im[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(Fm),this.setFromPoints(Im)),this}translate(Gm){return this.min.add(Gm),this.max.add(Gm),this}equals(Hm){return Hm.min.equals(this.min)&&Hm.max.equals(this.max)}}ul.prototype.isBox3=!0;const Im=[new Qi(),new Qi(),new Qi(),new Qi(),new Qi(),new Qi(),new Qi(),new Qi()],Jm=new Qi(),Km=new ul(),Lm=new Qi(),Mm=new Qi(),Nm=new Qi(),Om=new Qi(),Pm=new Qi(),Qm=new Qi(),Rm=new Qi(),Sm=new Qi(),Tm=new Qi(),Um=new Qi();function Vm(a,b,c,d,e){for(let f=0,g=a.length-3;f<=g;f+=3){Um.fromArray(a,f);const h=e.x*Math.abs(Um.x)+e.y*Math.abs(Um.y)+e.z*Math.abs(Um.z),i=b.dot(Um),j=c.dot(Um),k=d.dot(Um);if(Math.max(-Math.max(i,j,k),Math.min(i,j,k))>h)return!1}return!0}const Wm=new ul(),Xm=new Qi(),Ym=new Qi(),Zm=new Qi();class $m{constructor(_m=new Qi(),an=-1){this.center=_m,this.radius=an}set(bn,cn){return this.center.copy(bn),this.radius=cn,this}setFromPoints(dn,en){const fn=this.center;void 0!==en?fn.copy(en):Wm.setFromPoints(dn).getCenter(fn);let gn=0;for(let hn=0,jn=dn.length;hn<jn;hn++)gn=Math.max(gn,fn.distanceToSquared(dn[hn]));return this.radius=Math.sqrt(gn),this}copy(kn){return this.center.copy(kn.center),this.radius=kn.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(ln){return ln.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(mn){return mn.distanceTo(this.center)-this.radius}intersectsSphere(nn){const on=this.radius+nn.radius;return nn.center.distanceToSquared(this.center)<=on*on}intersectsBox(pn){return pn.intersectsSphere(this)}intersectsPlane(qn){return Math.abs(qn.distanceToPoint(this.center))<=this.radius}clampPoint(rn,sn){const tn=this.center.distanceToSquared(rn);return sn.copy(rn),tn>this.radius*this.radius&&(sn.sub(this.center).normalize(),sn.multiplyScalar(this.radius).add(this.center)),sn}getBoundingBox(un){return this.isEmpty()?(un.makeEmpty(),un):(un.set(this.center,this.center),un.expandByScalar(this.radius),un)}applyMatrix4(vn){return this.center.applyMatrix4(vn),this.radius=this.radius*vn.getMaxScaleOnAxis(),this}translate(wn){return this.center.add(wn),this}expandByPoint(xn){Zm.subVectors(xn,this.center);const yn=Zm.lengthSq();if(yn>this.radius*this.radius){const zn=Math.sqrt(yn),An=(zn-this.radius)*0.5;this.center.add(Zm.multiplyScalar(An/zn)),this.radius+=An}return this}union(Bn){return Ym.subVectors(Bn.center,this.center).normalize().multiplyScalar(Bn.radius),this.expandByPoint(Xm.copy(Bn.center).add(Ym)),this.expandByPoint(Xm.copy(Bn.center).sub(Ym)),this}equals(Cn){return Cn.center.equals(this.center)&&Cn.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Dn=new Qi(),En=new Qi(),Fn=new Qi(),Gn=new Qi(),Hn=new Qi(),In=new Qi(),Jn=new Qi();class Kn{constructor(Ln=new Qi(),Mn=new Qi(0,0,-1)){this.origin=Ln,this.direction=Mn}set(Nn,On){return this.origin.copy(Nn),this.direction.copy(On),this}copy(Pn){return this.origin.copy(Pn.origin),this.direction.copy(Pn.direction),this}at(Qn,Rn){return Rn.copy(this.direction).multiplyScalar(Qn).add(this.origin)}lookAt(Sn){return this.direction.copy(Sn).sub(this.origin).normalize(),this}recast(Tn){return this.origin.copy(this.at(Tn,Dn)),this}closestPointToPoint(Un,Vn){Vn.subVectors(Un,this.origin);const Wn=Vn.dot(this.direction);return Wn<0?Vn.copy(this.origin):Vn.copy(this.direction).multiplyScalar(Wn).add(this.origin)}distanceToPoint(Xn){return Math.sqrt(this.distanceSqToPoint(Xn))}distanceSqToPoint(Yn){const Zn=Dn.subVectors(Yn,this.origin).dot(this.direction);return Zn<0?this.origin.distanceToSquared(Yn):(Dn.copy(this.direction).multiplyScalar(Zn).add(this.origin),Dn.distanceToSquared(Yn))}distanceSqToSegment($n,_n,ao,bo){En.copy($n).add(_n).multiplyScalar(0.5),Fn.copy(_n).sub($n).normalize(),Gn.copy(this.origin).sub(En);const co=0.5*$n.distanceTo(_n),eo=-this.direction.dot(Fn),fo=Gn.dot(this.direction),go=-Gn.dot(Fn),ho=Gn.lengthSq(),io=Math.abs(1-eo*eo);let jo,ko,lo,mo;if(io>0)if(jo=eo*go-fo,ko=eo*fo-go,mo=co*io,jo>=0)if(ko>= -mo)if(ko<=mo){const no=1/io;jo*=no,ko*=no,lo=jo*(jo+eo*ko+2*fo)+ko*(eo*jo+ko+2*go)+ho}else lo=-(jo=Math.max(0,-(eo*(ko=co)+fo)))*jo+ko*(ko+2*go)+ho;else lo=-(jo=Math.max(0,-(eo*(ko=-co)+fo)))*jo+ko*(ko+2*go)+ho;else ko<= -mo?(ko=(jo=Math.max(0,-(-eo*co+fo)))>0?-co:Math.min(Math.max(-co,-go),co),lo=-jo*jo+ko*(ko+2*go)+ho):ko<=mo?(jo=0,lo=(ko=Math.min(Math.max(-co,-go),co))*(ko+2*go)+ho):(ko=(jo=Math.max(0,-(eo*co+fo)))>0?co:Math.min(Math.max(-co,-go),co),lo=-jo*jo+ko*(ko+2*go)+ho);else ko=eo>0?-co:co,jo=Math.max(0,-(eo*ko+fo)),lo=-jo*jo+ko*(ko+2*go)+ho;return ao&&ao.copy(this.direction).multiplyScalar(jo).add(this.origin),bo&&bo.copy(Fn).multiplyScalar(ko).add(En),lo}intersectSphere(oo,po){Dn.subVectors(oo.center,this.origin);const qo=Dn.dot(this.direction),ro=Dn.dot(Dn)-qo*qo,so=oo.radius*oo.radius;if(ro>so)return null;const to=Math.sqrt(so-ro),uo=qo-to,vo=qo+to;return uo<0&&vo<0?null:uo<0?this.at(vo,po):this.at(uo,po)}intersectsSphere(wo){return this.distanceSqToPoint(wo.center)<=wo.radius*wo.radius}distanceToPlane(xo){const yo=xo.normal.dot(this.direction);if(0===yo)return 0===xo.distanceToPoint(this.origin)?0:null;const zo=-(this.origin.dot(xo.normal)+xo.constant)/yo;return zo>=0?zo:null}intersectPlane(Ao,Bo){const Co=this.distanceToPlane(Ao);return null===Co?null:this.at(Co,Bo)}intersectsPlane(Do){const Eo=Do.distanceToPoint(this.origin);if(0===Eo)return!0;const Fo=Do.normal.dot(this.direction);return Fo*Eo<0}intersectBox(Go,Ho){let Io,Jo,Ko,Lo,Mo,No;const Oo=1/this.direction.x,Po=1/this.direction.y,Qo=1/this.direction.z,Ro=this.origin;return(Oo>=0?(Io=(Go.min.x-Ro.x)*Oo,Jo=(Go.max.x-Ro.x)*Oo):(Io=(Go.max.x-Ro.x)*Oo,Jo=(Go.min.x-Ro.x)*Oo),Po>=0?(Ko=(Go.min.y-Ro.y)*Po,Lo=(Go.max.y-Ro.y)*Po):(Ko=(Go.max.y-Ro.y)*Po,Lo=(Go.min.y-Ro.y)*Po),Io>Lo||Ko>Jo)?null:((Ko>Io||Io!=Io)&&(Io=Ko),(Lo<Jo||Jo!=Jo)&&(Jo=Lo),Qo>=0?(Mo=(Go.min.z-Ro.z)*Qo,No=(Go.max.z-Ro.z)*Qo):(Mo=(Go.max.z-Ro.z)*Qo,No=(Go.min.z-Ro.z)*Qo),Io>No||Mo>Jo)?null:((Mo>Io||Io!=Io)&&(Io=Mo),(No<Jo||Jo!=Jo)&&(Jo=No),Jo<0)?null:this.at(Io>=0?Io:Jo,Ho)}intersectsBox(So){return null!==this.intersectBox(So,Dn)}intersectTriangle(To,Uo,Vo,Wo,Xo){Hn.subVectors(Uo,To),In.subVectors(Vo,To),Jn.crossVectors(Hn,In);let Yo=this.direction.dot(Jn),Zo;if(Yo>0){if(Wo)return null;Zo=1}else{if(!(Yo<0))return null;Zo=-1,Yo=-Yo}Gn.subVectors(this.origin,To);const $o=Zo*this.direction.dot(In.crossVectors(Gn,In));if($o<0)return null;const _o=Zo*this.direction.dot(Hn.cross(Gn));if(_o<0)return null;if($o+_o>Yo)return null;const ap=-Zo*Gn.dot(Jn);return ap<0?null:this.at(ap/Yo,Xo)}applyMatrix4(bp){return this.origin.applyMatrix4(bp),this.direction.transformDirection(bp),this}equals(cp){return cp.origin.equals(this.origin)&&cp.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class dp{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(ep,fp,gp,hp,ip,jp,kp,lp,mp,np,op,pp,qp,rp,sp,tp){const up=this.elements;return up[0]=ep,up[4]=fp,up[8]=gp,up[12]=hp,up[1]=ip,up[5]=jp,up[9]=kp,up[13]=lp,up[2]=mp,up[6]=np,up[10]=op,up[14]=pp,up[3]=qp,up[7]=rp,up[11]=sp,up[15]=tp,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new dp().fromArray(this.elements)}copy(vp){const wp=this.elements,xp=vp.elements;return wp[0]=xp[0],wp[1]=xp[1],wp[2]=xp[2],wp[3]=xp[3],wp[4]=xp[4],wp[5]=xp[5],wp[6]=xp[6],wp[7]=xp[7],wp[8]=xp[8],wp[9]=xp[9],wp[10]=xp[10],wp[11]=xp[11],wp[12]=xp[12],wp[13]=xp[13],wp[14]=xp[14],wp[15]=xp[15],this}copyPosition(yp){const zp=this.elements,Ap=yp.elements;return zp[12]=Ap[12],zp[13]=Ap[13],zp[14]=Ap[14],this}setFromMatrix3(Bp){const Cp=Bp.elements;return this.set(Cp[0],Cp[3],Cp[6],0,Cp[1],Cp[4],Cp[7],0,Cp[2],Cp[5],Cp[8],0,0,0,0,1),this}extractBasis(Dp,Ep,Fp){return Dp.setFromMatrixColumn(this,0),Ep.setFromMatrixColumn(this,1),Fp.setFromMatrixColumn(this,2),this}makeBasis(Gp,Hp,Ip){return this.set(Gp.x,Hp.x,Ip.x,0,Gp.y,Hp.y,Ip.y,0,Gp.z,Hp.z,Ip.z,0,0,0,0,1),this}extractRotation(Jp){const Kp=this.elements,Lp=Jp.elements,Mp=1/au.setFromMatrixColumn(Jp,0).length(),Np=1/au.setFromMatrixColumn(Jp,1).length(),Op=1/au.setFromMatrixColumn(Jp,2).length();return Kp[0]=Lp[0]*Mp,Kp[1]=Lp[1]*Mp,Kp[2]=Lp[2]*Mp,Kp[3]=0,Kp[4]=Lp[4]*Np,Kp[5]=Lp[5]*Np,Kp[6]=Lp[6]*Np,Kp[7]=0,Kp[8]=Lp[8]*Op,Kp[9]=Lp[9]*Op,Kp[10]=Lp[10]*Op,Kp[11]=0,Kp[12]=0,Kp[13]=0,Kp[14]=0,Kp[15]=1,this}makeRotationFromEuler(Pp){Pp&&Pp.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const Qp=this.elements,Rp=Pp.x,Sp=Pp.y,Tp=Pp.z,Up=Math.cos(Rp),Vp=Math.sin(Rp),Wp=Math.cos(Sp),Xp=Math.sin(Sp),Yp=Math.cos(Tp),Zp=Math.sin(Tp);if("XYZ"===Pp.order){const $p=Up*Yp,_p=Up*Zp,aq=Vp*Yp,bq=Vp*Zp;Qp[0]=Wp*Yp,Qp[4]=-Wp*Zp,Qp[8]=Xp,Qp[1]=_p+aq*Xp,Qp[5]=$p-bq*Xp,Qp[9]=-Vp*Wp,Qp[2]=bq-$p*Xp,Qp[6]=aq+_p*Xp,Qp[10]=Up*Wp}else if("YXZ"===Pp.order){const cq=Wp*Yp,dq=Wp*Zp,eq=Xp*Yp,fq=Xp*Zp;Qp[0]=cq+fq*Vp,Qp[4]=eq*Vp-dq,Qp[8]=Up*Xp,Qp[1]=Up*Zp,Qp[5]=Up*Yp,Qp[9]=-Vp,Qp[2]=dq*Vp-eq,Qp[6]=fq+cq*Vp,Qp[10]=Up*Wp}else if("ZXY"===Pp.order){const gq=Wp*Yp,hq=Wp*Zp,iq=Xp*Yp,jq=Xp*Zp;Qp[0]=gq-jq*Vp,Qp[4]=-Up*Zp,Qp[8]=iq+hq*Vp,Qp[1]=hq+iq*Vp,Qp[5]=Up*Yp,Qp[9]=jq-gq*Vp,Qp[2]=-Up*Xp,Qp[6]=Vp,Qp[10]=Up*Wp}else if("ZYX"===Pp.order){const kq=Up*Yp,lq=Up*Zp,mq=Vp*Yp,nq=Vp*Zp;Qp[0]=Wp*Yp,Qp[4]=mq*Xp-lq,Qp[8]=kq*Xp+nq,Qp[1]=Wp*Zp,Qp[5]=nq*Xp+kq,Qp[9]=lq*Xp-mq,Qp[2]=-Xp,Qp[6]=Vp*Wp,Qp[10]=Up*Wp}else if("YZX"===Pp.order){const oq=Up*Wp,pq=Up*Xp,qq=Vp*Wp,rq=Vp*Xp;Qp[0]=Wp*Yp,Qp[4]=rq-oq*Zp,Qp[8]=qq*Zp+pq,Qp[1]=Zp,Qp[5]=Up*Yp,Qp[9]=-Vp*Yp,Qp[2]=-Xp*Yp,Qp[6]=pq*Zp+qq,Qp[10]=oq-rq*Zp}else if("XZY"===Pp.order){const sq=Up*Wp,tq=Up*Xp,uq=Vp*Wp,vq=Vp*Xp;Qp[0]=Wp*Yp,Qp[4]=-Zp,Qp[8]=Xp*Yp,Qp[1]=sq*Zp+vq,Qp[5]=Up*Yp,Qp[9]=tq*Zp-uq,Qp[2]=uq*Zp-tq,Qp[6]=Vp*Yp,Qp[10]=vq*Zp+sq}return Qp[3]=0,Qp[7]=0,Qp[11]=0,Qp[12]=0,Qp[13]=0,Qp[14]=0,Qp[15]=1,this}makeRotationFromQuaternion(wq){return this.compose(cu,wq,du)}lookAt(xq,yq,zq){const Aq=this.elements;return gu.subVectors(xq,yq),0===gu.lengthSq()&&(gu.z=1),gu.normalize(),eu.crossVectors(zq,gu),0===eu.lengthSq()&&(1===Math.abs(zq.z)?gu.x+=0.0001:gu.z+=0.0001,gu.normalize(),eu.crossVectors(zq,gu)),eu.normalize(),fu.crossVectors(gu,eu),Aq[0]=eu.x,Aq[4]=fu.x,Aq[8]=gu.x,Aq[1]=eu.y,Aq[5]=fu.y,Aq[9]=gu.y,Aq[2]=eu.z,Aq[6]=fu.z,Aq[10]=gu.z,this}multiply(Bq,Cq){return void 0!==Cq?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(Bq,Cq)):this.multiplyMatrices(this,Bq)}premultiply(Dq){return this.multiplyMatrices(Dq,this)}multiplyMatrices(Eq,Fq){const Gq=Eq.elements,Hq=Fq.elements,Iq=this.elements,Jq=Gq[0],Kq=Gq[4],Lq=Gq[8],Mq=Gq[12],Nq=Gq[1],Oq=Gq[5],Pq=Gq[9],Qq=Gq[13],Rq=Gq[2],Sq=Gq[6],Tq=Gq[10],Uq=Gq[14],Vq=Gq[3],Wq=Gq[7],Xq=Gq[11],Yq=Gq[15],Zq=Hq[0],$q=Hq[4],_q=Hq[8],ar=Hq[12],br=Hq[1],cr=Hq[5],dr=Hq[9],er=Hq[13],fr=Hq[2],gr=Hq[6],hr=Hq[10],ir=Hq[14],jr=Hq[3],kr=Hq[7],lr=Hq[11],mr=Hq[15];return Iq[0]=Jq*Zq+Kq*br+Lq*fr+Mq*jr,Iq[4]=Jq*$q+Kq*cr+Lq*gr+Mq*kr,Iq[8]=Jq*_q+Kq*dr+Lq*hr+Mq*lr,Iq[12]=Jq*ar+Kq*er+Lq*ir+Mq*mr,Iq[1]=Nq*Zq+Oq*br+Pq*fr+Qq*jr,Iq[5]=Nq*$q+Oq*cr+Pq*gr+Qq*kr,Iq[9]=Nq*_q+Oq*dr+Pq*hr+Qq*lr,Iq[13]=Nq*ar+Oq*er+Pq*ir+Qq*mr,Iq[2]=Rq*Zq+Sq*br+Tq*fr+Uq*jr,Iq[6]=Rq*$q+Sq*cr+Tq*gr+Uq*kr,Iq[10]=Rq*_q+Sq*dr+Tq*hr+Uq*lr,Iq[14]=Rq*ar+Sq*er+Tq*ir+Uq*mr,Iq[3]=Vq*Zq+Wq*br+Xq*fr+Yq*jr,Iq[7]=Vq*$q+Wq*cr+Xq*gr+Yq*kr,Iq[11]=Vq*_q+Wq*dr+Xq*hr+Yq*lr,Iq[15]=Vq*ar+Wq*er+Xq*ir+Yq*mr,this}multiplyScalar(nr){const or=this.elements;return or[0]*=nr,or[4]*=nr,or[8]*=nr,or[12]*=nr,or[1]*=nr,or[5]*=nr,or[9]*=nr,or[13]*=nr,or[2]*=nr,or[6]*=nr,or[10]*=nr,or[14]*=nr,or[3]*=nr,or[7]*=nr,or[11]*=nr,or[15]*=nr,this}determinant(){const pr=this.elements,qr=pr[0],rr=pr[4],sr=pr[8],tr=pr[12],ur=pr[1],vr=pr[5],wr=pr[9],xr=pr[13],yr=pr[2],zr=pr[6],Ar=pr[10],Br=pr[14],Cr=pr[3],Dr=pr[7],Er=pr[11],Fr=pr[15];return Cr*(+tr*wr*zr-sr*xr*zr-tr*vr*Ar+rr*xr*Ar+sr*vr*Br-rr*wr*Br)+Dr*(+qr*wr*Br-qr*xr*Ar+tr*ur*Ar-sr*ur*Br+sr*xr*yr-tr*wr*yr)+Er*(+qr*xr*zr-qr*vr*Br-tr*ur*zr+rr*ur*Br+tr*vr*yr-rr*xr*yr)+Fr*(-sr*vr*yr-qr*wr*zr+qr*vr*Ar+sr*ur*zr-rr*ur*Ar+rr*wr*yr)}transpose(){const Gr=this.elements;let Hr;return Hr=Gr[1],Gr[1]=Gr[4],Gr[4]=Hr,Hr=Gr[2],Gr[2]=Gr[8],Gr[8]=Hr,Hr=Gr[6],Gr[6]=Gr[9],Gr[9]=Hr,Hr=Gr[3],Gr[3]=Gr[12],Gr[12]=Hr,Hr=Gr[7],Gr[7]=Gr[13],Gr[13]=Hr,Hr=Gr[11],Gr[11]=Gr[14],Gr[14]=Hr,this}setPosition(Ir,Jr,Kr){const Lr=this.elements;return Ir.isVector3?(Lr[12]=Ir.x,Lr[13]=Ir.y,Lr[14]=Ir.z):(Lr[12]=Ir,Lr[13]=Jr,Lr[14]=Kr),this}invert(){const Mr=this.elements,Nr=Mr[0],Or=Mr[1],Pr=Mr[2],Qr=Mr[3],Rr=Mr[4],Sr=Mr[5],Tr=Mr[6],Ur=Mr[7],Vr=Mr[8],Wr=Mr[9],Xr=Mr[10],Yr=Mr[11],Zr=Mr[12],$r=Mr[13],_r=Mr[14],as=Mr[15],bs=Wr*_r*Ur-$r*Xr*Ur+$r*Tr*Yr-Sr*_r*Yr-Wr*Tr*as+Sr*Xr*as,cs=Zr*Xr*Ur-Vr*_r*Ur-Zr*Tr*Yr+Rr*_r*Yr+Vr*Tr*as-Rr*Xr*as,ds=Vr*$r*Ur-Zr*Wr*Ur+Zr*Sr*Yr-Rr*$r*Yr-Vr*Sr*as+Rr*Wr*as,es=Zr*Wr*Tr-Vr*$r*Tr-Zr*Sr*Xr+Rr*$r*Xr+Vr*Sr*_r-Rr*Wr*_r,fs=Nr*bs+Or*cs+Pr*ds+Qr*es;if(0===fs)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const gs=1/fs;return Mr[0]=bs*gs,Mr[1]=($r*Xr*Qr-Wr*_r*Qr-$r*Pr*Yr+Or*_r*Yr+Wr*Pr*as-Or*Xr*as)*gs,Mr[2]=(Sr*_r*Qr-$r*Tr*Qr+$r*Pr*Ur-Or*_r*Ur-Sr*Pr*as+Or*Tr*as)*gs,Mr[3]=(Wr*Tr*Qr-Sr*Xr*Qr-Wr*Pr*Ur+Or*Xr*Ur+Sr*Pr*Yr-Or*Tr*Yr)*gs,Mr[4]=cs*gs,Mr[5]=(Vr*_r*Qr-Zr*Xr*Qr+Zr*Pr*Yr-Nr*_r*Yr-Vr*Pr*as+Nr*Xr*as)*gs,Mr[6]=(Zr*Tr*Qr-Rr*_r*Qr-Zr*Pr*Ur+Nr*_r*Ur+Rr*Pr*as-Nr*Tr*as)*gs,Mr[7]=(Rr*Xr*Qr-Vr*Tr*Qr+Vr*Pr*Ur-Nr*Xr*Ur-Rr*Pr*Yr+Nr*Tr*Yr)*gs,Mr[8]=ds*gs,Mr[9]=(Zr*Wr*Qr-Vr*$r*Qr-Zr*Or*Yr+Nr*$r*Yr+Vr*Or*as-Nr*Wr*as)*gs,Mr[10]=(Rr*$r*Qr-Zr*Sr*Qr+Zr*Or*Ur-Nr*$r*Ur-Rr*Or*as+Nr*Sr*as)*gs,Mr[11]=(Vr*Sr*Qr-Rr*Wr*Qr-Vr*Or*Ur+Nr*Wr*Ur+Rr*Or*Yr-Nr*Sr*Yr)*gs,Mr[12]=es*gs,Mr[13]=(Vr*$r*Pr-Zr*Wr*Pr+Zr*Or*Xr-Nr*$r*Xr-Vr*Or*_r+Nr*Wr*_r)*gs,Mr[14]=(Zr*Sr*Pr-Rr*$r*Pr-Zr*Or*Tr+Nr*$r*Tr+Rr*Or*_r-Nr*Sr*_r)*gs,Mr[15]=(Rr*Wr*Pr-Vr*Sr*Pr+Vr*Or*Tr-Nr*Wr*Tr-Rr*Or*Xr+Nr*Sr*Xr)*gs,this}scale(hs){const is=this.elements,js=hs.x,ks=hs.y,ls=hs.z;return is[0]*=js,is[4]*=ks,is[8]*=ls,is[1]*=js,is[5]*=ks,is[9]*=ls,is[2]*=js,is[6]*=ks,is[10]*=ls,is[3]*=js,is[7]*=ks,is[11]*=ls,this}getMaxScaleOnAxis(){const ms=this.elements,ns=ms[0]*ms[0]+ms[1]*ms[1]+ms[2]*ms[2],os=ms[4]*ms[4]+ms[5]*ms[5]+ms[6]*ms[6],ps=ms[8]*ms[8]+ms[9]*ms[9]+ms[10]*ms[10];return Math.sqrt(Math.max(ns,os,ps))}makeTranslation(qs,rs,ss){return this.set(1,0,0,qs,0,1,0,rs,0,0,1,ss,0,0,0,1),this}makeRotationX(ts){const us=Math.cos(ts),vs=Math.sin(ts);return this.set(1,0,0,0,0,us,-vs,0,0,vs,us,0,0,0,0,1),this}makeRotationY(ws){const xs=Math.cos(ws),ys=Math.sin(ws);return this.set(xs,0,ys,0,0,1,0,0,-ys,0,xs,0,0,0,0,1),this}makeRotationZ(zs){const As=Math.cos(zs),Bs=Math.sin(zs);return this.set(As,-Bs,0,0,Bs,As,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(Cs,Ds){const Es=Math.cos(Ds),Fs=Math.sin(Ds),Gs=1-Es,Hs=Cs.x,Is=Cs.y,Js=Cs.z,Ks=Gs*Hs,Ls=Gs*Is;return this.set(Ks*Hs+Es,Ks*Is-Fs*Js,Ks*Js+Fs*Is,0,Ks*Is+Fs*Js,Ls*Is+Es,Ls*Js-Fs*Hs,0,Ks*Js-Fs*Is,Ls*Js+Fs*Hs,Gs*Js*Js+Es,0,0,0,0,1),this}makeScale(Ms,Ns,Os){return this.set(Ms,0,0,0,0,Ns,0,0,0,0,Os,0,0,0,0,1),this}makeShear(Ps,Qs,Rs,Ss,Ts,Us){return this.set(1,Rs,Ts,0,Ps,1,Us,0,Qs,Ss,1,0,0,0,0,1),this}compose(Vs,Ws,Xs){const Ys=this.elements,Zs=Ws._x,$s=Ws._y,_s=Ws._z,at=Ws._w,bt=Zs+Zs,ct=$s+$s,dt=_s+_s,et=Zs*bt,ft=Zs*ct,gt=Zs*dt,ht=$s*ct,it=$s*dt,jt=_s*dt,kt=at*bt,lt=at*ct,mt=at*dt,nt=Xs.x,ot=Xs.y,pt=Xs.z;return Ys[0]=(1-(ht+jt))*nt,Ys[1]=(ft+mt)*nt,Ys[2]=(gt-lt)*nt,Ys[3]=0,Ys[4]=(ft-mt)*ot,Ys[5]=(1-(et+jt))*ot,Ys[6]=(it+kt)*ot,Ys[7]=0,Ys[8]=(gt+lt)*pt,Ys[9]=(it-kt)*pt,Ys[10]=(1-(et+ht))*pt,Ys[11]=0,Ys[12]=Vs.x,Ys[13]=Vs.y,Ys[14]=Vs.z,Ys[15]=1,this}decompose(qt,rt,st){const tt=this.elements;let ut=au.set(tt[0],tt[1],tt[2]).length();const vt=au.set(tt[4],tt[5],tt[6]).length(),wt=au.set(tt[8],tt[9],tt[10]).length(),xt=this.determinant();xt<0&&(ut=-ut),qt.x=tt[12],qt.y=tt[13],qt.z=tt[14],bu.copy(this);const yt=1/ut,zt=1/vt,At=1/wt;return bu.elements[0]*=yt,bu.elements[1]*=yt,bu.elements[2]*=yt,bu.elements[4]*=zt,bu.elements[5]*=zt,bu.elements[6]*=zt,bu.elements[8]*=At,bu.elements[9]*=At,bu.elements[10]*=At,rt.setFromRotationMatrix(bu),st.x=ut,st.y=vt,st.z=wt,this}makePerspective(Bt,Ct,Dt,Et,Ft,Gt){void 0===Gt&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const Ht=this.elements;return Ht[0]=2*Ft/(Ct-Bt),Ht[4]=0,Ht[8]=(Ct+Bt)/(Ct-Bt),Ht[12]=0,Ht[1]=0,Ht[5]=2*Ft/(Dt-Et),Ht[9]=(Dt+Et)/(Dt-Et),Ht[13]=0,Ht[2]=0,Ht[6]=0,Ht[10]=-(Gt+Ft)/(Gt-Ft),Ht[14]=-2*Gt*Ft/(Gt-Ft),Ht[3]=0,Ht[7]=0,Ht[11]=-1,Ht[15]=0,this}makeOrthographic(It,Jt,Kt,Lt,Mt,Nt){const Ot=this.elements,Pt=1/(Jt-It),Qt=1/(Kt-Lt),Rt=1/(Nt-Mt);return Ot[0]=2*Pt,Ot[4]=0,Ot[8]=0,Ot[12]=-((Jt+It)*Pt),Ot[1]=0,Ot[5]=2*Qt,Ot[9]=0,Ot[13]=-((Kt+Lt)*Qt),Ot[2]=0,Ot[6]=0,Ot[10]=-2*Rt,Ot[14]=-((Nt+Mt)*Rt),Ot[3]=0,Ot[7]=0,Ot[11]=0,Ot[15]=1,this}equals(St){const Tt=this.elements,Ut=St.elements;for(let Vt=0;Vt<16;Vt++)if(Tt[Vt]!==Ut[Vt])return!1;return!0}fromArray(Wt,Xt=0){for(let Yt=0;Yt<16;Yt++)this.elements[Yt]=Wt[Yt+Xt];return this}toArray(Zt=[],$t=0){const _t=this.elements;return Zt[$t]=_t[0],Zt[$t+1]=_t[1],Zt[$t+2]=_t[2],Zt[$t+3]=_t[3],Zt[$t+4]=_t[4],Zt[$t+5]=_t[5],Zt[$t+6]=_t[6],Zt[$t+7]=_t[7],Zt[$t+8]=_t[8],Zt[$t+9]=_t[9],Zt[$t+10]=_t[10],Zt[$t+11]=_t[11],Zt[$t+12]=_t[12],Zt[$t+13]=_t[13],Zt[$t+14]=_t[14],Zt[$t+15]=_t[15],Zt}}dp.prototype.isMatrix4=!0;const au=new Qi(),bu=new dp(),cu=new Qi(0,0,0),du=new Qi(1,1,1),eu=new Qi(),fu=new Qi(),gu=new Qi(),hu=new dp(),iu=new jg();class ju{constructor(ku=0,lu=0,mu=0,nu=ju.DefaultOrder){this._x=ku,this._y=lu,this._z=mu,this._order=nu}get x(){return this._x}set x(ou){this._x=ou,this._onChangeCallback()}get y(){return this._y}set y(pu){this._y=pu,this._onChangeCallback()}get z(){return this._z}set z(qu){this._z=qu,this._onChangeCallback()}get order(){return this._order}set order(ru){this._order=ru,this._onChangeCallback()}set(su,tu,uu,vu=this._order){return this._x=su,this._y=tu,this._z=uu,this._order=vu,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(wu){return this._x=wu._x,this._y=wu._y,this._z=wu._z,this._order=wu._order,this._onChangeCallback(),this}setFromRotationMatrix(xu,yu=this._order,zu=!0){const Au=xu.elements,Bu=Au[0],Cu=Au[4],Du=Au[8],Eu=Au[1],Fu=Au[5],Gu=Au[9],Hu=Au[2],Iu=Au[6],Ju=Au[10];switch(yu){case"XYZ":this._y=Math.asin(Y(Du,-1,1)),0.9999999>Math.abs(Du)?(this._x=Math.atan2(-Gu,Ju),this._z=Math.atan2(-Cu,Bu)):(this._x=Math.atan2(Iu,Fu),this._z=0);break;case"YXZ":this._x=Math.asin(-Y(Gu,-1,1)),0.9999999>Math.abs(Gu)?(this._y=Math.atan2(Du,Ju),this._z=Math.atan2(Eu,Fu)):(this._y=Math.atan2(-Hu,Bu),this._z=0);break;case"ZXY":this._x=Math.asin(Y(Iu,-1,1)),0.9999999>Math.abs(Iu)?(this._y=Math.atan2(-Hu,Ju),this._z=Math.atan2(-Cu,Fu)):(this._y=0,this._z=Math.atan2(Eu,Bu));break;case"ZYX":this._y=Math.asin(-Y(Hu,-1,1)),0.9999999>Math.abs(Hu)?(this._x=Math.atan2(Iu,Ju),this._z=Math.atan2(Eu,Bu)):(this._x=0,this._z=Math.atan2(-Cu,Fu));break;case"YZX":this._z=Math.asin(Y(Eu,-1,1)),0.9999999>Math.abs(Eu)?(this._x=Math.atan2(-Gu,Fu),this._y=Math.atan2(-Hu,Bu)):(this._x=0,this._y=Math.atan2(Du,Ju));break;case"XZY":this._z=Math.asin(-Y(Cu,-1,1)),0.9999999>Math.abs(Cu)?(this._x=Math.atan2(Iu,Fu),this._y=Math.atan2(Du,Bu)):(this._x=Math.atan2(-Gu,Ju),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+yu)}return this._order=yu,!0===zu&&this._onChangeCallback(),this}setFromQuaternion(Ku,Lu,Mu){return hu.makeRotationFromQuaternion(Ku),this.setFromRotationMatrix(hu,Lu,Mu)}setFromVector3(Nu,Ou=this._order){return this.set(Nu.x,Nu.y,Nu.z,Ou)}reorder(Pu){return iu.setFromEuler(this),this.setFromQuaternion(iu,Pu)}equals(Qu){return Qu._x===this._x&&Qu._y===this._y&&Qu._z===this._z&&Qu._order===this._order}fromArray(Ru){return this._x=Ru[0],this._y=Ru[1],this._z=Ru[2],void 0!==Ru[3]&&(this._order=Ru[3]),this._onChangeCallback(),this}toArray(Su=[],Tu=0){return Su[Tu]=this._x,Su[Tu+1]=this._y,Su[Tu+2]=this._z,Su[Tu+3]=this._order,Su}toVector3(Uu){return Uu?Uu.set(this._x,this._y,this._z):new Qi(this._x,this._y,this._z)}_onChange(Vu){return this._onChangeCallback=Vu,this}_onChangeCallback(){}}ju.prototype.isEuler=!0,ju.DefaultOrder="XYZ",ju.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];let Wu=0;const Xu=new Qi(),Yu=new jg(),Zu=new dp(),$u=new Qi(),_u=new Qi(),av=new Qi(),bv=new jg(),cv=new Qi(1,0,0),dv=new Qi(0,1,0),ev=new Qi(0,0,1),fv={type:"added"},gv={type:"removed"};class hv extends z{constructor(){super(),Object.defineProperty(this,"id",{value:Wu++}),this.uuid=X(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=hv.DefaultUp.clone();const iv=new Qi(),jv=new ju(),kv=new jg(),lv=new Qi(1,1,1);jv._onChange(function(){kv.setFromEuler(jv,!1)}),kv._onChange(function(){jv.setFromQuaternion(kv,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:iv},rotation:{configurable:!0,enumerable:!0,value:jv},quaternion:{configurable:!0,enumerable:!0,value:kv},scale:{configurable:!0,enumerable:!0,value:lv},modelViewMatrix:{value:new dp()},normalMatrix:{value:new ub()}}),this.matrix=new dp(),this.matrixWorld=new dp(),this.matrixAutoUpdate=hv.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new class{constructor(){this.mask=1}set(mv){this.mask=1<<mv|0}enable(nv){this.mask|=1<<nv|0}enableAll(){this.mask=-1}toggle(ov){this.mask^=1<<ov|0}disable(pv){this.mask&=~(1<<pv|0)}disableAll(){this.mask=0}test(qv){return(this.mask&qv.mask)!=0}}(),this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(rv){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(rv),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(sv){return this.quaternion.premultiply(sv),this}setRotationFromAxisAngle(tv,uv){this.quaternion.setFromAxisAngle(tv,uv)}setRotationFromEuler(vv){this.quaternion.setFromEuler(vv,!0)}setRotationFromMatrix(wv){this.quaternion.setFromRotationMatrix(wv)}setRotationFromQuaternion(xv){this.quaternion.copy(xv)}rotateOnAxis(yv,zv){return Yu.setFromAxisAngle(yv,zv),this.quaternion.multiply(Yu),this}rotateOnWorldAxis(Av,Bv){return Yu.setFromAxisAngle(Av,Bv),this.quaternion.premultiply(Yu),this}rotateX(Cv){return this.rotateOnAxis(cv,Cv)}rotateY(Dv){return this.rotateOnAxis(dv,Dv)}rotateZ(Ev){return this.rotateOnAxis(ev,Ev)}translateOnAxis(Fv,Gv){return Xu.copy(Fv).applyQuaternion(this.quaternion),this.position.add(Xu.multiplyScalar(Gv)),this}translateX(Hv){return this.translateOnAxis(cv,Hv)}translateY(Iv){return this.translateOnAxis(dv,Iv)}translateZ(Jv){return this.translateOnAxis(ev,Jv)}localToWorld(Kv){return Kv.applyMatrix4(this.matrixWorld)}worldToLocal(Lv){return Lv.applyMatrix4(Zu.copy(this.matrixWorld).invert())}lookAt(Mv,Nv,Ov){Mv.isVector3?$u.copy(Mv):$u.set(Mv,Nv,Ov);const Pv=this.parent;this.updateWorldMatrix(!0,!1),_u.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Zu.lookAt(_u,$u,this.up):Zu.lookAt($u,_u,this.up),this.quaternion.setFromRotationMatrix(Zu),Pv&&(Zu.extractRotation(Pv.matrixWorld),Yu.setFromRotationMatrix(Zu),this.quaternion.premultiply(Yu.invert()))}add(Qv){if(arguments.length>1){for(let Rv=0;Rv<arguments.length;Rv++)this.add(arguments[Rv]);return this}return Qv===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",Qv),this):(Qv&&Qv.isObject3D?(null!==Qv.parent&&Qv.parent.remove(Qv),Qv.parent=this,this.children.push(Qv),Qv.dispatchEvent(fv)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",Qv),this)}remove(Sv){if(arguments.length>1){for(let Tv=0;Tv<arguments.length;Tv++)this.remove(arguments[Tv]);return this}const Uv=this.children.indexOf(Sv);return -1!==Uv&&(Sv.parent=null,this.children.splice(Uv,1),Sv.dispatchEvent(gv)),this}removeFromParent(){const Vv=this.parent;return null!==Vv&&Vv.remove(this),this}clear(){for(let Wv=0;Wv<this.children.length;Wv++){const Xv=this.children[Wv];Xv.parent=null,Xv.dispatchEvent(gv)}return this.children.length=0,this}attach(Yv){return this.updateWorldMatrix(!0,!1),Zu.copy(this.matrixWorld).invert(),null!==Yv.parent&&(Yv.parent.updateWorldMatrix(!0,!1),Zu.multiply(Yv.parent.matrixWorld)),Yv.applyMatrix4(Zu),this.add(Yv),Yv.updateWorldMatrix(!1,!0),this}getObjectById(Zv){return this.getObjectByProperty("id",Zv)}getObjectByName($v){return this.getObjectByProperty("name",$v)}getObjectByProperty(_v,aw){if(this[_v]===aw)return this;for(let bw=0,cw=this.children.length;bw<cw;bw++){const dw=this.children[bw],ew=dw.getObjectByProperty(_v,aw);if(void 0!==ew)return ew}}getWorldPosition(fw){return this.updateWorldMatrix(!0,!1),fw.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(gw){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_u,gw,av),gw}getWorldScale(hw){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_u,bv,hw),hw}getWorldDirection(iw){this.updateWorldMatrix(!0,!1);const jw=this.matrixWorld.elements;return iw.set(jw[8],jw[9],jw[10]).normalize()}raycast(){}traverse(kw){kw(this);const lw=this.children;for(let mw=0,nw=lw.length;mw<nw;mw++)lw[mw].traverse(kw)}traverseVisible(ow){if(!1===this.visible)return;ow(this);const pw=this.children;for(let qw=0,rw=pw.length;qw<rw;qw++)pw[qw].traverseVisible(ow)}traverseAncestors(sw){const tw=this.parent;null!==tw&&(sw(tw),tw.traverseAncestors(sw))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(uw){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||uw)&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,uw=!0);const vw=this.children;for(let ww=0,xw=vw.length;ww<xw;ww++)vw[ww].updateMatrixWorld(uw)}updateWorldMatrix(yw,zw){const Aw=this.parent;if(!0===yw&&null!==Aw&&Aw.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),!0===zw){const Bw=this.children;for(let Cw=0,Dw=Bw.length;Cw<Dw;Cw++)Bw[Cw].updateWorldMatrix(!1,!0)}}toJSON(Ew){const Fw=void 0===Ew||"string"==typeof Ew,Gw={};Fw&&(Ew={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},Gw.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const Hw={};function Iw(a,b){return void 0===a[b.uuid]&&(a[b.uuid]=b.toJSON(Ew)),b.uuid}if(Hw.uuid=this.uuid,Hw.type=this.type,""!==this.name&&(Hw.name=this.name),!0===this.castShadow&&(Hw.castShadow=!0),!0===this.receiveShadow&&(Hw.receiveShadow=!0),!1===this.visible&&(Hw.visible=!1),!1===this.frustumCulled&&(Hw.frustumCulled=!1),0!==this.renderOrder&&(Hw.renderOrder=this.renderOrder),"{}"!==JSON.stringify(this.userData)&&(Hw.userData=this.userData),Hw.layers=this.layers.mask,Hw.matrix=this.matrix.toArray(),!1===this.matrixAutoUpdate&&(Hw.matrixAutoUpdate=!1),this.isInstancedMesh&&(Hw.type="InstancedMesh",Hw.count=this.count,Hw.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(Hw.instanceColor=this.instanceColor.toJSON())),this.isScene)this.background&&(this.background.isColor?Hw.background=this.background.toJSON():this.background.isTexture&&(Hw.background=this.background.toJSON(Ew).uuid)),this.environment&&this.environment.isTexture&&(Hw.environment=this.environment.toJSON(Ew).uuid);else if(this.isMesh||this.isLine||this.isPoints){Hw.geometry=Iw(Ew.geometries,this.geometry);const Jw=this.geometry.parameters;if(void 0!==Jw&& void 0!==Jw.shapes){const Kw=Jw.shapes;if(Array.isArray(Kw))for(let Lw=0,Mw=Kw.length;Lw<Mw;Lw++){const Nw=Kw[Lw];Iw(Ew.shapes,Nw)}else Iw(Ew.shapes,Kw)}}if(this.isSkinnedMesh&&(Hw.bindMode=this.bindMode,Hw.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(Iw(Ew.skeletons,this.skeleton),Hw.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const Ow=[];for(let Pw=0,Qw=this.material.length;Pw<Qw;Pw++)Ow.push(Iw(Ew.materials,this.material[Pw]));Hw.material=Ow}else Hw.material=Iw(Ew.materials,this.material);if(this.children.length>0){Hw.children=[];for(let Rw=0;Rw<this.children.length;Rw++)Hw.children.push(this.children[Rw].toJSON(Ew).object)}if(this.animations.length>0){Hw.animations=[];for(let Sw=0;Sw<this.animations.length;Sw++){const Tw=this.animations[Sw];Hw.animations.push(Iw(Ew.animations,Tw))}}if(Fw){const Uw=_w(Ew.geometries),Vw=_w(Ew.materials),Ww=_w(Ew.textures),Xw=_w(Ew.images),Yw=_w(Ew.shapes),Zw=_w(Ew.skeletons),$w=_w(Ew.animations);Uw.length>0&&(Gw.geometries=Uw),Vw.length>0&&(Gw.materials=Vw),Ww.length>0&&(Gw.textures=Ww),Xw.length>0&&(Gw.images=Xw),Yw.length>0&&(Gw.shapes=Yw),Zw.length>0&&(Gw.skeletons=Zw),$w.length>0&&(Gw.animations=$w)}return Gw.object=Hw,Gw;function _w(a){const b=[];for(const c in a){const d=a[c];delete d.metadata,b.push(d)}return b}}clone(ax){return new this.constructor().copy(this,ax)}copy(bx,cx=!0){if(this.name=bx.name,this.up.copy(bx.up),this.position.copy(bx.position),this.rotation.order=bx.rotation.order,this.quaternion.copy(bx.quaternion),this.scale.copy(bx.scale),this.matrix.copy(bx.matrix),this.matrixWorld.copy(bx.matrixWorld),this.matrixAutoUpdate=bx.matrixAutoUpdate,this.matrixWorldNeedsUpdate=bx.matrixWorldNeedsUpdate,this.layers.mask=bx.layers.mask,this.visible=bx.visible,this.castShadow=bx.castShadow,this.receiveShadow=bx.receiveShadow,this.frustumCulled=bx.frustumCulled,this.renderOrder=bx.renderOrder,this.userData=JSON.parse(JSON.stringify(bx.userData)),!0===cx)for(let dx=0;dx<bx.children.length;dx++){const ex=bx.children[dx];this.add(ex.clone())}return this}}hv.DefaultUp=new Qi(0,1,0),hv.DefaultMatrixAutoUpdate=!0,hv.prototype.isObject3D=!0;const fx=new Qi(),gx=new Qi(),hx=new Qi(),ix=new Qi(),jx=new Qi(),kx=new Qi(),lx=new Qi(),mx=new Qi(),nx=new Qi(),ox=new Qi();class px{constructor(qx=new Qi(),rx=new Qi(),sx=new Qi()){this.a=qx,this.b=rx,this.c=sx}static getNormal(tx,ux,vx,wx){wx.subVectors(vx,ux),fx.subVectors(tx,ux),wx.cross(fx);const xx=wx.lengthSq();return xx>0?wx.multiplyScalar(1/Math.sqrt(xx)):wx.set(0,0,0)}static getBarycoord(yx,zx,Ax,Bx,Cx){fx.subVectors(Bx,zx),gx.subVectors(Ax,zx),hx.subVectors(yx,zx);const Dx=fx.dot(fx),Ex=fx.dot(gx),Fx=fx.dot(hx),Gx=gx.dot(gx),Hx=gx.dot(hx),Ix=Dx*Gx-Ex*Ex;if(0===Ix)return Cx.set(-2,-1,-1);const Jx=1/Ix,Kx=(Gx*Fx-Ex*Hx)*Jx,Lx=(Dx*Hx-Ex*Fx)*Jx;return Cx.set(1-Kx-Lx,Lx,Kx)}static containsPoint(Mx,Nx,Ox,Px){return this.getBarycoord(Mx,Nx,Ox,Px,ix),ix.x>=0&&ix.y>=0&&ix.x+ix.y<=1}static getUV(Qx,Rx,Sx,Tx,Ux,Vx,Wx,Xx){return this.getBarycoord(Qx,Rx,Sx,Tx,ix),Xx.set(0,0),Xx.addScaledVector(Ux,ix.x),Xx.addScaledVector(Vx,ix.y),Xx.addScaledVector(Wx,ix.z),Xx}static isFrontFacing(Yx,Zx,$x,_x){return fx.subVectors($x,Zx),gx.subVectors(Yx,Zx),0>fx.cross(gx).dot(_x)}set(ay,by,cy){return this.a.copy(ay),this.b.copy(by),this.c.copy(cy),this}setFromPointsAndIndices(dy,ey,fy,gy){return this.a.copy(dy[ey]),this.b.copy(dy[fy]),this.c.copy(dy[gy]),this}setFromAttributeAndIndices(hy,iy,jy,ky){return this.a.fromBufferAttribute(hy,iy),this.b.fromBufferAttribute(hy,jy),this.c.fromBufferAttribute(hy,ky),this}clone(){return new this.constructor().copy(this)}copy(ly){return this.a.copy(ly.a),this.b.copy(ly.b),this.c.copy(ly.c),this}getArea(){return fx.subVectors(this.c,this.b),gx.subVectors(this.a,this.b),0.5*fx.cross(gx).length()}getMidpoint(my){return my.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(ny){return px.getNormal(this.a,this.b,this.c,ny)}getPlane(oy){return oy.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(py,qy){return px.getBarycoord(py,this.a,this.b,this.c,qy)}getUV(ry,sy,ty,uy,vy){return px.getUV(ry,this.a,this.b,this.c,sy,ty,uy,vy)}containsPoint(wy){return px.containsPoint(wy,this.a,this.b,this.c)}isFrontFacing(xy){return px.isFrontFacing(this.a,this.b,this.c,xy)}intersectsBox(yy){return yy.intersectsTriangle(this)}closestPointToPoint(zy,Ay){const By=this.a,Cy=this.b,Dy=this.c;let Ey,Fy;jx.subVectors(Cy,By),kx.subVectors(Dy,By),mx.subVectors(zy,By);const Gy=jx.dot(mx),Hy=kx.dot(mx);if(Gy<=0&&Hy<=0)return Ay.copy(By);nx.subVectors(zy,Cy);const Iy=jx.dot(nx),Jy=kx.dot(nx);if(Iy>=0&&Jy<=Iy)return Ay.copy(Cy);const Ky=Gy*Jy-Iy*Hy;if(Ky<=0&&Gy>=0&&Iy<=0)return Ey=Gy/(Gy-Iy),Ay.copy(By).addScaledVector(jx,Ey);ox.subVectors(zy,Dy);const Ly=jx.dot(ox),My=kx.dot(ox);if(My>=0&&Ly<=My)return Ay.copy(Dy);const Ny=Ly*Hy-Gy*My;if(Ny<=0&&Hy>=0&&My<=0)return Fy=Hy/(Hy-My),Ay.copy(By).addScaledVector(kx,Fy);const Oy=Iy*My-Ly*Jy;if(Oy<=0&&Jy-Iy>=0&&Ly-My>=0)return lx.subVectors(Dy,Cy),Fy=(Jy-Iy)/(Jy-Iy+(Ly-My)),Ay.copy(Cy).addScaledVector(lx,Fy);const Py=1/(Oy+Ny+Ky);return Ey=Ny*Py,Fy=Ky*Py,Ay.copy(By).addScaledVector(jx,Ey).addScaledVector(kx,Fy)}equals(Qy){return Qy.a.equals(this.a)&&Qy.b.equals(this.b)&&Qy.c.equals(this.c)}}let Ry=0;class Sy extends z{constructor(){super(),Object.defineProperty(this,"id",{value:Ry++}),this.uuid=X(),this.name="",this.type="Material",this.fog=!0,this.blending=1,this.side=f,this.vertexColors=!1,this.opacity=1,this.format=1023,this.transparent=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(Ty){this._alphaTest>0!=Ty>0&&this.version++,this._alphaTest=Ty}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(Uy){if(void 0!==Uy)for(const Vy in Uy){const Wy=Uy[Vy];if(void 0===Wy){console.warn("THREE.Material: '"+Vy+"' parameter is undefined.");continue}if("shading"===Vy){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===Wy;continue}const Xy=this[Vy];if(void 0===Xy){console.warn("THREE."+this.type+": '"+Vy+"' is not a property of this material.");continue}Xy&&Xy.isColor?Xy.set(Wy):Xy&&Xy.isVector3&&Wy&&Wy.isVector3?Xy.copy(Wy):this[Vy]=Wy}}toJSON(Yy){const Zy=void 0===Yy||"string"==typeof Yy;Zy&&(Yy={textures:{},images:{}});const $y={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};function _y(a){const b=[];for(const c in a){const d=a[c];delete d.metadata,b.push(d)}return b}if($y.uuid=this.uuid,$y.type=this.type,""!==this.name&&($y.name=this.name),this.color&&this.color.isColor&&($y.color=this.color.getHex()),void 0!==this.roughness&&($y.roughness=this.roughness),void 0!==this.metalness&&($y.metalness=this.metalness),void 0!==this.sheen&&($y.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&($y.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&($y.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&($y.emissive=this.emissive.getHex()),this.emissiveIntensity&&1!==this.emissiveIntensity&&($y.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&($y.specular=this.specular.getHex()),void 0!==this.specularIntensity&&($y.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&($y.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&($y.shininess=this.shininess),void 0!==this.clearcoat&&($y.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&($y.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&($y.clearcoatMap=this.clearcoatMap.toJSON(Yy).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&($y.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(Yy).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&($y.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(Yy).uuid,$y.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&($y.map=this.map.toJSON(Yy).uuid),this.matcap&&this.matcap.isTexture&&($y.matcap=this.matcap.toJSON(Yy).uuid),this.alphaMap&&this.alphaMap.isTexture&&($y.alphaMap=this.alphaMap.toJSON(Yy).uuid),this.lightMap&&this.lightMap.isTexture&&($y.lightMap=this.lightMap.toJSON(Yy).uuid,$y.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&($y.aoMap=this.aoMap.toJSON(Yy).uuid,$y.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&($y.bumpMap=this.bumpMap.toJSON(Yy).uuid,$y.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&($y.normalMap=this.normalMap.toJSON(Yy).uuid,$y.normalMapType=this.normalMapType,$y.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&($y.displacementMap=this.displacementMap.toJSON(Yy).uuid,$y.displacementScale=this.displacementScale,$y.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&($y.roughnessMap=this.roughnessMap.toJSON(Yy).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&($y.metalnessMap=this.metalnessMap.toJSON(Yy).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&($y.emissiveMap=this.emissiveMap.toJSON(Yy).uuid),this.specularMap&&this.specularMap.isTexture&&($y.specularMap=this.specularMap.toJSON(Yy).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&($y.specularIntensityMap=this.specularIntensityMap.toJSON(Yy).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&($y.specularColorMap=this.specularColorMap.toJSON(Yy).uuid),this.envMap&&this.envMap.isTexture&&($y.envMap=this.envMap.toJSON(Yy).uuid,void 0!==this.combine&&($y.combine=this.combine)),void 0!==this.envMapIntensity&&($y.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&($y.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&($y.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&($y.gradientMap=this.gradientMap.toJSON(Yy).uuid),void 0!==this.transmission&&($y.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&($y.transmissionMap=this.transmissionMap.toJSON(Yy).uuid),void 0!==this.thickness&&($y.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&($y.thicknessMap=this.thicknessMap.toJSON(Yy).uuid),void 0!==this.attenuationDistance&&($y.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&($y.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&($y.size=this.size),null!==this.shadowSide&&($y.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&($y.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&($y.blending=this.blending),this.side!==f&&($y.side=this.side),this.vertexColors&&($y.vertexColors=!0),this.opacity<1&&($y.opacity=this.opacity),1023!==this.format&&($y.format=this.format),!0===this.transparent&&($y.transparent=this.transparent),$y.depthFunc=this.depthFunc,$y.depthTest=this.depthTest,$y.depthWrite=this.depthWrite,$y.colorWrite=this.colorWrite,$y.stencilWrite=this.stencilWrite,$y.stencilWriteMask=this.stencilWriteMask,$y.stencilFunc=this.stencilFunc,$y.stencilRef=this.stencilRef,$y.stencilFuncMask=this.stencilFuncMask,$y.stencilFail=this.stencilFail,$y.stencilZFail=this.stencilZFail,$y.stencilZPass=this.stencilZPass,this.rotation&&0!==this.rotation&&($y.rotation=this.rotation),!0===this.polygonOffset&&($y.polygonOffset=!0),0!==this.polygonOffsetFactor&&($y.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&($y.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&1!==this.linewidth&&($y.linewidth=this.linewidth),void 0!==this.dashSize&&($y.dashSize=this.dashSize),void 0!==this.gapSize&&($y.gapSize=this.gapSize),void 0!==this.scale&&($y.scale=this.scale),!0===this.dithering&&($y.dithering=!0),this.alphaTest>0&&($y.alphaTest=this.alphaTest),!0===this.alphaToCoverage&&($y.alphaToCoverage=this.alphaToCoverage),!0===this.premultipliedAlpha&&($y.premultipliedAlpha=this.premultipliedAlpha),!0===this.wireframe&&($y.wireframe=this.wireframe),this.wireframeLinewidth>1&&($y.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&($y.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&($y.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&($y.flatShading=this.flatShading),!1===this.visible&&($y.visible=!1),!1===this.toneMapped&&($y.toneMapped=!1),"{}"!==JSON.stringify(this.userData)&&($y.userData=this.userData),Zy){const az=_y(Yy.textures),bz=_y(Yy.images);az.length>0&&($y.textures=az),bz.length>0&&($y.images=bz)}return $y}clone(){return new this.constructor().copy(this)}copy(cz){this.name=cz.name,this.fog=cz.fog,this.blending=cz.blending,this.side=cz.side,this.vertexColors=cz.vertexColors,this.opacity=cz.opacity,this.format=cz.format,this.transparent=cz.transparent,this.blendSrc=cz.blendSrc,this.blendDst=cz.blendDst,this.blendEquation=cz.blendEquation,this.blendSrcAlpha=cz.blendSrcAlpha,this.blendDstAlpha=cz.blendDstAlpha,this.blendEquationAlpha=cz.blendEquationAlpha,this.depthFunc=cz.depthFunc,this.depthTest=cz.depthTest,this.depthWrite=cz.depthWrite,this.stencilWriteMask=cz.stencilWriteMask,this.stencilFunc=cz.stencilFunc,this.stencilRef=cz.stencilRef,this.stencilFuncMask=cz.stencilFuncMask,this.stencilFail=cz.stencilFail,this.stencilZFail=cz.stencilZFail,this.stencilZPass=cz.stencilZPass,this.stencilWrite=cz.stencilWrite;const dz=cz.clippingPlanes;let ez=null;if(null!==dz){const fz=dz.length;ez=new Array(fz);for(let gz=0;gz!==fz;++gz)ez[gz]=dz[gz].clone()}return this.clippingPlanes=ez,this.clipIntersection=cz.clipIntersection,this.clipShadows=cz.clipShadows,this.shadowSide=cz.shadowSide,this.colorWrite=cz.colorWrite,this.precision=cz.precision,this.polygonOffset=cz.polygonOffset,this.polygonOffsetFactor=cz.polygonOffsetFactor,this.polygonOffsetUnits=cz.polygonOffsetUnits,this.dithering=cz.dithering,this.alphaTest=cz.alphaTest,this.alphaToCoverage=cz.alphaToCoverage,this.premultipliedAlpha=cz.premultipliedAlpha,this.visible=cz.visible,this.toneMapped=cz.toneMapped,this.userData=JSON.parse(JSON.stringify(cz.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(hz){!0===hz&&this.version++}}Sy.prototype.isMaterial=!0;const iz={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},jz={h:0,s:0,l:0},kz={h:0,s:0,l:0};function lz(a,b,c){return(c<0&&(c+=1),c>1&&(c-=1),c<1/6)?a+(b-a)*6*c:c<0.5?b:c<2/3?a+(b-a)*6*(2/3-c):a}function mz(a){return a<0.04045?0.0773993808*a:Math.pow(0.9478672986*a+0.0521327014,2.4)}function nz(a){return a<0.0031308?12.92*a:1.055*Math.pow(a,0.41666)-0.055}class oz{constructor(pz,qz,rz){if(void 0===qz&& void 0===rz)return this.set(pz);return this.setRGB(pz,qz,rz)}set(sz){return sz&&sz.isColor?this.copy(sz):"number"==typeof sz?this.setHex(sz):"string"==typeof sz&&this.setStyle(sz),this}setScalar(tz){return this.r=tz,this.g=tz,this.b=tz,this}setHex(uz){return uz=Math.floor(uz),this.r=(uz>>16&255)/255,this.g=(uz>>8&255)/255,this.b=(255&uz)/255,this}setRGB(vz,wz,xz){return this.r=vz,this.g=wz,this.b=xz,this}setHSL(yz,zz,Az){if(yz=Z(yz,1),zz=Y(zz,0,1),Az=Y(Az,0,1),0===zz)this.r=this.g=this.b=Az;else{const Bz=Az<=0.5?Az*(1+zz):Az+zz-Az*zz,Cz=2*Az-Bz;this.r=lz(Cz,Bz,yz+1/3),this.g=lz(Cz,Bz,yz),this.b=lz(Cz,Bz,yz-1/3)}return this}setStyle(Dz){function Ez(a){void 0!==a&&1>parseFloat(a)&&console.warn("THREE.Color: Alpha component of "+Dz+" will be ignored.")}let Fz;if(Fz=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(Dz)){let Gz;const Hz=Fz[1],Iz=Fz[2];switch(Hz){case"rgb":case"rgba":if(Gz=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(Iz))return this.r=Math.min(255,parseInt(Gz[1],10))/255,this.g=Math.min(255,parseInt(Gz[2],10))/255,this.b=Math.min(255,parseInt(Gz[3],10))/255,Ez(Gz[4]),this;if(Gz=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(Iz))return this.r=Math.min(100,parseInt(Gz[1],10))/100,this.g=Math.min(100,parseInt(Gz[2],10))/100,this.b=Math.min(100,parseInt(Gz[3],10))/100,Ez(Gz[4]),this;break;case"hsl":case"hsla":if(Gz=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(Iz)){const Jz=parseFloat(Gz[1])/360,Kz=parseInt(Gz[2],10)/100,Lz=parseInt(Gz[3],10)/100;return Ez(Gz[4]),this.setHSL(Jz,Kz,Lz)}break}}else if(Fz=/^\#([A-Fa-f\d]+)$/.exec(Dz)){const Mz=Fz[1],Nz=Mz.length;if(3===Nz)return this.r=parseInt(Mz.charAt(0)+Mz.charAt(0),16)/255,this.g=parseInt(Mz.charAt(1)+Mz.charAt(1),16)/255,this.b=parseInt(Mz.charAt(2)+Mz.charAt(2),16)/255,this;if(6===Nz)return this.r=parseInt(Mz.charAt(0)+Mz.charAt(1),16)/255,this.g=parseInt(Mz.charAt(2)+Mz.charAt(3),16)/255,this.b=parseInt(Mz.charAt(4)+Mz.charAt(5),16)/255,this}return Dz&&Dz.length>0?this.setColorName(Dz):this}setColorName(Oz){const Pz=iz[Oz.toLowerCase()];return void 0!==Pz?this.setHex(Pz):console.warn("THREE.Color: Unknown color "+Oz),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(Qz){return this.r=Qz.r,this.g=Qz.g,this.b=Qz.b,this}copyGammaToLinear(Rz,Sz=2){return this.r=Math.pow(Rz.r,Sz),this.g=Math.pow(Rz.g,Sz),this.b=Math.pow(Rz.b,Sz),this}copyLinearToGamma(Tz,Uz=2){const Vz=Uz>0?1/Uz:1;return this.r=Math.pow(Tz.r,Vz),this.g=Math.pow(Tz.g,Vz),this.b=Math.pow(Tz.b,Vz),this}convertGammaToLinear(Wz){return this.copyGammaToLinear(this,Wz),this}convertLinearToGamma(Xz){return this.copyLinearToGamma(this,Xz),this}copySRGBToLinear(Yz){return this.r=mz(Yz.r),this.g=mz(Yz.g),this.b=mz(Yz.b),this}copyLinearToSRGB(Zz){return this.r=nz(Zz.r),this.g=nz(Zz.g),this.b=nz(Zz.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return 255*this.r<<16^255*this.g<<8^255*this.b<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL($z){const _z=this.r,aA=this.g,bA=this.b,cA=Math.max(_z,aA,bA),dA=Math.min(_z,aA,bA);let eA,fA;const gA=(dA+cA)/2;if(dA===cA)eA=0,fA=0;else{const hA=cA-dA;switch(fA=gA<=0.5?hA/(cA+dA):hA/(2-cA-dA),cA){case _z:eA=(aA-bA)/hA+(aA<bA?6:0);break;case aA:eA=(bA-_z)/hA+2;break;case bA:eA=(_z-aA)/hA+4;break}eA/=6}return $z.h=eA,$z.s=fA,$z.l=gA,$z}getStyle(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"}offsetHSL(iA,jA,kA){return this.getHSL(jz),jz.h+=iA,jz.s+=jA,jz.l+=kA,this.setHSL(jz.h,jz.s,jz.l),this}add(lA){return this.r+=lA.r,this.g+=lA.g,this.b+=lA.b,this}addColors(mA,nA){return this.r=mA.r+nA.r,this.g=mA.g+nA.g,this.b=mA.b+nA.b,this}addScalar(oA){return this.r+=oA,this.g+=oA,this.b+=oA,this}sub(pA){return this.r=Math.max(0,this.r-pA.r),this.g=Math.max(0,this.g-pA.g),this.b=Math.max(0,this.b-pA.b),this}multiply(qA){return this.r*=qA.r,this.g*=qA.g,this.b*=qA.b,this}multiplyScalar(rA){return this.r*=rA,this.g*=rA,this.b*=rA,this}lerp(sA,tA){return this.r+=(sA.r-this.r)*tA,this.g+=(sA.g-this.g)*tA,this.b+=(sA.b-this.b)*tA,this}lerpColors(uA,vA,wA){return this.r=uA.r+(vA.r-uA.r)*wA,this.g=uA.g+(vA.g-uA.g)*wA,this.b=uA.b+(vA.b-uA.b)*wA,this}lerpHSL(xA,yA){this.getHSL(jz),xA.getHSL(kz);const zA=$(jz.h,kz.h,yA),AA=$(jz.s,kz.s,yA),BA=$(jz.l,kz.l,yA);return this.setHSL(zA,AA,BA),this}equals(CA){return CA.r===this.r&&CA.g===this.g&&CA.b===this.b}fromArray(DA,EA=0){return this.r=DA[EA],this.g=DA[EA+1],this.b=DA[EA+2],this}toArray(FA=[],GA=0){return FA[GA]=this.r,FA[GA+1]=this.g,FA[GA+2]=this.b,FA}fromBufferAttribute(HA,IA){return this.r=HA.getX(IA),this.g=HA.getY(IA),this.b=HA.getZ(IA),!0===HA.normalized&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}oz.NAMES=iz,oz.prototype.isColor=!0,oz.prototype.r=1,oz.prototype.g=1,oz.prototype.b=1;class JA extends Sy{constructor(KA){super(),this.type="MeshBasicMaterial",this.color=new oz(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=0.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(KA)}copy(LA){return super.copy(LA),this.color.copy(LA.color),this.map=LA.map,this.lightMap=LA.lightMap,this.lightMapIntensity=LA.lightMapIntensity,this.aoMap=LA.aoMap,this.aoMapIntensity=LA.aoMapIntensity,this.specularMap=LA.specularMap,this.alphaMap=LA.alphaMap,this.envMap=LA.envMap,this.combine=LA.combine,this.reflectivity=LA.reflectivity,this.refractionRatio=LA.refractionRatio,this.wireframe=LA.wireframe,this.wireframeLinewidth=LA.wireframeLinewidth,this.wireframeLinecap=LA.wireframeLinecap,this.wireframeLinejoin=LA.wireframeLinejoin,this}}JA.prototype.isMeshBasicMaterial=!0;const MA=new Qi(),NA=new da();class OA{constructor(PA,QA,RA){if(Array.isArray(PA))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=PA,this.itemSize=QA,this.count=void 0!==PA?PA.length/QA:0,this.normalized=!0===RA,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(SA){!0===SA&&this.version++}setUsage(TA){return this.usage=TA,this}copy(UA){return this.name=UA.name,this.array=new UA.array.constructor(UA.array),this.itemSize=UA.itemSize,this.count=UA.count,this.normalized=UA.normalized,this.usage=UA.usage,this}copyAt(VA,WA,XA){VA*=this.itemSize,XA*=WA.itemSize;for(let YA=0,ZA=this.itemSize;YA<ZA;YA++)this.array[VA+YA]=WA.array[XA+YA];return this}copyArray($A){return this.array.set($A),this}copyColorsArray(_A){const aB=this.array;let bB=0;for(let cB=0,dB=_A.length;cB<dB;cB++){let eB=_A[cB];void 0===eB&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",cB),eB=new oz()),aB[bB++]=eB.r,aB[bB++]=eB.g,aB[bB++]=eB.b}return this}copyVector2sArray(fB){const gB=this.array;let hB=0;for(let iB=0,jB=fB.length;iB<jB;iB++){let kB=fB[iB];void 0===kB&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",iB),kB=new da()),gB[hB++]=kB.x,gB[hB++]=kB.y}return this}copyVector3sArray(lB){const mB=this.array;let nB=0;for(let oB=0,pB=lB.length;oB<pB;oB++){let qB=lB[oB];void 0===qB&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",oB),qB=new Qi()),mB[nB++]=qB.x,mB[nB++]=qB.y,mB[nB++]=qB.z}return this}copyVector4sArray(rB){const sB=this.array;let tB=0;for(let uB=0,vB=rB.length;uB<vB;uB++){let wB=rB[uB];void 0===wB&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",uB),wB=new ae()),sB[tB++]=wB.x,sB[tB++]=wB.y,sB[tB++]=wB.z,sB[tB++]=wB.w}return this}applyMatrix3(xB){if(2===this.itemSize)for(let yB=0,zB=this.count;yB<zB;yB++)NA.fromBufferAttribute(this,yB),NA.applyMatrix3(xB),this.setXY(yB,NA.x,NA.y);else if(3===this.itemSize)for(let AB=0,BB=this.count;AB<BB;AB++)MA.fromBufferAttribute(this,AB),MA.applyMatrix3(xB),this.setXYZ(AB,MA.x,MA.y,MA.z);return this}applyMatrix4(CB){for(let DB=0,EB=this.count;DB<EB;DB++)MA.x=this.getX(DB),MA.y=this.getY(DB),MA.z=this.getZ(DB),MA.applyMatrix4(CB),this.setXYZ(DB,MA.x,MA.y,MA.z);return this}applyNormalMatrix(FB){for(let GB=0,HB=this.count;GB<HB;GB++)MA.x=this.getX(GB),MA.y=this.getY(GB),MA.z=this.getZ(GB),MA.applyNormalMatrix(FB),this.setXYZ(GB,MA.x,MA.y,MA.z);return this}transformDirection(IB){for(let JB=0,KB=this.count;JB<KB;JB++)MA.x=this.getX(JB),MA.y=this.getY(JB),MA.z=this.getZ(JB),MA.transformDirection(IB),this.setXYZ(JB,MA.x,MA.y,MA.z);return this}set(LB,MB=0){return this.array.set(LB,MB),this}getX(NB){return this.array[NB*this.itemSize]}setX(OB,PB){return this.array[OB*this.itemSize]=PB,this}getY(QB){return this.array[QB*this.itemSize+1]}setY(RB,SB){return this.array[RB*this.itemSize+1]=SB,this}getZ(TB){return this.array[TB*this.itemSize+2]}setZ(UB,VB){return this.array[UB*this.itemSize+2]=VB,this}getW(WB){return this.array[WB*this.itemSize+3]}setW(XB,YB){return this.array[XB*this.itemSize+3]=YB,this}setXY(ZB,$B,_B){return ZB*=this.itemSize,this.array[ZB+0]=$B,this.array[ZB+1]=_B,this}setXYZ(aC,bC,cC,dC){return aC*=this.itemSize,this.array[aC+0]=bC,this.array[aC+1]=cC,this.array[aC+2]=dC,this}setXYZW(eC,fC,gC,hC,iC){return eC*=this.itemSize,this.array[eC+0]=fC,this.array[eC+1]=gC,this.array[eC+2]=hC,this.array[eC+3]=iC,this}onUpload(jC){return this.onUploadCallback=jC,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const kC={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return""!==this.name&&(kC.name=this.name),35044!==this.usage&&(kC.usage=this.usage),(0!==this.updateRange.offset|| -1!==this.updateRange.count)&&(kC.updateRange=this.updateRange),kC}}OA.prototype.isBufferAttribute=!0;class lC extends OA{constructor(mC,nC,oC){super(new Uint16Array(mC),nC,oC)}}class pC extends OA{constructor(qC,rC,sC){super(new Uint32Array(qC),rC,sC)}}(class extends OA{constructor(tC,uC,vC){super(new Uint16Array(tC),uC,vC)}}).prototype.isFloat16BufferAttribute=!0;class wC extends OA{constructor(xC,yC,zC){super(new Float32Array(xC),yC,zC)}}let AC=0;const BC=new dp(),CC=new hv(),DC=new Qi(),EC=new ul(),FC=new ul(),GC=new Qi();class HC extends z{constructor(){super(),Object.defineProperty(this,"id",{value:AC++}),this.uuid=X(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(IC){return Array.isArray(IC)?this.index=new(xd(IC)>65535?pC:lC)(IC,1):this.index=IC,this}getAttribute(JC){return this.attributes[JC]}setAttribute(KC,LC){return this.attributes[KC]=LC,this}deleteAttribute(MC){return delete this.attributes[MC],this}hasAttribute(NC){return void 0!==this.attributes[NC]}addGroup(OC,PC,QC=0){this.groups.push({start:OC,count:PC,materialIndex:QC})}clearGroups(){this.groups=[]}setDrawRange(RC,SC){this.drawRange.start=RC,this.drawRange.count=SC}applyMatrix4(TC){const UC=this.attributes.position;void 0!==UC&&(UC.applyMatrix4(TC),UC.needsUpdate=!0);const VC=this.attributes.normal;if(void 0!==VC){const WC=new ub().getNormalMatrix(TC);VC.applyNormalMatrix(WC),VC.needsUpdate=!0}const XC=this.attributes.tangent;return void 0!==XC&&(XC.transformDirection(TC),XC.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(YC){return BC.makeRotationFromQuaternion(YC),this.applyMatrix4(BC),this}rotateX(ZC){return BC.makeRotationX(ZC),this.applyMatrix4(BC),this}rotateY($C){return BC.makeRotationY($C),this.applyMatrix4(BC),this}rotateZ(_C){return BC.makeRotationZ(_C),this.applyMatrix4(BC),this}translate(aD,bD,cD){return BC.makeTranslation(aD,bD,cD),this.applyMatrix4(BC),this}scale(dD,eD,fD){return BC.makeScale(dD,eD,fD),this.applyMatrix4(BC),this}lookAt(gD){return CC.lookAt(gD),CC.updateMatrix(),this.applyMatrix4(CC.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(DC).negate(),this.translate(DC.x,DC.y,DC.z),this}setFromPoints(hD){const iD=[];for(let jD=0,kD=hD.length;jD<kD;jD++){const lD=hD[jD];iD.push(lD.x,lD.y,lD.z||0)}return this.setAttribute("position",new wC(iD,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new ul());const mD=this.attributes.position,nD=this.morphAttributes.position;if(mD&&mD.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".",this),this.boundingBox.set(new Qi(-1/0,-1/0,-1/0),new Qi(Infinity,Infinity,Infinity));return}if(void 0!==mD){if(this.boundingBox.setFromBufferAttribute(mD),nD)for(let oD=0,pD=nD.length;oD<pD;oD++){const qD=nD[oD];EC.setFromBufferAttribute(qD),this.morphTargetsRelative?(GC.addVectors(this.boundingBox.min,EC.min),this.boundingBox.expandByPoint(GC),GC.addVectors(this.boundingBox.max,EC.max),this.boundingBox.expandByPoint(GC)):(this.boundingBox.expandByPoint(EC.min),this.boundingBox.expandByPoint(EC.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error("THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.",this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new $m());const rD=this.attributes.position,sD=this.morphAttributes.position;if(rD&&rD.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".",this),this.boundingSphere.set(new Qi(),1/0);return}if(rD){const tD=this.boundingSphere.center;if(EC.setFromBufferAttribute(rD),sD)for(let uD=0,vD=sD.length;uD<vD;uD++){const wD=sD[uD];FC.setFromBufferAttribute(wD),this.morphTargetsRelative?(GC.addVectors(EC.min,FC.min),EC.expandByPoint(GC),GC.addVectors(EC.max,FC.max),EC.expandByPoint(GC)):(EC.expandByPoint(FC.min),EC.expandByPoint(FC.max))}EC.getCenter(tD);let xD=0;for(let yD=0,zD=rD.count;yD<zD;yD++)GC.fromBufferAttribute(rD,yD),xD=Math.max(xD,tD.distanceToSquared(GC));if(sD)for(let AD=0,BD=sD.length;AD<BD;AD++){const CD=sD[AD],DD=this.morphTargetsRelative;for(let ED=0,FD=CD.count;ED<FD;ED++)GC.fromBufferAttribute(CD,ED),DD&&(DC.fromBufferAttribute(rD,ED),GC.add(DC)),xD=Math.max(xD,tD.distanceToSquared(GC))}this.boundingSphere.radius=Math.sqrt(xD),isNaN(this.boundingSphere.radius)&&console.error("THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.",this)}}computeTangents(){const GD=this.index,HD=this.attributes;if(null===GD|| void 0===HD.position|| void 0===HD.normal|| void 0===HD.uv){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const ID=GD.array,JD=HD.position.array,KD=HD.normal.array,LD=HD.uv.array,MD=JD.length/3;void 0===HD.tangent&&this.setAttribute("tangent",new OA(new Float32Array(4*MD),4));const ND=HD.tangent.array,OD=[],PD=[];for(let QD=0;QD<MD;QD++)OD[QD]=new Qi(),PD[QD]=new Qi();const RD=new Qi(),SD=new Qi(),TD=new Qi(),UD=new da(),VD=new da(),WD=new da(),XD=new Qi(),YD=new Qi();function ZD(a,b,c){RD.fromArray(JD,3*a),SD.fromArray(JD,3*b),TD.fromArray(JD,3*c),UD.fromArray(LD,2*a),VD.fromArray(LD,2*b),WD.fromArray(LD,2*c),SD.sub(RD),TD.sub(RD),VD.sub(UD),WD.sub(UD);const d=1/(VD.x*WD.y-WD.x*VD.y);isFinite(d)&&(XD.copy(SD).multiplyScalar(WD.y).addScaledVector(TD,-VD.y).multiplyScalar(d),YD.copy(TD).multiplyScalar(VD.x).addScaledVector(SD,-WD.x).multiplyScalar(d),OD[a].add(XD),OD[b].add(XD),OD[c].add(XD),PD[a].add(YD),PD[b].add(YD),PD[c].add(YD))}let $D=this.groups;0===$D.length&&($D=[{start:0,count:ID.length}]);for(let _D=0,aE=$D.length;_D<aE;++_D){const bE=$D[_D],cE=bE.start,dE=bE.count;for(let eE=cE,fE=cE+dE;eE<fE;eE+=3)ZD(ID[eE+0],ID[eE+1],ID[eE+2])}const gE=new Qi(),hE=new Qi(),iE=new Qi(),jE=new Qi();function kE(a){iE.fromArray(KD,3*a),jE.copy(iE);const b=OD[a];gE.copy(b),gE.sub(iE.multiplyScalar(iE.dot(b))).normalize(),hE.crossVectors(jE,b);const c=hE.dot(PD[a]);ND[4*a]=gE.x,ND[4*a+1]=gE.y,ND[4*a+2]=gE.z,ND[4*a+3]=c<0?-1:1}for(let lE=0,mE=$D.length;lE<mE;++lE){const nE=$D[lE],oE=nE.start,pE=nE.count;for(let qE=oE,rE=oE+pE;qE<rE;qE+=3)kE(ID[qE+0]),kE(ID[qE+1]),kE(ID[qE+2])}}computeVertexNormals(){const sE=this.index,tE=this.getAttribute("position");if(void 0!==tE){let uE=this.getAttribute("normal");if(void 0===uE)uE=new OA(new Float32Array(3*tE.count),3),this.setAttribute("normal",uE);else for(let vE=0,wE=uE.count;vE<wE;vE++)uE.setXYZ(vE,0,0,0);const xE=new Qi(),yE=new Qi(),zE=new Qi(),AE=new Qi(),BE=new Qi(),CE=new Qi(),DE=new Qi(),EE=new Qi();if(sE)for(let FE=0,GE=sE.count;FE<GE;FE+=3){const HE=sE.getX(FE+0),IE=sE.getX(FE+1),JE=sE.getX(FE+2);xE.fromBufferAttribute(tE,HE),yE.fromBufferAttribute(tE,IE),zE.fromBufferAttribute(tE,JE),DE.subVectors(zE,yE),EE.subVectors(xE,yE),DE.cross(EE),AE.fromBufferAttribute(uE,HE),BE.fromBufferAttribute(uE,IE),CE.fromBufferAttribute(uE,JE),AE.add(DE),BE.add(DE),CE.add(DE),uE.setXYZ(HE,AE.x,AE.y,AE.z),uE.setXYZ(IE,BE.x,BE.y,BE.z),uE.setXYZ(JE,CE.x,CE.y,CE.z)}else for(let KE=0,LE=tE.count;KE<LE;KE+=3)xE.fromBufferAttribute(tE,KE+0),yE.fromBufferAttribute(tE,KE+1),zE.fromBufferAttribute(tE,KE+2),DE.subVectors(zE,yE),EE.subVectors(xE,yE),DE.cross(EE),uE.setXYZ(KE+0,DE.x,DE.y,DE.z),uE.setXYZ(KE+1,DE.x,DE.y,DE.z),uE.setXYZ(KE+2,DE.x,DE.y,DE.z);this.normalizeNormals(),uE.needsUpdate=!0}}merge(ME,NE){if(!(ME&&ME.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",ME);return}void 0===NE&&(NE=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const OE=this.attributes;for(const PE in OE){if(void 0===ME.attributes[PE])continue;const QE=OE[PE],RE=QE.array,SE=ME.attributes[PE],TE=SE.array,UE=SE.itemSize*NE,VE=Math.min(TE.length,RE.length-UE);for(let WE=0,XE=UE;WE<VE;WE++,XE++)RE[XE]=TE[WE]}return this}normalizeNormals(){const YE=this.attributes.normal;for(let ZE=0,$E=YE.count;ZE<$E;ZE++)GC.fromBufferAttribute(YE,ZE),GC.normalize(),YE.setXYZ(ZE,GC.x,GC.y,GC.z)}toNonIndexed(){function _E(a,b){const c=a.array,d=a.itemSize,e=a.normalized,f=new c.constructor(b.length*d);let g=0,h=0;for(let i=0,j=b.length;i<j;i++){g=a.isInterleavedBufferAttribute?b[i]*a.data.stride+a.offset:b[i]*d;for(let k=0;k<d;k++)f[h++]=c[g++]}return new OA(f,d,e)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const aF=new HC(),bF=this.index.array,cF=this.attributes;for(const dF in cF){const eF=cF[dF],fF=_E(eF,bF);aF.setAttribute(dF,fF)}const gF=this.morphAttributes;for(const hF in gF){const iF=[],jF=gF[hF];for(let kF=0,lF=jF.length;kF<lF;kF++){const mF=jF[kF],nF=_E(mF,bF);iF.push(nF)}aF.morphAttributes[hF]=iF}aF.morphTargetsRelative=this.morphTargetsRelative;const oF=this.groups;for(let pF=0,qF=oF.length;pF<qF;pF++){const rF=oF[pF];aF.addGroup(rF.start,rF.count,rF.materialIndex)}return aF}toJSON(){const sF={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(sF.uuid=this.uuid,sF.type=this.type,""!==this.name&&(sF.name=this.name),Object.keys(this.userData).length>0&&(sF.userData=this.userData),void 0!==this.parameters){const tF=this.parameters;for(const uF in tF)void 0!==tF[uF]&&(sF[uF]=tF[uF]);return sF}sF.data={attributes:{}};const vF=this.index;null!==vF&&(sF.data.index={type:vF.array.constructor.name,array:Array.prototype.slice.call(vF.array)});const wF=this.attributes;for(const xF in wF){const yF=wF[xF];sF.data.attributes[xF]=yF.toJSON(sF.data)}const zF={};let AF=!1;for(const BF in this.morphAttributes){const CF=this.morphAttributes[BF],DF=[];for(let EF=0,FF=CF.length;EF<FF;EF++){const GF=CF[EF];DF.push(GF.toJSON(sF.data))}DF.length>0&&(zF[BF]=DF,AF=!0)}AF&&(sF.data.morphAttributes=zF,sF.data.morphTargetsRelative=this.morphTargetsRelative);const HF=this.groups;HF.length>0&&(sF.data.groups=JSON.parse(JSON.stringify(HF)));const IF=this.boundingSphere;return null!==IF&&(sF.data.boundingSphere={center:IF.center.toArray(),radius:IF.radius}),sF}clone(){return new this.constructor().copy(this)}copy(JF){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const KF={};this.name=JF.name;const LF=JF.index;null!==LF&&this.setIndex(LF.clone(KF));const MF=JF.attributes;for(const NF in MF){const OF=MF[NF];this.setAttribute(NF,OF.clone(KF))}const PF=JF.morphAttributes;for(const QF in PF){const RF=[],SF=PF[QF];for(let TF=0,UF=SF.length;TF<UF;TF++)RF.push(SF[TF].clone(KF));this.morphAttributes[QF]=RF}this.morphTargetsRelative=JF.morphTargetsRelative;const VF=JF.groups;for(let WF=0,XF=VF.length;WF<XF;WF++){const YF=VF[WF];this.addGroup(YF.start,YF.count,YF.materialIndex)}const ZF=JF.boundingBox;null!==ZF&&(this.boundingBox=ZF.clone());const $F=JF.boundingSphere;return null!==$F&&(this.boundingSphere=$F.clone()),this.drawRange.start=JF.drawRange.start,this.drawRange.count=JF.drawRange.count,this.userData=JF.userData,void 0!==JF.parameters&&(this.parameters=Object.assign({},JF.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}HC.prototype.isBufferGeometry=!0;const _F=new dp(),aG=new Kn(),bG=new $m(),cG=new Qi(),dG=new Qi(),eG=new Qi(),fG=new Qi(),gG=new Qi(),hG=new Qi(),iG=new Qi(),jG=new Qi(),kG=new Qi(),lG=new da(),mG=new da(),nG=new da(),oG=new Qi(),pG=new Qi();class qG extends hv{constructor(rG=new HC(),sG=new JA()){super(),this.type="Mesh",this.geometry=rG,this.material=sG,this.updateMorphTargets()}copy(tG){return super.copy(tG),void 0!==tG.morphTargetInfluences&&(this.morphTargetInfluences=tG.morphTargetInfluences.slice()),void 0!==tG.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},tG.morphTargetDictionary)),this.material=tG.material,this.geometry=tG.geometry,this}updateMorphTargets(){const uG=this.geometry;if(uG.isBufferGeometry){const vG=uG.morphAttributes,wG=Object.keys(vG);if(wG.length>0){const xG=vG[wG[0]];if(void 0!==xG){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let yG=0,zG=xG.length;yG<zG;yG++){const AG=xG[yG].name||String(yG);this.morphTargetInfluences.push(0),this.morphTargetDictionary[AG]=yG}}}}else{const BG=uG.morphTargets;void 0!==BG&&BG.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(CG,DG){const EG=this.geometry,FG=this.material,GG=this.matrixWorld;if(void 0===FG)return;if(null===EG.boundingSphere&&EG.computeBoundingSphere(),bG.copy(EG.boundingSphere),bG.applyMatrix4(GG),!1===CG.ray.intersectsSphere(bG))return;if(_F.copy(GG).invert(),aG.copy(CG.ray).applyMatrix4(_F),null!==EG.boundingBox&& !1===aG.intersectsBox(EG.boundingBox))return;let HG;if(EG.isBufferGeometry){const IG=EG.index,JG=EG.attributes.position,KG=EG.morphAttributes.position,LG=EG.morphTargetsRelative,MG=EG.attributes.uv,NG=EG.attributes.uv2,OG=EG.groups,PG=EG.drawRange;if(null!==IG)if(Array.isArray(FG))for(let QG=0,RG=OG.length;QG<RG;QG++){const SG=OG[QG],TG=FG[SG.materialIndex],UG=Math.max(SG.start,PG.start),VG=Math.min(IG.count,Math.min(SG.start+SG.count,PG.start+PG.count));for(let WG=UG,XG=VG;WG<XG;WG+=3){const YG=IG.getX(WG),ZG=IG.getX(WG+1),$G=IG.getX(WG+2);(HG=yH(this,TG,CG,aG,JG,KG,LG,MG,NG,YG,ZG,$G))&&(HG.faceIndex=Math.floor(WG/3),HG.face.materialIndex=SG.materialIndex,DG.push(HG))}}else{const _G=Math.max(0,PG.start),aH=Math.min(IG.count,PG.start+PG.count);for(let bH=_G,cH=aH;bH<cH;bH+=3){const dH=IG.getX(bH),eH=IG.getX(bH+1),fH=IG.getX(bH+2);(HG=yH(this,FG,CG,aG,JG,KG,LG,MG,NG,dH,eH,fH))&&(HG.faceIndex=Math.floor(bH/3),DG.push(HG))}}else if(void 0!==JG)if(Array.isArray(FG))for(let gH=0,hH=OG.length;gH<hH;gH++){const iH=OG[gH],jH=FG[iH.materialIndex],kH=Math.max(iH.start,PG.start),lH=Math.min(JG.count,Math.min(iH.start+iH.count,PG.start+PG.count));for(let mH=kH,nH=lH;mH<nH;mH+=3){const oH=mH,pH=mH+1,qH=mH+2;(HG=yH(this,jH,CG,aG,JG,KG,LG,MG,NG,oH,pH,qH))&&(HG.faceIndex=Math.floor(mH/3),HG.face.materialIndex=iH.materialIndex,DG.push(HG))}}else{const rH=Math.max(0,PG.start),sH=Math.min(JG.count,PG.start+PG.count);for(let tH=rH,uH=sH;tH<uH;tH+=3){const vH=tH,wH=tH+1,xH=tH+2;(HG=yH(this,FG,CG,aG,JG,KG,LG,MG,NG,vH,wH,xH))&&(HG.faceIndex=Math.floor(tH/3),DG.push(HG))}}}else EG.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}function yH(a,b,c,d,e,f,i,j,k,l,m,n){cG.fromBufferAttribute(e,l),dG.fromBufferAttribute(e,m),eG.fromBufferAttribute(e,n);const o=a.morphTargetInfluences;if(f&&o){iG.set(0,0,0),jG.set(0,0,0),kG.set(0,0,0);for(let p=0,q=f.length;p<q;p++){const r=o[p],s=f[p];0!==r&&(fG.fromBufferAttribute(s,l),gG.fromBufferAttribute(s,m),hG.fromBufferAttribute(s,n),i?(iG.addScaledVector(fG,r),jG.addScaledVector(gG,r),kG.addScaledVector(hG,r)):(iG.addScaledVector(fG.sub(cG),r),jG.addScaledVector(gG.sub(dG),r),kG.addScaledVector(hG.sub(eG),r)))}cG.add(iG),dG.add(jG),eG.add(kG)}a.isSkinnedMesh&&(a.boneTransform(l,cG),a.boneTransform(m,dG),a.boneTransform(n,eG));const t=function(a,b,c,d,e,f,i,j){if(null===(b.side===g?d.intersectTriangle(i,f,e,!0,j):d.intersectTriangle(e,f,i,b.side!==h,j)))return null;pG.copy(j),pG.applyMatrix4(a.matrixWorld);const k=c.ray.origin.distanceTo(pG);return k<c.near||k>c.far?null:{distance:k,point:pG.clone(),object:a}}(a,b,c,d,cG,dG,eG,oG);if(t){j&&(lG.fromBufferAttribute(j,l),mG.fromBufferAttribute(j,m),nG.fromBufferAttribute(j,n),t.uv=px.getUV(oG,cG,dG,eG,lG,mG,nG,new da())),k&&(lG.fromBufferAttribute(k,l),mG.fromBufferAttribute(k,m),nG.fromBufferAttribute(k,n),t.uv2=px.getUV(oG,cG,dG,eG,lG,mG,nG,new da()));const u={a:l,b:m,c:n,normal:new Qi(),materialIndex:0};px.getNormal(cG,dG,eG,u.normal),t.face=u}return t}qG.prototype.isMesh=!0;class zH extends HC{constructor(AH=1,BH=1,CH=1,DH=1,EH=1,FH=1){super(),this.type="BoxGeometry",this.parameters={width:AH,height:BH,depth:CH,widthSegments:DH,heightSegments:EH,depthSegments:FH};const GH=this;DH=Math.floor(DH),EH=Math.floor(EH),FH=Math.floor(FH);const HH=[],IH=[],JH=[],KH=[];let LH=0,MH=0;function NH(a,b,c,d,e,f,g,h,i,j,k){const l=f/i,m=g/j,n=f/2,o=g/2,p=h/2,q=i+1,r=j+1;let s=0,t=0;const u=new Qi();for(let v=0;v<r;v++){const w=v*m-o;for(let x=0;x<q;x++){const y=x*l-n;u[a]=y*d,u[b]=w*e,u[c]=p,IH.push(u.x,u.y,u.z),u[a]=0,u[b]=0,u[c]=h>0?1:-1,JH.push(u.x,u.y,u.z),KH.push(x/i),KH.push(1-v/j),s+=1}}for(let z=0;z<j;z++)for(let A=0;A<i;A++){const B=LH+A+q*z,C=LH+A+q*(z+1),D=LH+(A+1)+q*(z+1),E=LH+(A+1)+q*z;HH.push(B,C,E),HH.push(C,D,E),t+=6}GH.addGroup(MH,t,k),MH+=t,LH+=s}NH("z","y","x",-1,-1,CH,BH,AH,FH,EH,0),NH("z","y","x",1,-1,CH,BH,-AH,FH,EH,1),NH("x","z","y",1,1,AH,CH,BH,DH,FH,2),NH("x","z","y",1,-1,AH,CH,-BH,DH,FH,3),NH("x","y","z",1,-1,AH,BH,CH,DH,EH,4),NH("x","y","z",-1,-1,AH,BH,-CH,DH,EH,5),this.setIndex(HH),this.setAttribute("position",new wC(IH,3)),this.setAttribute("normal",new wC(JH,3)),this.setAttribute("uv",new wC(KH,2))}static fromJSON(OH){return new zH(OH.width,OH.height,OH.depth,OH.widthSegments,OH.heightSegments,OH.depthSegments)}}function PH(a){const b={};for(const c in a)for(const d in b[c]={},a[c]){const e=a[c][d];e&&(e.isColor||e.isMatrix3||e.isMatrix4||e.isVector2||e.isVector3||e.isVector4||e.isTexture||e.isQuaternion)?b[c][d]=e.clone():Array.isArray(e)?b[c][d]=e.slice():b[c][d]=e}return b}function QH(a){const b={};for(let c=0;c<a.length;c++){const d=PH(a[c]);for(const e in d)b[e]=d[e]}return b}const RH={clone:PH,merge:QH};class SH extends Sy{constructor(TH){super(),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,void 0!==TH&&(void 0!==TH.attributes&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(TH))}copy(UH){return super.copy(UH),this.fragmentShader=UH.fragmentShader,this.vertexShader=UH.vertexShader,this.uniforms=PH(UH.uniforms),this.defines=Object.assign({},UH.defines),this.wireframe=UH.wireframe,this.wireframeLinewidth=UH.wireframeLinewidth,this.lights=UH.lights,this.clipping=UH.clipping,this.extensions=Object.assign({},UH.extensions),this.glslVersion=UH.glslVersion,this}toJSON(VH){const WH=super.toJSON(VH);for(const XH in WH.glslVersion=this.glslVersion,WH.uniforms={},this.uniforms){const YH=this.uniforms[XH],ZH=YH.value;ZH&&ZH.isTexture?WH.uniforms[XH]={type:"t",value:ZH.toJSON(VH).uuid}:ZH&&ZH.isColor?WH.uniforms[XH]={type:"c",value:ZH.getHex()}:ZH&&ZH.isVector2?WH.uniforms[XH]={type:"v2",value:ZH.toArray()}:ZH&&ZH.isVector3?WH.uniforms[XH]={type:"v3",value:ZH.toArray()}:ZH&&ZH.isVector4?WH.uniforms[XH]={type:"v4",value:ZH.toArray()}:ZH&&ZH.isMatrix3?WH.uniforms[XH]={type:"m3",value:ZH.toArray()}:ZH&&ZH.isMatrix4?WH.uniforms[XH]={type:"m4",value:ZH.toArray()}:WH.uniforms[XH]={value:ZH}}Object.keys(this.defines).length>0&&(WH.defines=this.defines),WH.vertexShader=this.vertexShader,WH.fragmentShader=this.fragmentShader;const $H={};for(const _H in this.extensions)!0===this.extensions[_H]&&($H[_H]=!0);return Object.keys($H).length>0&&(WH.extensions=$H),WH}}SH.prototype.isShaderMaterial=!0;class aI extends hv{constructor(){super(),this.type="Camera",this.matrixWorldInverse=new dp(),this.projectionMatrix=new dp(),this.projectionMatrixInverse=new dp()}copy(bI,cI){return super.copy(bI,cI),this.matrixWorldInverse.copy(bI.matrixWorldInverse),this.projectionMatrix.copy(bI.projectionMatrix),this.projectionMatrixInverse.copy(bI.projectionMatrixInverse),this}getWorldDirection(dI){this.updateWorldMatrix(!0,!1);const eI=this.matrixWorld.elements;return dI.set(-eI[8],-eI[9],-eI[10]).normalize()}updateMatrixWorld(fI){super.updateMatrixWorld(fI),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(gI,hI){super.updateWorldMatrix(gI,hI),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}aI.prototype.isCamera=!0;class iI extends aI{constructor(jI=50,kI=1,lI=0.1,mI=2000){super(),this.type="PerspectiveCamera",this.fov=jI,this.zoom=1,this.near=lI,this.far=mI,this.focus=10,this.aspect=kI,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(nI,oI){return super.copy(nI,oI),this.fov=nI.fov,this.zoom=nI.zoom,this.near=nI.near,this.far=nI.far,this.focus=nI.focus,this.aspect=nI.aspect,this.view=null===nI.view?null:Object.assign({},nI.view),this.filmGauge=nI.filmGauge,this.filmOffset=nI.filmOffset,this}setFocalLength(pI){const qI=0.5*this.getFilmHeight()/pI;this.fov=2*T*Math.atan(qI),this.updateProjectionMatrix()}getFocalLength(){const rI=Math.tan(0.5*S*this.fov);return 0.5*this.getFilmHeight()/rI}getEffectiveFOV(){return 2*T*Math.atan(Math.tan(0.5*S*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(sI,tI,uI,vI,wI,xI){this.aspect=sI/tI,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=sI,this.view.fullHeight=tI,this.view.offsetX=uI,this.view.offsetY=vI,this.view.width=wI,this.view.height=xI,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const yI=this.near;let zI=yI*Math.tan(0.5*S*this.fov)/this.zoom,AI=2*zI,BI=this.aspect*AI,CI=-0.5*BI;const DI=this.view;if(null!==this.view&&this.view.enabled){const EI=DI.fullWidth,FI=DI.fullHeight;CI+=DI.offsetX*BI/EI,zI-=DI.offsetY*AI/FI,BI*=DI.width/EI,AI*=DI.height/FI}const GI=this.filmOffset;0!==GI&&(CI+=yI*GI/this.getFilmWidth()),this.projectionMatrix.makePerspective(CI,CI+BI,zI,zI-AI,yI,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(HI){const II=super.toJSON(HI);return II.object.fov=this.fov,II.object.zoom=this.zoom,II.object.near=this.near,II.object.far=this.far,II.object.focus=this.focus,II.object.aspect=this.aspect,null!==this.view&&(II.object.view=Object.assign({},this.view)),II.object.filmGauge=this.filmGauge,II.object.filmOffset=this.filmOffset,II}}iI.prototype.isPerspectiveCamera=!0;class JI extends hv{constructor(KI,LI,MI){if(super(),this.type="CubeCamera",!0!==MI.isWebGLCubeRenderTarget){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=MI;const NI=new iI(90,1,KI,LI);NI.layers=this.layers,NI.up.set(0,-1,0),NI.lookAt(new Qi(1,0,0)),this.add(NI);const OI=new iI(90,1,KI,LI);OI.layers=this.layers,OI.up.set(0,-1,0),OI.lookAt(new Qi(-1,0,0)),this.add(OI);const PI=new iI(90,1,KI,LI);PI.layers=this.layers,PI.up.set(0,0,1),PI.lookAt(new Qi(0,1,0)),this.add(PI);const QI=new iI(90,1,KI,LI);QI.layers=this.layers,QI.up.set(0,0,-1),QI.lookAt(new Qi(0,-1,0)),this.add(QI);const RI=new iI(90,1,KI,LI);RI.layers=this.layers,RI.up.set(0,-1,0),RI.lookAt(new Qi(0,0,1)),this.add(RI);const SI=new iI(90,1,KI,LI);SI.layers=this.layers,SI.up.set(0,-1,0),SI.lookAt(new Qi(0,0,-1)),this.add(SI)}update(TI,UI){null===this.parent&&this.updateMatrixWorld();const VI=this.renderTarget,[WI,XI,YI,ZI,$I,_I]=this.children,aJ=TI.xr.enabled,bJ=TI.getRenderTarget();TI.xr.enabled=!1;const cJ=VI.texture.generateMipmaps;VI.texture.generateMipmaps=!1,TI.setRenderTarget(VI,0),TI.render(UI,WI),TI.setRenderTarget(VI,1),TI.render(UI,XI),TI.setRenderTarget(VI,2),TI.render(UI,YI),TI.setRenderTarget(VI,3),TI.render(UI,ZI),TI.setRenderTarget(VI,4),TI.render(UI,$I),VI.texture.generateMipmaps=cJ,TI.setRenderTarget(VI,5),TI.render(UI,_I),TI.setRenderTarget(bJ),TI.xr.enabled=aJ}}class dJ extends Gd{constructor(eJ,fJ,gJ,hJ,iJ,jJ,kJ,lJ,mJ,nJ){super(eJ=void 0!==eJ?eJ:[],fJ=void 0!==fJ?fJ:301,gJ,hJ,iJ,jJ,kJ,lJ,mJ,nJ),this.flipY=!1}get images(){return this.image}set images(oJ){this.image=oJ}}dJ.prototype.isCubeTexture=!0;class pJ extends Kf{constructor(qJ,rJ,sJ){Number.isInteger(rJ)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),rJ=sJ),super(qJ,qJ,rJ),rJ=rJ||{},this.texture=new dJ(void 0,rJ.mapping,rJ.wrapS,rJ.wrapT,rJ.magFilter,rJ.minFilter,rJ.format,rJ.type,rJ.anisotropy,rJ.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=void 0!==rJ.generateMipmaps&&rJ.generateMipmaps,this.texture.minFilter=void 0!==rJ.minFilter?rJ.minFilter:o,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(tJ,uJ){this.texture.type=uJ.type,this.texture.format=1023,this.texture.encoding=uJ.encoding,this.texture.generateMipmaps=uJ.generateMipmaps,this.texture.minFilter=uJ.minFilter,this.texture.magFilter=uJ.magFilter;const vJ={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},wJ=new zH(5,5,5),xJ=new SH({name:"CubemapFromEquirect",uniforms:PH(vJ.uniforms),vertexShader:vJ.vertexShader,fragmentShader:vJ.fragmentShader,side:g,blending:0});xJ.uniforms.tEquirect.value=uJ;const yJ=new qG(wJ,xJ),zJ=uJ.minFilter;uJ.minFilter===q&&(uJ.minFilter=o);const AJ=new JI(1,10,this);return AJ.update(tJ,yJ),uJ.minFilter=zJ,yJ.geometry.dispose(),yJ.material.dispose(),this}clear(BJ,CJ,DJ,EJ){const FJ=BJ.getRenderTarget();for(let GJ=0;GJ<6;GJ++)BJ.setRenderTarget(this,GJ),BJ.clear(CJ,DJ,EJ);BJ.setRenderTarget(FJ)}}pJ.prototype.isWebGLCubeRenderTarget=!0;const HJ=new Qi(),IJ=new Qi(),JJ=new ub();class KJ{constructor(LJ=new Qi(1,0,0),MJ=0){this.normal=LJ,this.constant=MJ}set(NJ,OJ){return this.normal.copy(NJ),this.constant=OJ,this}setComponents(PJ,QJ,RJ,SJ){return this.normal.set(PJ,QJ,RJ),this.constant=SJ,this}setFromNormalAndCoplanarPoint(TJ,UJ){return this.normal.copy(TJ),this.constant=-UJ.dot(this.normal),this}setFromCoplanarPoints(VJ,WJ,XJ){const YJ=HJ.subVectors(XJ,WJ).cross(IJ.subVectors(VJ,WJ)).normalize();return this.setFromNormalAndCoplanarPoint(YJ,VJ),this}copy(ZJ){return this.normal.copy(ZJ.normal),this.constant=ZJ.constant,this}normalize(){const $J=1/this.normal.length();return this.normal.multiplyScalar($J),this.constant*=$J,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(_J){return this.normal.dot(_J)+this.constant}distanceToSphere(aK){return this.distanceToPoint(aK.center)-aK.radius}projectPoint(bK,cK){return cK.copy(this.normal).multiplyScalar(-this.distanceToPoint(bK)).add(bK)}intersectLine(dK,eK){const fK=dK.delta(HJ),gK=this.normal.dot(fK);if(0===gK)return 0===this.distanceToPoint(dK.start)?eK.copy(dK.start):null;const hK=-(dK.start.dot(this.normal)+this.constant)/gK;return hK<0||hK>1?null:eK.copy(fK).multiplyScalar(hK).add(dK.start)}intersectsLine(iK){const jK=this.distanceToPoint(iK.start),kK=this.distanceToPoint(iK.end);return jK<0&&kK>0||kK<0&&jK>0}intersectsBox(lK){return lK.intersectsPlane(this)}intersectsSphere(mK){return mK.intersectsPlane(this)}coplanarPoint(nK){return nK.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(oK,pK){const qK=pK||JJ.getNormalMatrix(oK),rK=this.coplanarPoint(HJ).applyMatrix4(oK),sK=this.normal.applyMatrix3(qK).normalize();return this.constant=-rK.dot(sK),this}translate(tK){return this.constant-=tK.dot(this.normal),this}equals(uK){return uK.normal.equals(this.normal)&&uK.constant===this.constant}clone(){return new this.constructor().copy(this)}}KJ.prototype.isPlane=!0;const vK=new $m(),wK=new Qi();class xK{constructor(yK=new KJ(),zK=new KJ(),AK=new KJ(),BK=new KJ(),CK=new KJ(),DK=new KJ()){this.planes=[yK,zK,AK,BK,CK,DK]}set(EK,FK,GK,HK,IK,JK){const KK=this.planes;return KK[0].copy(EK),KK[1].copy(FK),KK[2].copy(GK),KK[3].copy(HK),KK[4].copy(IK),KK[5].copy(JK),this}copy(LK){const MK=this.planes;for(let NK=0;NK<6;NK++)MK[NK].copy(LK.planes[NK]);return this}setFromProjectionMatrix(OK){const PK=this.planes,QK=OK.elements,RK=QK[0],SK=QK[1],TK=QK[2],UK=QK[3],VK=QK[4],WK=QK[5],XK=QK[6],YK=QK[7],ZK=QK[8],$K=QK[9],_K=QK[10],aL=QK[11],bL=QK[12],cL=QK[13],dL=QK[14],eL=QK[15];return PK[0].setComponents(UK-RK,YK-VK,aL-ZK,eL-bL).normalize(),PK[1].setComponents(UK+RK,YK+VK,aL+ZK,eL+bL).normalize(),PK[2].setComponents(UK+SK,YK+WK,aL+$K,eL+cL).normalize(),PK[3].setComponents(UK-SK,YK-WK,aL-$K,eL-cL).normalize(),PK[4].setComponents(UK-TK,YK-XK,aL-_K,eL-dL).normalize(),PK[5].setComponents(UK+TK,YK+XK,aL+_K,eL+dL).normalize(),this}intersectsObject(fL){const gL=fL.geometry;return null===gL.boundingSphere&&gL.computeBoundingSphere(),vK.copy(gL.boundingSphere).applyMatrix4(fL.matrixWorld),this.intersectsSphere(vK)}intersectsSprite(hL){return vK.center.set(0,0,0),vK.radius=0.7071067811865476,vK.applyMatrix4(hL.matrixWorld),this.intersectsSphere(vK)}intersectsSphere(iL){const jL=this.planes,kL=iL.center,lL=-iL.radius;for(let mL=0;mL<6;mL++){const nL=jL[mL].distanceToPoint(kL);if(nL<lL)return!1}return!0}intersectsBox(oL){const pL=this.planes;for(let qL=0;qL<6;qL++){const rL=pL[qL];if(wK.x=rL.normal.x>0?oL.max.x:oL.min.x,wK.y=rL.normal.y>0?oL.max.y:oL.min.y,wK.z=rL.normal.z>0?oL.max.z:oL.min.z,0>rL.distanceToPoint(wK))return!1}return!0}containsPoint(sL){const tL=this.planes;for(let uL=0;uL<6;uL++)if(0>tL[uL].distanceToPoint(sL))return!1;return!0}clone(){return new this.constructor().copy(this)}}function vL(){let a=null,b=!1,c=null,d=null;function e(b,f){c(b,f),d=a.requestAnimationFrame(e)}return{start:function(){!0!==b&&null!==c&&(d=a.requestAnimationFrame(e),b=!0)},stop:function(){a.cancelAnimationFrame(d),b=!1},setAnimationLoop:function(a){c=a},setContext:function(b){a=b}}}function wL(a,b){const c=b.isWebGL2,d=new WeakMap();return{get:function(a){return a.isInterleavedBufferAttribute&&(a=a.data),d.get(a)},remove:function(b){b.isInterleavedBufferAttribute&&(b=b.data);const c=d.get(b);c&&(a.deleteBuffer(c.buffer),d.delete(b))},update:function(b,e){if(b.isGLBufferAttribute){const f=d.get(b);(!f||f.version<b.version)&&d.set(b,{buffer:b.buffer,type:b.type,bytesPerElement:b.elementSize,version:b.version});return}b.isInterleavedBufferAttribute&&(b=b.data);const g=d.get(b);void 0===g?d.set(b,function(b,d){const e=b.array,f=b.usage,g=a.createBuffer();a.bindBuffer(d,g),a.bufferData(d,e,f),b.onUploadCallback();let h=5126;return e instanceof Float32Array?h=5126:e instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):e instanceof Uint16Array?b.isFloat16BufferAttribute?c?h=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):h=5123:e instanceof Int16Array?h=5122:e instanceof Uint32Array?h=5125:e instanceof Int32Array?h=5124:e instanceof Int8Array?h=5120:e instanceof Uint8Array?h=5121:e instanceof Uint8ClampedArray&&(h=5121),{buffer:g,type:h,bytesPerElement:e.BYTES_PER_ELEMENT,version:b.version}}(b,e)):g.version<b.version&&(!function(b,d,e){const f=d.array,g=d.updateRange;a.bindBuffer(e,b),-1===g.count?a.bufferSubData(e,0,f):(c?a.bufferSubData(e,g.offset*f.BYTES_PER_ELEMENT,f,g.offset,g.count):a.bufferSubData(e,g.offset*f.BYTES_PER_ELEMENT,f.subarray(g.offset,g.offset+g.count)),g.count=-1)}(g.buffer,b,e),g.version=b.version)}}}class xL extends HC{constructor(yL=1,zL=1,AL=1,BL=1){super(),this.type="PlaneGeometry",this.parameters={width:yL,height:zL,widthSegments:AL,heightSegments:BL};const CL=yL/2,DL=zL/2,EL=Math.floor(AL),FL=Math.floor(BL),GL=EL+1,HL=FL+1,IL=yL/EL,JL=zL/FL,KL=[],LL=[],ML=[],NL=[];for(let OL=0;OL<HL;OL++){const PL=OL*JL-DL;for(let QL=0;QL<GL;QL++){const RL=QL*IL-CL;LL.push(RL,-PL,0),ML.push(0,0,1),NL.push(QL/EL),NL.push(1-OL/FL)}}for(let SL=0;SL<FL;SL++)for(let TL=0;TL<EL;TL++){const UL=TL+GL*SL,VL=TL+GL*(SL+1),WL=TL+1+GL*(SL+1),XL=TL+1+GL*SL;KL.push(UL,VL,XL),KL.push(VL,WL,XL)}this.setIndex(KL),this.setAttribute("position",new wC(LL,3)),this.setAttribute("normal",new wC(ML,3)),this.setAttribute("uv",new wC(NL,2))}static fromJSON(YL){return new xL(YL.width,YL.height,YL.widthSegments,YL.heightSegments)}}const ZL={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed = vec3( position );",beginnormal_vertex:"vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",clipping_planes_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",defaultnormal_vertex:"vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor = linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",fog_vertex:"#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_vertex:"vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",map_fragment:"#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",metalnessmap_fragment:"float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",normal_fragment_begin:"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",roughnessmap_fragment:"float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",shadowmap_pars_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",shadowmap_vertex:"#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",transmission_fragment:"#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( float roughness, float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,\n\t\tvec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,\n\t\tvec3 attenuationColor, float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",uv_pars_fragment:"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",cube_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",cube_frag:"#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",depth_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",depth_frag:"#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",equirect_vert:"varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",meshbasic_vert:"#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshlambert_vert:"#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshlambert_frag:"uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - clearcoat * Fcc ) + clearcoatSpecular * clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",points_vert:"uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",shadow_vert:"#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"},$L={common:{diffuse:{value:new oz(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new ub()},uv2Transform:{value:new ub()},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:0.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new da(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:0.00025},fogNear:{value:1},fogFar:{value:2000},fogColor:{value:new oz(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new oz(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new ub()}},sprite:{diffuse:{value:new oz(16777215)},opacity:{value:1},center:{value:new da(0.5,0.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new ub()}}},_L={basic:{uniforms:QH([$L.common,$L.specularmap,$L.envmap,$L.aomap,$L.lightmap,$L.fog]),vertexShader:ZL.meshbasic_vert,fragmentShader:ZL.meshbasic_frag},lambert:{uniforms:QH([$L.common,$L.specularmap,$L.envmap,$L.aomap,$L.lightmap,$L.emissivemap,$L.fog,$L.lights,{emissive:{value:new oz(0)}}]),vertexShader:ZL.meshlambert_vert,fragmentShader:ZL.meshlambert_frag},phong:{uniforms:QH([$L.common,$L.specularmap,$L.envmap,$L.aomap,$L.lightmap,$L.emissivemap,$L.bumpmap,$L.normalmap,$L.displacementmap,$L.fog,$L.lights,{emissive:{value:new oz(0)},specular:{value:new oz(1118481)},shininess:{value:30}}]),vertexShader:ZL.meshphong_vert,fragmentShader:ZL.meshphong_frag},standard:{uniforms:QH([$L.common,$L.envmap,$L.aomap,$L.lightmap,$L.emissivemap,$L.bumpmap,$L.normalmap,$L.displacementmap,$L.roughnessmap,$L.metalnessmap,$L.fog,$L.lights,{emissive:{value:new oz(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ZL.meshphysical_vert,fragmentShader:ZL.meshphysical_frag},toon:{uniforms:QH([$L.common,$L.aomap,$L.lightmap,$L.emissivemap,$L.bumpmap,$L.normalmap,$L.displacementmap,$L.gradientmap,$L.fog,$L.lights,{emissive:{value:new oz(0)}}]),vertexShader:ZL.meshtoon_vert,fragmentShader:ZL.meshtoon_frag},matcap:{uniforms:QH([$L.common,$L.bumpmap,$L.normalmap,$L.displacementmap,$L.fog,{matcap:{value:null}}]),vertexShader:ZL.meshmatcap_vert,fragmentShader:ZL.meshmatcap_frag},points:{uniforms:QH([$L.points,$L.fog]),vertexShader:ZL.points_vert,fragmentShader:ZL.points_frag},dashed:{uniforms:QH([$L.common,$L.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ZL.linedashed_vert,fragmentShader:ZL.linedashed_frag},depth:{uniforms:QH([$L.common,$L.displacementmap]),vertexShader:ZL.depth_vert,fragmentShader:ZL.depth_frag},normal:{uniforms:QH([$L.common,$L.bumpmap,$L.normalmap,$L.displacementmap,{opacity:{value:1}}]),vertexShader:ZL.meshnormal_vert,fragmentShader:ZL.meshnormal_frag},sprite:{uniforms:QH([$L.sprite,$L.fog]),vertexShader:ZL.sprite_vert,fragmentShader:ZL.sprite_frag},background:{uniforms:{uvTransform:{value:new ub()},t2D:{value:null}},vertexShader:ZL.background_vert,fragmentShader:ZL.background_frag},cube:{uniforms:QH([$L.envmap,{opacity:{value:1}}]),vertexShader:ZL.cube_vert,fragmentShader:ZL.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ZL.equirect_vert,fragmentShader:ZL.equirect_frag},distanceRGBA:{uniforms:QH([$L.common,$L.displacementmap,{referencePosition:{value:new Qi()},nearDistance:{value:1},farDistance:{value:1000}}]),vertexShader:ZL.distanceRGBA_vert,fragmentShader:ZL.distanceRGBA_frag},shadow:{uniforms:QH([$L.lights,$L.fog,{color:{value:new oz(0)},opacity:{value:1}},]),vertexShader:ZL.shadow_vert,fragmentShader:ZL.shadow_frag}};function aM(a,b,c,d,e){const h=new oz(0);let i=0,j,k,l=null,m=0,n=null;function o(a,b){c.buffers.color.setClear(a.r,a.g,a.b,b,e)}return{getClearColor:function(){return h},setClearColor:function(a,b=1){h.set(a),o(h,i=b)},getClearAlpha:function(){return i},setClearAlpha:function(a){o(h,i=a)},render:function(c,e){let p=!1,q=!0===e.isScene?e.background:null;q&&q.isTexture&&(q=b.get(q));const r=a.xr,s=r.getSession&&r.getSession();s&&"additive"===s.environmentBlendMode&&(q=null),null===q?o(h,i):q&&q.isColor&&(o(q,1),p=!0),(a.autoClear||p)&&a.clear(a.autoClearColor,a.autoClearDepth,a.autoClearStencil),q&&(q.isCubeTexture||306===q.mapping)?(void 0===k&&((k=new qG(new zH(1,1,1),new SH({name:"BackgroundCubeMaterial",uniforms:PH(_L.cube.uniforms),vertexShader:_L.cube.vertexShader,fragmentShader:_L.cube.fragmentShader,side:g,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),k.geometry.deleteAttribute("uv"),k.onBeforeRender=function(a,b,c){this.matrixWorld.copyPosition(c.matrixWorld)},Object.defineProperty(k.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),d.update(k)),k.material.uniforms.envMap.value=q,k.material.uniforms.flipEnvMap.value=q.isCubeTexture&& !1===q.isRenderTargetTexture?-1:1,(l!==q||m!==q.version||n!==a.toneMapping)&&(k.material.needsUpdate=!0,l=q,m=q.version,n=a.toneMapping),c.unshift(k,k.geometry,k.material,0,0,null)):q&&q.isTexture&&(void 0===j&&((j=new qG(new xL(2,2),new SH({name:"BackgroundMaterial",uniforms:PH(_L.background.uniforms),vertexShader:_L.background.vertexShader,fragmentShader:_L.background.fragmentShader,side:f,depthTest:!1,depthWrite:!1,fog:!1}))).geometry.deleteAttribute("normal"),Object.defineProperty(j.material,"map",{get:function(){return this.uniforms.t2D.value}}),d.update(j)),j.material.uniforms.t2D.value=q,!0===q.matrixAutoUpdate&&q.updateMatrix(),j.material.uniforms.uvTransform.value.copy(q.matrix),(l!==q||m!==q.version||n!==a.toneMapping)&&(j.material.needsUpdate=!0,l=q,m=q.version,n=a.toneMapping),c.unshift(j,j.geometry,j.material,0,0,null))}}}function bM(a,b,c,d){const e=a.getParameter(34921),f=d.isWebGL2?null:b.get("OES_vertex_array_object"),g=d.isWebGL2||null!==f,h={},i=m(null);let j=i;function k(b){return d.isWebGL2?a.bindVertexArray(b):f.bindVertexArrayOES(b)}function l(b){return d.isWebGL2?a.deleteVertexArray(b):f.deleteVertexArrayOES(b)}function m(a){const b=[],c=[],d=[];for(let f=0;f<e;f++)b[f]=0,c[f]=0,d[f]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:b,enabledAttributes:c,attributeDivisors:d,object:a,attributes:{},index:null}}function n(){const a=j.newAttributes;for(let b=0,c=a.length;b<c;b++)a[b]=0}function o(a){p(a,0)}function p(c,e){const f=j.newAttributes,g=j.enabledAttributes,h=j.attributeDivisors;if(f[c]=1,0===g[c]&&(a.enableVertexAttribArray(c),g[c]=1),h[c]!==e){const i=d.isWebGL2?a:b.get("ANGLE_instanced_arrays");i[d.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](c,e),h[c]=e}}function q(){const b=j.newAttributes,c=j.enabledAttributes;for(let d=0,e=c.length;d<e;d++)c[d]!==b[d]&&(a.disableVertexAttribArray(d),c[d]=0)}function r(b,c,e,f,g,h){!0===d.isWebGL2&&(5124===e||5125===e)?a.vertexAttribIPointer(b,c,e,g,h):a.vertexAttribPointer(b,c,e,f,g,h)}function s(){t(),j!==i&&k((j=i).object)}function t(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:function(e,i,l,s,t){let u=!1;if(g){const v=function(b,c,e){const g=!0===e.wireframe;let i=h[b.id];void 0===i&&(i={},h[b.id]=i);let j=i[c.id];void 0===j&&(j={},i[c.id]=j);let k=j[g];return void 0===k&&(k=m(d.isWebGL2?a.createVertexArray():f.createVertexArrayOES()),j[g]=k),k}(s,l,i);j!==v&&k((j=v).object),(u=(function(a,b){const c=j.attributes,d=a.attributes;let e=0;for(const f in d){const g=c[f],h=d[f];if(void 0===g)return!0;if(g.attribute!==h)return!0;if(g.data!==h.data)return!0;e++}return j.attributesNum!==e||j.index!==b})(s,t))&&(function(a,b){const c={},d=a.attributes;let e=0;for(const f in d){const g=d[f],h={};h.attribute=g,g.data&&(h.data=g.data),c[f]=h,e++}j.attributes=c,j.attributesNum=e,j.index=b})(s,t)}else{const w=!0===i.wireframe;(j.geometry!==s.id||j.program!==l.id||j.wireframe!==w)&&(j.geometry=s.id,j.program=l.id,j.wireframe=w,u=!0)}!0===e.isInstancedMesh&&(u=!0),null!==t&&c.update(t,34963),u&&((function(e,f,g,h){if(!1===d.isWebGL2&&(e.isInstancedMesh||h.isInstancedBufferGeometry)&&null===b.get("ANGLE_instanced_arrays"))return;n();const i=h.attributes,j=g.getAttributes(),k=f.defaultAttributeValues;for(const l in j){const m=j[l];if(m.location>=0){let s=i[l];if(void 0===s&&("instanceMatrix"===l&&e.instanceMatrix&&(s=e.instanceMatrix),"instanceColor"===l&&e.instanceColor&&(s=e.instanceColor)),void 0!==s){const t=s.normalized,u=s.itemSize,v=c.get(s);if(void 0===v)continue;const w=v.buffer,x=v.type,y=v.bytesPerElement;if(s.isInterleavedBufferAttribute){const z=s.data,A=z.stride,B=s.offset;if(z&&z.isInstancedInterleavedBuffer){for(let C=0;C<m.locationSize;C++)p(m.location+C,z.meshPerAttribute);!0!==e.isInstancedMesh&& void 0===h._maxInstanceCount&&(h._maxInstanceCount=z.meshPerAttribute*z.count)}else for(let D=0;D<m.locationSize;D++)o(m.location+D);a.bindBuffer(34962,w);for(let E=0;E<m.locationSize;E++)r(m.location+E,u/m.locationSize,x,t,A*y,(B+u/m.locationSize*E)*y)}else{if(s.isInstancedBufferAttribute){for(let F=0;F<m.locationSize;F++)p(m.location+F,s.meshPerAttribute);!0!==e.isInstancedMesh&& void 0===h._maxInstanceCount&&(h._maxInstanceCount=s.meshPerAttribute*s.count)}else for(let G=0;G<m.locationSize;G++)o(m.location+G);a.bindBuffer(34962,w);for(let H=0;H<m.locationSize;H++)r(m.location+H,u/m.locationSize,x,t,u*y,u/m.locationSize*H*y)}}else if(void 0!==k){const I=k[l];if(void 0!==I)switch(I.length){case 2:a.vertexAttrib2fv(m.location,I);break;case 3:a.vertexAttrib3fv(m.location,I);break;case 4:a.vertexAttrib4fv(m.location,I);break;default:a.vertexAttrib1fv(m.location,I)}}}}q()})(e,i,l,s),null!==t&&a.bindBuffer(34963,c.get(t).buffer))},reset:s,resetDefaultState:t,dispose:function(){for(const a in s(),h){const b=h[a];for(const c in b){const d=b[c];for(const e in d)l(d[e].object),delete d[e];delete b[c]}delete h[a]}},releaseStatesOfGeometry:function(a){if(void 0===h[a.id])return;const b=h[a.id];for(const c in b){const d=b[c];for(const e in d)l(d[e].object),delete d[e];delete b[c]}delete h[a.id]},releaseStatesOfProgram:function(a){for(const b in h){const c=h[b];if(void 0===c[a.id])continue;const d=c[a.id];for(const e in d)l(d[e].object),delete d[e];delete c[a.id]}},initAttributes:n,enableAttribute:o,disableUnusedAttributes:q}}function cM(a,b,c,d){const e=d.isWebGL2;let f;this.setMode=function(a){f=a},this.render=function(b,d){a.drawArrays(f,b,d),c.update(d,f,1)},this.renderInstances=function(d,g,h){if(0===h)return;let i,j;if(e)i=a,j="drawArraysInstanced";else if(j="drawArraysInstancedANGLE",null===(i=b.get("ANGLE_instanced_arrays"))){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}i[j](f,d,g,h),c.update(g,f,h)}}function dM(a,b,c){let d;function e(b){if("highp"===b){if(a.getShaderPrecisionFormat(35633,36338).precision>0&&a.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";b="mediump"}return"mediump"===b&&a.getShaderPrecisionFormat(35633,36337).precision>0&&a.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const f="undefined"!=typeof WebGL2RenderingContext&&a instanceof WebGL2RenderingContext||"undefined"!=typeof WebGL2ComputeRenderingContext&&a instanceof WebGL2ComputeRenderingContext;let g=void 0!==c.precision?c.precision:"highp";const h=e(g);h!==g&&(console.warn("THREE.WebGLRenderer:",g,"not supported, using",h,"instead."),g=h);const i=f||b.has("WEBGL_draw_buffers"),j=!0===c.logarithmicDepthBuffer,k=a.getParameter(34930),l=a.getParameter(35660),m=a.getParameter(3379),n=a.getParameter(34076),o=a.getParameter(34921),p=a.getParameter(36347),q=a.getParameter(36348),r=a.getParameter(36349),s=l>0,t=f||b.has("OES_texture_float"),u=f?a.getParameter(36183):0;return{isWebGL2:f,drawBuffers:i,getMaxAnisotropy:function(){if(void 0!==d)return d;if(!0===b.has("EXT_texture_filter_anisotropic")){const c=b.get("EXT_texture_filter_anisotropic");d=a.getParameter(c.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else d=0;return d},getMaxPrecision:e,precision:g,logarithmicDepthBuffer:j,maxTextures:k,maxVertexTextures:l,maxTextureSize:m,maxCubemapSize:n,maxAttributes:o,maxVertexUniforms:p,maxVaryings:q,maxFragmentUniforms:r,vertexTextures:s,floatFragmentTextures:t,floatVertexTextures:s&&t,maxSamples:u}}function eM(a){const b=this;let c=null,d=0,e=!1,f=!1;const g=new KJ(),h=new ub(),i={value:null,needsUpdate:!1};function j(){i.value!==c&&(i.value=c,i.needsUpdate=d>0),b.numPlanes=d,b.numIntersection=0}function k(a,c,d,e){const f=null!==a?a.length:0;let j=null;if(0!==f){if(j=i.value,!0!==e||null===j){const k=d+4*f,l=c.matrixWorldInverse;h.getNormalMatrix(l),(null===j||j.length<k)&&(j=new Float32Array(k));for(let m=0,n=d;m!==f;++m,n+=4)g.copy(a[m]).applyMatrix4(l,h),g.normal.toArray(j,n),j[n+3]=g.constant}i.value=j,i.needsUpdate=!0}return b.numPlanes=f,b.numIntersection=0,j}this.uniform=i,this.numPlanes=0,this.numIntersection=0,this.init=function(a,b,f){const g=0!==a.length||b||0!==d||e;return e=b,c=k(a,f,0),d=a.length,g},this.beginShadows=function(){f=!0,k(null)},this.endShadows=function(){f=!1,j()},this.setState=function(b,g,h){const l=b.clippingPlanes,m=b.clipIntersection,n=b.clipShadows,o=a.get(b);if(e&&null!==l&&0!==l.length&&(!f||n)){const p=f?0:d,q=4*p;let r=o.clippingState||null;i.value=r,r=k(l,g,q,h);for(let s=0;s!==q;++s)r[s]=c[s];o.clippingState=r,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=p}else f?k(null):j()}}function fM(a){let b=new WeakMap();function c(a,b){return 303===b?a.mapping=301:304===b&&(a.mapping=302),a}function d(a){const c=a.target;c.removeEventListener("dispose",d);const e=b.get(c);void 0!==e&&(b.delete(c),e.dispose())}return{get:function(e){if(e&&e.isTexture&& !1===e.isRenderTargetTexture){const f=e.mapping;if(303===f||304===f){if(b.has(e)){const g=b.get(e).texture;return c(g,e.mapping)}{const h=e.image;if(!h||!(h.height>0))return null;{const i=a.getRenderTarget(),j=new pJ(h.height/2);return j.fromEquirectangularTexture(a,e),b.set(e,j),a.setRenderTarget(i),e.addEventListener("dispose",d),c(j.texture,e.mapping)}}}}return e},dispose:function(){b=new WeakMap()}}}_L.physical={uniforms:QH([_L.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new da(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new oz(0)},sheenColorMap:{value:null},sheenRoughness:{value:0},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new da()},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new oz(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularColor:{value:new oz(1,1,1)},specularColorMap:{value:null}}]),vertexShader:ZL.meshphysical_vert,fragmentShader:ZL.meshphysical_frag};class gM extends aI{constructor(hM=-1,iM=1,jM=1,kM=-1,lM=0.1,mM=2000){super(),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=hM,this.right=iM,this.top=jM,this.bottom=kM,this.near=lM,this.far=mM,this.updateProjectionMatrix()}copy(nM,oM){return super.copy(nM,oM),this.left=nM.left,this.right=nM.right,this.top=nM.top,this.bottom=nM.bottom,this.near=nM.near,this.far=nM.far,this.zoom=nM.zoom,this.view=null===nM.view?null:Object.assign({},nM.view),this}setViewOffset(pM,qM,rM,sM,tM,uM){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=pM,this.view.fullHeight=qM,this.view.offsetX=rM,this.view.offsetY=sM,this.view.width=tM,this.view.height=uM,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const vM=(this.right-this.left)/(2*this.zoom),wM=(this.top-this.bottom)/(2*this.zoom),xM=(this.right+this.left)/2,yM=(this.top+this.bottom)/2;let zM=xM-vM,AM=xM+vM,BM=yM+wM,CM=yM-wM;if(null!==this.view&&this.view.enabled){const DM=(this.right-this.left)/this.view.fullWidth/this.zoom,EM=(this.top-this.bottom)/this.view.fullHeight/this.zoom;AM=(zM+=DM*this.view.offsetX)+DM*this.view.width,CM=(BM-=EM*this.view.offsetY)-EM*this.view.height}this.projectionMatrix.makeOrthographic(zM,AM,BM,CM,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(FM){const GM=super.toJSON(FM);return GM.object.zoom=this.zoom,GM.object.left=this.left,GM.object.right=this.right,GM.object.top=this.top,GM.object.bottom=this.bottom,GM.object.near=this.near,GM.object.far=this.far,null!==this.view&&(GM.object.view=Object.assign({},this.view)),GM}}gM.prototype.isOrthographicCamera=!0;class HM extends SH{constructor(IM){super(IM),this.type="RawShaderMaterial"}}HM.prototype.isRawShaderMaterial=!0;const JM=[0.125,0.215,0.35,0.446,0.526,0.582],KM=5+JM.length,LM={[3000]:0,[w]:1,[3002]:2,[3004]:3,[3005]:4,[3006]:5,[3007]:6},MM=new gM(),{_lodPlanes:NM,_sizeLods:OM,_sigmas:PM}=function(){const a=[],b=[],c=[];let d=8;for(let e=0;e<KM;e++){const f=Math.pow(2,d);b.push(f);let g=1/f;e>4?g=JM[e-8+4-1]:0==e&&(g=0),c.push(g);const h=1/(f-1),i=-h/2,j=1+h/2,k=[i,i,j,i,j,j,i,i,j,j,i,j],l=6,m=6,n=3,o=2,p=1,q=new Float32Array(n*m*l),r=new Float32Array(o*m*l),s=new Float32Array(p*m*l);for(let t=0;t<l;t++){const u=t%3*2/3-1,v=t>2?0:-1,w=[u,v,0,u+2/3,v,0,u+2/3,v+1,0,u,v,0,u+2/3,v+1,0,u,v+1,0];q.set(w,n*m*t),r.set(k,o*m*t);const x=[t,t,t,t,t,t];s.set(x,p*m*t)}const y=new HC();y.setAttribute("position",new OA(q,n)),y.setAttribute("uv",new OA(r,o)),y.setAttribute("faceIndex",new OA(s,p)),a.push(y),d>4&&d--}return{_lodPlanes:a,_sizeLods:b,_sigmas:c}}(),QM=new oz();let RM=null;const SM=(1+Math.sqrt(5))/2,TM=1/SM,UM=[new Qi(1,1,1),new Qi(-1,1,1),new Qi(1,1,-1),new Qi(-1,1,-1),new Qi(0,SM,TM),new Qi(0,SM,-TM),new Qi(TM,0,SM),new Qi(-TM,0,SM),new Qi(SM,TM,0),new Qi(-SM,TM,0)];class VM{constructor(WM){this._renderer=WM,this._pingPongRenderTarget=null,this._blurMaterial=(function(a){const b=new Float32Array(a),c=new Qi(0,1,0),d=new HM({name:"SphericalGaussianBlur",defines:{n:a},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:b},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:c},inputEncoding:{value:LM[3000]},outputEncoding:{value:LM[3000]}},vertexShader:wO(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${xO()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:0,depthTest:!1,depthWrite:!1});return d})(20),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(XM,YM=0,ZM=0.1,$M=100){RM=this._renderer.getRenderTarget();const _M=this._allocateTargets();return this._sceneToCubeUV(XM,ZM,$M,_M),YM>0&&this._blur(_M,0,0,YM),this._applyPMREM(_M),this._cleanup(_M),_M}fromEquirectangular(aN){return this._fromTexture(aN)}fromCubemap(bN){return this._fromTexture(bN)}compileCubemapShader(){null===this._cubemapShader&&(this._cubemapShader=vO(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){null===this._equirectShader&&(this._equirectShader=uO(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),null!==this._cubemapShader&&this._cubemapShader.dispose(),null!==this._equirectShader&&this._equirectShader.dispose();for(let cN=0;cN<NM.length;cN++)NM[cN].dispose()}_cleanup(dN){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(RM),dN.scissorTest=!1,tO(dN,0,0,dN.width,dN.height)}_fromTexture(eN){RM=this._renderer.getRenderTarget();const fN=this._allocateTargets(eN);return this._textureToCubeUV(eN,fN),this._applyPMREM(fN),this._cleanup(fN),fN}_allocateTargets(gN){const hN={magFilter:l,minFilter:l,generateMipmaps:!1,type:1009,format:1023,encoding:rO(gN)?gN.encoding:3002,depthBuffer:!1},iN=sO(hN);return iN.depthBuffer=!gN,this._pingPongRenderTarget=sO(hN),iN}_compileMaterial(jN){const kN=new qG(NM[0],jN);this._renderer.compile(kN,MM)}_sceneToCubeUV(lN,mN,nN,oN){const pN=new iI(90,1,mN,nN),qN=[1,-1,1,1,1,1],rN=[1,1,1,-1,-1,-1],sN=this._renderer,tN=sN.autoClear,uN=sN.outputEncoding,vN=sN.toneMapping;sN.getClearColor(QM),sN.toneMapping=0,sN.outputEncoding=3000,sN.autoClear=!1;const wN=new JA({name:"PMREM.Background",side:g,depthWrite:!1,depthTest:!1}),xN=new qG(new zH(),wN);let yN=!1;const zN=lN.background;zN?zN.isColor&&(wN.color.copy(zN),lN.background=null,yN=!0):(wN.color.copy(QM),yN=!0);for(let AN=0;AN<6;AN++){const BN=AN%3;0==BN?(pN.up.set(0,qN[AN],0),pN.lookAt(rN[AN],0,0)):1==BN?(pN.up.set(0,0,qN[AN]),pN.lookAt(0,rN[AN],0)):(pN.up.set(0,qN[AN],0),pN.lookAt(0,0,rN[AN])),tO(oN,256*BN,AN>2?256:0,256,256),sN.setRenderTarget(oN),yN&&sN.render(xN,pN),sN.render(lN,pN)}xN.geometry.dispose(),xN.material.dispose(),sN.toneMapping=vN,sN.outputEncoding=uN,sN.autoClear=tN,lN.background=zN}_setEncoding(CN,DN){!0===this._renderer.capabilities.isWebGL2&&1023===DN.format&&1009===DN.type&&DN.encoding===w?CN.value=LM[3000]:CN.value=LM[DN.encoding]}_textureToCubeUV(EN,FN){const GN=this._renderer,HN=301===EN.mapping||302===EN.mapping;HN?null==this._cubemapShader&&(this._cubemapShader=vO()):null==this._equirectShader&&(this._equirectShader=uO());const IN=HN?this._cubemapShader:this._equirectShader,JN=new qG(NM[0],IN),KN=IN.uniforms;KN.envMap.value=EN,HN||KN.texelSize.value.set(1/EN.image.width,1/EN.image.height),this._setEncoding(KN.inputEncoding,EN),this._setEncoding(KN.outputEncoding,FN.texture),tO(FN,0,0,768,512),GN.setRenderTarget(FN),GN.render(JN,MM)}_applyPMREM(LN){const MN=this._renderer,NN=MN.autoClear;MN.autoClear=!1;for(let ON=1;ON<KM;ON++){const PN=Math.sqrt(PM[ON]*PM[ON]-PM[ON-1]*PM[ON-1]),QN=UM[(ON-1)%UM.length];this._blur(LN,ON-1,ON,PN,QN)}MN.autoClear=NN}_blur(RN,SN,TN,UN,VN){const WN=this._pingPongRenderTarget;this._halfBlur(RN,WN,SN,TN,UN,"latitudinal",VN),this._halfBlur(WN,RN,TN,TN,UN,"longitudinal",VN)}_halfBlur(XN,YN,ZN,$N,_N,aO,bO){const cO=this._renderer,dO=this._blurMaterial;"latitudinal"!==aO&&"longitudinal"!==aO&&console.error("blur direction must be either latitudinal or longitudinal!");const eO=new qG(NM[$N],dO),fO=dO.uniforms,gO=OM[ZN]-1,hO=isFinite(_N)?Math.PI/(2*gO):2*Math.PI/39,iO=_N/hO,jO=isFinite(_N)?1+Math.floor(3*iO):20;jO>20&&console.warn(`sigmaRadians, ${_N}, is too large and will clip, as it requested ${jO} samples when the maximum is set to 20`);const kO=[];let lO=0;for(let mO=0;mO<20;++mO){const nO=mO/iO,oO=Math.exp(-nO*nO/2);kO.push(oO),0==mO?lO+=oO:mO<jO&&(lO+=2*oO)}for(let pO=0;pO<kO.length;pO++)kO[pO]=kO[pO]/lO;fO.envMap.value=XN.texture,fO.samples.value=jO,fO.weights.value=kO,fO.latitudinal.value="latitudinal"===aO,bO&&(fO.poleAxis.value=bO),fO.dTheta.value=hO,fO.mipInt.value=8-ZN,this._setEncoding(fO.inputEncoding,XN.texture),this._setEncoding(fO.outputEncoding,XN.texture);const qO=OM[$N];tO(YN,3*Math.max(0,256-2*qO),(0===$N?0:512)+2*qO*($N>4?$N-8+4:0),3*qO,2*qO),cO.setRenderTarget(YN),cO.render(eO,MM)}}function rO(a){return void 0!==a&&1009===a.type&&(3000===a.encoding||a.encoding===w||3007===a.encoding)}function sO(a){const b=new Kf(768,768,a);return b.texture.mapping=306,b.texture.name="PMREM.cubeUv",b.scissorTest=!0,b}function tO(a,b,c,d,e){a.viewport.set(b,c,d,e),a.scissor.set(b,c,d,e)}function uO(){const a=new da(1,1),b=new HM({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:a},inputEncoding:{value:LM[3000]},outputEncoding:{value:LM[3000]}},vertexShader:wO(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${xO()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:0,depthTest:!1,depthWrite:!1});return b}function vO(){const a=new HM({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:LM[3000]},outputEncoding:{value:LM[3000]}},vertexShader:wO(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${xO()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:0,depthTest:!1,depthWrite:!1});return a}function wO(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function xO(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function yO(a){let b=new WeakMap(),c=null;function d(a){const c=a.target;c.removeEventListener("dispose",d);const e=b.get(c);void 0!==e&&(b.delete(c),e.dispose())}return{get:function(e){if(e&&e.isTexture&& !1===e.isRenderTargetTexture){const f=e.mapping,g=303===f||304===f,h=301===f||302===f;if(g||h){if(b.has(e))return b.get(e).texture;{const i=e.image;if(!(g&&i&&i.height>0||h&&i&&function(a){let b=0;for(let c=0;c<6;c++)void 0!==a[c]&&b++;return 6===b}(i)))return null;{const j=a.getRenderTarget();null===c&&(c=new VM(a));const k=g?c.fromEquirectangular(e):c.fromCubemap(e);return b.set(e,k),a.setRenderTarget(j),e.addEventListener("dispose",d),k.texture}}}}return e},dispose:function(){b=new WeakMap(),null!==c&&(c.dispose(),c=null)}}}function zO(a){const b={};function c(c){if(void 0!==b[c])return b[c];let d;switch(c){case"WEBGL_depth_texture":d=a.getExtension("WEBGL_depth_texture")||a.getExtension("MOZ_WEBGL_depth_texture")||a.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":d=a.getExtension("EXT_texture_filter_anisotropic")||a.getExtension("MOZ_EXT_texture_filter_anisotropic")||a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":d=a.getExtension("WEBGL_compressed_texture_s3tc")||a.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":d=a.getExtension("WEBGL_compressed_texture_pvrtc")||a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:d=a.getExtension(c)}return b[c]=d,d}return{has:function(a){return null!==c(a)},init:function(a){a.isWebGL2?c("EXT_color_buffer_float"):(c("WEBGL_depth_texture"),c("OES_texture_float"),c("OES_texture_half_float"),c("OES_texture_half_float_linear"),c("OES_standard_derivatives"),c("OES_element_index_uint"),c("OES_vertex_array_object"),c("ANGLE_instanced_arrays")),c("OES_texture_float_linear"),c("EXT_color_buffer_half_float")},get:function(a){const b=c(a);return null===b&&console.warn("THREE.WebGLRenderer: "+a+" extension not supported."),b}}}function AO(a,b,c,d){const e={},f=new WeakMap();function g(a){const h=a.target;for(const i in null!==h.index&&b.remove(h.index),h.attributes)b.remove(h.attributes[i]);h.removeEventListener("dispose",g),delete e[h.id];const j=f.get(h);j&&(b.remove(j),f.delete(h)),d.releaseStatesOfGeometry(h),!0===h.isInstancedBufferGeometry&&delete h._maxInstanceCount,c.memory.geometries--}function h(a){const c=[],d=a.index,e=a.attributes.position;let g=0;if(null!==d){const h=d.array;g=d.version;for(let i=0,j=h.length;i<j;i+=3){const k=h[i+0],l=h[i+1],m=h[i+2];c.push(k,l,l,m,m,k)}}else{const n=e.array;g=e.version;for(let o=0,p=n.length/3-1;o<p;o+=3){const q=o+0,r=o+1,s=o+2;c.push(q,r,r,s,s,q)}}const t=new(xd(c)>65535?pC:lC)(c,1);t.version=g;const u=f.get(a);u&&b.remove(u),f.set(a,t)}return{get:function(a,b){return!0===e[b.id]||(b.addEventListener("dispose",g),e[b.id]=!0,c.memory.geometries++),b},update:function(a){const c=a.attributes;for(const d in c)b.update(c[d],34962);const e=a.morphAttributes;for(const f in e){const g=e[f];for(let h=0,i=g.length;h<i;h++)b.update(g[h],34962)}},getWireframeAttribute:function(a){const b=f.get(a);if(b){const c=a.index;null!==c&&b.version<c.version&&h(a)}else h(a);return f.get(a)}}}function BO(a,b,c,d){const e=d.isWebGL2;let f,g,h;this.setMode=function(a){f=a},this.setIndex=function(a){g=a.type,h=a.bytesPerElement},this.render=function(b,d){a.drawElements(f,d,g,b*h),c.update(d,f,1)},this.renderInstances=function(d,i,j){if(0===j)return;let k,l;if(e)k=a,l="drawElementsInstanced";else if(l="drawElementsInstancedANGLE",null===(k=b.get("ANGLE_instanced_arrays"))){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}k[l](f,i,g,d*h,j),c.update(i,f,j)}}function CO(a){const b={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render:b,programs:null,autoReset:!0,reset:function(){b.frame++,b.calls=0,b.triangles=0,b.points=0,b.lines=0},update:function(a,c,d){switch(b.calls++,c){case 4:b.triangles+=d*(a/3);break;case 1:b.lines+=d*(a/2);break;case 3:b.lines+=d*(a-1);break;case 2:b.lines+=d*a;break;case 0:b.points+=d*a;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",c);break}}}}class DO extends Gd{constructor(EO=null,FO=1,GO=1,HO=1){super(null),this.image={data:EO,width:FO,height:GO,depth:HO},this.magFilter=l,this.minFilter=l,this.wrapR=j,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}function IO(a,b){return a[0]-b[0]}function JO(a,b){return Math.abs(b[1])-Math.abs(a[1])}function KO(a,b){let c=1;const d=b.isInterleavedBufferAttribute?b.data.array:b.array;d instanceof Int8Array?c=127:d instanceof Int16Array?c=32767:d instanceof Int32Array?c=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",d),a.divideScalar(c)}function LO(a,b,c){const d={},e=new Float32Array(8),f=new WeakMap(),g=new Qi(),h=[];for(let i=0;i<8;i++)h[i]=[i,0];return{update:function(i,j,k,l){const m=i.morphTargetInfluences;if(!0===b.isWebGL2){const n=j.morphAttributes.position.length;let o=f.get(j);if(void 0===o||o.count!==n){void 0!==o&&o.texture.dispose();const p=void 0!==j.morphAttributes.normal,q=j.morphAttributes.position,r=j.morphAttributes.normal||[],s=j.attributes.position.count,t=!0===p?2:1;let u=s*t,v=1;u>b.maxTextureSize&&(v=Math.ceil(u/b.maxTextureSize),u=b.maxTextureSize);const w=new Float32Array(u*v*4*n),x=new DO(w,u,v,n);x.format=1023,x.type=1015;const y=4*t;for(let z=0;z<n;z++){const A=q[z],B=r[z],C=u*v*4*z;for(let D=0;D<A.count;D++){g.fromBufferAttribute(A,D),!0===A.normalized&&KO(g,A);const E=D*y;w[C+E+0]=g.x,w[C+E+1]=g.y,w[C+E+2]=g.z,w[C+E+3]=0,!0===p&&(g.fromBufferAttribute(B,D),!0===B.normalized&&KO(g,B),w[C+E+4]=g.x,w[C+E+5]=g.y,w[C+E+6]=g.z,w[C+E+7]=0)}}o={count:n,texture:x,size:new da(u,v)},f.set(j,o)}let F=0;for(let G=0;G<m.length;G++)F+=m[G];const H=j.morphTargetsRelative?1:1-F;l.getUniforms().setValue(a,"morphTargetBaseInfluence",H),l.getUniforms().setValue(a,"morphTargetInfluences",m),l.getUniforms().setValue(a,"morphTargetsTexture",o.texture,c),l.getUniforms().setValue(a,"morphTargetsTextureSize",o.size)}else{const I=void 0===m?0:m.length;let J=d[j.id];if(void 0===J||J.length!==I){J=[];for(let K=0;K<I;K++)J[K]=[K,0];d[j.id]=J}for(let L=0;L<I;L++){const M=J[L];M[0]=L,M[1]=m[L]}J.sort(JO);for(let N=0;N<8;N++)N<I&&J[N][1]?(h[N][0]=J[N][0],h[N][1]=J[N][1]):(h[N][0]=Number.MAX_SAFE_INTEGER,h[N][1]=0);h.sort(IO);const O=j.morphAttributes.position,P=j.morphAttributes.normal;let Q=0;for(let R=0;R<8;R++){const S=h[R],T=S[0],U=S[1];T!==Number.MAX_SAFE_INTEGER&&U?(O&&j.getAttribute("morphTarget"+R)!==O[T]&&j.setAttribute("morphTarget"+R,O[T]),P&&j.getAttribute("morphNormal"+R)!==P[T]&&j.setAttribute("morphNormal"+R,P[T]),e[R]=U,Q+=U):(O&& !0===j.hasAttribute("morphTarget"+R)&&j.deleteAttribute("morphTarget"+R),P&& !0===j.hasAttribute("morphNormal"+R)&&j.deleteAttribute("morphNormal"+R),e[R]=0)}const V=j.morphTargetsRelative?1:1-Q;l.getUniforms().setValue(a,"morphTargetBaseInfluence",V),l.getUniforms().setValue(a,"morphTargetInfluences",e)}}}}function MO(a,b,c,d){let e=new WeakMap();function f(a){const b=a.target;b.removeEventListener("dispose",f),c.remove(b.instanceMatrix),null!==b.instanceColor&&c.remove(b.instanceColor)}return{update:function(a){const g=d.render.frame,h=a.geometry,i=b.get(a,h);return e.get(i)!==g&&(b.update(i),e.set(i,g)),a.isInstancedMesh&&(!1===a.hasEventListener("dispose",f)&&a.addEventListener("dispose",f),c.update(a.instanceMatrix,34962),null!==a.instanceColor&&c.update(a.instanceColor,34962)),i},dispose:function(){e=new WeakMap()}}}DO.prototype.isDataTexture2DArray=!0;class NO extends Gd{constructor(OO=null,PO=1,QO=1,RO=1){super(null),this.image={data:OO,width:PO,height:QO,depth:RO},this.magFilter=l,this.minFilter=l,this.wrapR=j,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}NO.prototype.isDataTexture3D=!0;const SO=new Gd(),TO=new DO(),UO=new NO(),VO=new dJ(),WO=[],XO=[],YO=new Float32Array(16),ZO=new Float32Array(9),$O=new Float32Array(4);function _O(a,b,c){const d=a[0];if(d<=0||d>0)return a;const e=b*c;let f=WO[e];if(void 0===f&&(f=new Float32Array(e),WO[e]=f),0!==b){d.toArray(f,0);for(let g=1,h=0;g!==b;++g)h+=c,a[g].toArray(f,h)}return f}function aP(a,b){if(a.length!==b.length)return!1;for(let c=0,d=a.length;c<d;c++)if(a[c]!==b[c])return!1;return!0}function bP(a,b){for(let c=0,d=b.length;c<d;c++)a[c]=b[c]}function cP(a,b){let c=XO[b];void 0===c&&(c=new Int32Array(b),XO[b]=c);for(let d=0;d!==b;++d)c[d]=a.allocateTextureUnit();return c}function dP(a,b){const c=this.cache;c[0]!==b&&(a.uniform1f(this.addr,b),c[0]=b)}function eP(a,b){const c=this.cache;if(void 0!==b.x)(c[0]!==b.x||c[1]!==b.y)&&(a.uniform2f(this.addr,b.x,b.y),c[0]=b.x,c[1]=b.y);else{if(aP(c,b))return;a.uniform2fv(this.addr,b),bP(c,b)}}function fP(a,b){const c=this.cache;if(void 0!==b.x)(c[0]!==b.x||c[1]!==b.y||c[2]!==b.z)&&(a.uniform3f(this.addr,b.x,b.y,b.z),c[0]=b.x,c[1]=b.y,c[2]=b.z);else if(void 0!==b.r)(c[0]!==b.r||c[1]!==b.g||c[2]!==b.b)&&(a.uniform3f(this.addr,b.r,b.g,b.b),c[0]=b.r,c[1]=b.g,c[2]=b.b);else{if(aP(c,b))return;a.uniform3fv(this.addr,b),bP(c,b)}}function gP(a,b){const c=this.cache;if(void 0!==b.x)(c[0]!==b.x||c[1]!==b.y||c[2]!==b.z||c[3]!==b.w)&&(a.uniform4f(this.addr,b.x,b.y,b.z,b.w),c[0]=b.x,c[1]=b.y,c[2]=b.z,c[3]=b.w);else{if(aP(c,b))return;a.uniform4fv(this.addr,b),bP(c,b)}}function hP(a,b){const c=this.cache,d=b.elements;if(void 0===d){if(aP(c,b))return;a.uniformMatrix2fv(this.addr,!1,b),bP(c,b)}else{if(aP(c,d))return;$O.set(d),a.uniformMatrix2fv(this.addr,!1,$O),bP(c,d)}}function iP(a,b){const c=this.cache,d=b.elements;if(void 0===d){if(aP(c,b))return;a.uniformMatrix3fv(this.addr,!1,b),bP(c,b)}else{if(aP(c,d))return;ZO.set(d),a.uniformMatrix3fv(this.addr,!1,ZO),bP(c,d)}}function jP(a,b){const c=this.cache,d=b.elements;if(void 0===d){if(aP(c,b))return;a.uniformMatrix4fv(this.addr,!1,b),bP(c,b)}else{if(aP(c,d))return;YO.set(d),a.uniformMatrix4fv(this.addr,!1,YO),bP(c,d)}}function kP(a,b){const c=this.cache;c[0]!==b&&(a.uniform1i(this.addr,b),c[0]=b)}function lP(a,b){const c=this.cache;aP(c,b)||(a.uniform2iv(this.addr,b),bP(c,b))}function mP(a,b){const c=this.cache;aP(c,b)||(a.uniform3iv(this.addr,b),bP(c,b))}function nP(a,b){const c=this.cache;aP(c,b)||(a.uniform4iv(this.addr,b),bP(c,b))}function oP(a,b){const c=this.cache;c[0]!==b&&(a.uniform1ui(this.addr,b),c[0]=b)}function pP(a,b){const c=this.cache;aP(c,b)||(a.uniform2uiv(this.addr,b),bP(c,b))}function qP(a,b){const c=this.cache;aP(c,b)||(a.uniform3uiv(this.addr,b),bP(c,b))}function rP(a,b){const c=this.cache;aP(c,b)||(a.uniform4uiv(this.addr,b),bP(c,b))}function sP(a,b,c){const d=this.cache,e=c.allocateTextureUnit();d[0]!==e&&(a.uniform1i(this.addr,e),d[0]=e),c.safeSetTexture2D(b||SO,e)}function tP(a,b,c){const d=this.cache,e=c.allocateTextureUnit();d[0]!==e&&(a.uniform1i(this.addr,e),d[0]=e),c.setTexture3D(b||UO,e)}function uP(a,b,c){const d=this.cache,e=c.allocateTextureUnit();d[0]!==e&&(a.uniform1i(this.addr,e),d[0]=e),c.safeSetTextureCube(b||VO,e)}function vP(a,b,c){const d=this.cache,e=c.allocateTextureUnit();d[0]!==e&&(a.uniform1i(this.addr,e),d[0]=e),c.setTexture2DArray(b||TO,e)}function wP(a,b){a.uniform1fv(this.addr,b)}function xP(a,b){const c=_O(b,this.size,2);a.uniform2fv(this.addr,c)}function yP(a,b){const c=_O(b,this.size,3);a.uniform3fv(this.addr,c)}function zP(a,b){const c=_O(b,this.size,4);a.uniform4fv(this.addr,c)}function AP(a,b){const c=_O(b,this.size,4);a.uniformMatrix2fv(this.addr,!1,c)}function BP(a,b){const c=_O(b,this.size,9);a.uniformMatrix3fv(this.addr,!1,c)}function CP(a,b){const c=_O(b,this.size,16);a.uniformMatrix4fv(this.addr,!1,c)}function DP(a,b){a.uniform1iv(this.addr,b)}function EP(a,b){a.uniform2iv(this.addr,b)}function FP(a,b){a.uniform3iv(this.addr,b)}function GP(a,b){a.uniform4iv(this.addr,b)}function HP(a,b){a.uniform1uiv(this.addr,b)}function IP(a,b){a.uniform2uiv(this.addr,b)}function JP(a,b){a.uniform3uiv(this.addr,b)}function KP(a,b){a.uniform4uiv(this.addr,b)}function LP(a,b,c){const d=b.length,e=cP(c,d);a.uniform1iv(this.addr,e);for(let f=0;f!==d;++f)c.safeSetTexture2D(b[f]||SO,e[f])}function MP(a,b,c){const d=b.length,e=cP(c,d);a.uniform1iv(this.addr,e);for(let f=0;f!==d;++f)c.safeSetTextureCube(b[f]||VO,e[f])}function NP(a,b,c){this.id=a,this.addr=c,this.cache=[],this.setValue=(function(a){switch(a){case 5126:return dP;case 35664:return eP;case 35665:return fP;case 35666:return gP;case 35674:return hP;case 35675:return iP;case 35676:return jP;case 5124:case 35670:return kP;case 35667:case 35671:return lP;case 35668:case 35672:return mP;case 35669:case 35673:return nP;case 5125:return oP;case 36294:return pP;case 36295:return qP;case 36296:return rP;case 35678:case 36198:case 36298:case 36306:case 35682:return sP;case 35679:case 36299:case 36307:return tP;case 35680:case 36300:case 36308:case 36293:return uP;case 36289:case 36303:case 36311:case 36292:return vP}})(b.type)}function OP(a,b,c){this.id=a,this.addr=c,this.cache=[],this.size=b.size,this.setValue=(function(a){switch(a){case 5126:return wP;case 35664:return xP;case 35665:return yP;case 35666:return zP;case 35674:return AP;case 35675:return BP;case 35676:return CP;case 5124:case 35670:return DP;case 35667:case 35671:return EP;case 35668:case 35672:return FP;case 35669:case 35673:return GP;case 5125:return HP;case 36294:return IP;case 36295:return JP;case 36296:return KP;case 35678:case 36198:case 36298:case 36306:case 35682:return LP;case 35680:case 36300:case 36308:case 36293:return MP}})(b.type)}function PP(a){this.id=a,this.seq=[],this.map={}}OP.prototype.updateCache=function(a){const b=this.cache;a instanceof Float32Array&&b.length!==a.length&&(this.cache=new Float32Array(a.length)),bP(b,a)},PP.prototype.setValue=function(a,b,c){const d=this.seq;for(let e=0,f=d.length;e!==f;++e){const g=d[e];g.setValue(a,b[g.id],c)}};const QP=/(\w+)(\])?(\[|\.)?/g;function RP(a,b){a.seq.push(b),a.map[b.id]=b}function SP(a,b,c){const d=a.name,e=d.length;for(QP.lastIndex=0;;){const f=QP.exec(d),g=QP.lastIndex;let h=f[1];const i="]"===f[2],j=f[3];if(i&&(h|=0),void 0===j||"["===j&&g+2===e){RP(c,void 0===j?new NP(h,a,b):new OP(h,a,b));break}{const k=c.map;let l=k[h];void 0===l&&RP(c,l=new PP(h)),c=l}}}function TP(a,b){this.seq=[],this.map={};const c=a.getProgramParameter(b,35718);for(let d=0;d<c;++d){const e=a.getActiveUniform(b,d),f=a.getUniformLocation(b,e.name);SP(e,f,this)}}function UP(a,b,c){const d=a.createShader(b);return a.shaderSource(d,c),a.compileShader(d),d}TP.prototype.setValue=function(a,b,c,d){const e=this.map[b];void 0!==e&&e.setValue(a,c,d)},TP.prototype.setOptional=function(a,b,c){const d=b[c];void 0!==d&&this.setValue(a,c,d)},TP.upload=function(a,b,c,d){for(let e=0,f=b.length;e!==f;++e){const g=b[e],h=c[g.id];!1!==h.needsUpdate&&g.setValue(a,h.value,d)}},TP.seqWithValue=function(a,b){const c=[];for(let d=0,e=a.length;d!==e;++d){const f=a[d];f.id in b&&c.push(f)}return c};let VP=0;function WP(a){switch(a){case 3000:return["Linear","( value )"];case w:return["sRGB","( value )"];case 3002:return["RGBE","( value )"];case 3004:return["RGBM","( value, 7.0 )"];case 3005:return["RGBM","( value, 16.0 )"];case 3006:return["RGBD","( value, 256.0 )"];case 3007:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case 3003:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",a),["Linear","( value )"]}}function XP(a,b,c){const d=a.getShaderParameter(b,35713),e=a.getShaderInfoLog(b).trim();return d&&""===e?"":c.toUpperCase()+"\n\n"+e+"\n\n"+(function(a){const b=a.split("\n");for(let c=0;c<b.length;c++)b[c]=c+1+": "+b[c];return b.join("\n")})(a.getShaderSource(b))}function YP(a,b){const c=WP(b);return"vec4 "+a+"( vec4 value ) { return "+c[0]+"ToLinear"+c[1]+"; }"}function ZP(a){return""!==a}function $P(a,b){return a.replace(/NUM_DIR_LIGHTS/g,b.numDirLights).replace(/NUM_SPOT_LIGHTS/g,b.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,b.numPointLights).replace(/NUM_HEMI_LIGHTS/g,b.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,b.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,b.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,b.numPointLightShadows)}function _P(a,b){return a.replace(/NUM_CLIPPING_PLANES/g,b.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,b.numClippingPlanes-b.numClipIntersection)}const aQ=/^[ \t]*#include +<([\w\d./]+)>/gm;function bQ(a){return a.replace(aQ,cQ)}function cQ(a,b){const c=ZL[b];if(void 0===c)throw new Error("Can not resolve #include <"+b+">");return bQ(c)}const dQ=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,eQ=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function fQ(a){return a.replace(eQ,hQ).replace(dQ,gQ)}function gQ(a,b,c,d){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),hQ(a,b,c,d)}function hQ(a,b,c,d){let e="";for(let f=parseInt(b);f<parseInt(c);f++)e+=d.replace(/\[\s*i\s*\]/g,"[ "+f+" ]").replace(/UNROLLED_LOOP_INDEX/g,f);return e}function iQ(a){let b="precision "+a.precision+" float;\nprecision "+a.precision+" int;";return"highp"===a.precision?b+="\n#define HIGH_PRECISION":"mediump"===a.precision?b+="\n#define MEDIUM_PRECISION":"lowp"===a.precision&&(b+="\n#define LOW_PRECISION"),b}function jQ(a,b,c,d){var e;const f=a.getContext(),g=c.defines;let h=c.vertexShader,i=c.fragmentShader,j;const k=(j="SHADOWMAP_TYPE_BASIC",1===(e=c).shadowMapType?j="SHADOWMAP_TYPE_PCF":2===e.shadowMapType?j="SHADOWMAP_TYPE_PCF_SOFT":3===e.shadowMapType&&(j="SHADOWMAP_TYPE_VSM"),j),l=function(a){let b="ENVMAP_TYPE_CUBE";if(a.envMap)switch(a.envMapMode){case 301:case 302:b="ENVMAP_TYPE_CUBE";break;case 306:case 307:b="ENVMAP_TYPE_CUBE_UV";break}return b}(c),m=function(a){let b="ENVMAP_MODE_REFLECTION";if(a.envMap)switch(a.envMapMode){case 302:case 307:b="ENVMAP_MODE_REFRACTION";break}return b}(c),n=function(a){let b="ENVMAP_BLENDING_NONE";if(a.envMap)switch(a.combine){case 0:b="ENVMAP_BLENDING_MULTIPLY";break;case 1:b="ENVMAP_BLENDING_MIX";break;case 2:b="ENVMAP_BLENDING_ADD";break}return b}(c),o=a.gammaFactor>0?a.gammaFactor:1,p=c.isWebGL2?"":function(a){const b=[a.extensionDerivatives||a.envMapCubeUV||a.bumpMap||a.tangentSpaceNormalMap||a.clearcoatNormalMap||a.flatShading||"physical"===a.shaderID?"#extension GL_OES_standard_derivatives : enable":"",(a.extensionFragDepth||a.logarithmicDepthBuffer)&&a.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",a.extensionDrawBuffers&&a.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(a.extensionShaderTextureLOD||a.envMap||a.transmission)&&a.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""];return b.filter(ZP).join("\n")}(c),q=function(a){const b=[];for(const c in a){const d=a[c];!1!==d&&b.push("#define "+c+" "+d)}return b.join("\n")}(g),s=f.createProgram();let t,u,v=c.glslVersion?"#version "+c.glslVersion+"\n":"";c.isRawShaderMaterial?((t=[q].filter(ZP).join("\n")).length>0&&(t+="\n"),(u=[p,q].filter(ZP).join("\n")).length>0&&(u+="\n")):(t=[iQ(c),"#define SHADER_NAME "+c.shaderName,q,c.instancing?"#define USE_INSTANCING":"",c.instancingColor?"#define USE_INSTANCING_COLOR":"",c.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+o,"#define MAX_BONES "+c.maxBones,c.useFog&&c.fog?"#define USE_FOG":"",c.useFog&&c.fogExp2?"#define FOG_EXP2":"",c.map?"#define USE_MAP":"",c.envMap?"#define USE_ENVMAP":"",c.envMap?"#define "+m:"",c.lightMap?"#define USE_LIGHTMAP":"",c.aoMap?"#define USE_AOMAP":"",c.emissiveMap?"#define USE_EMISSIVEMAP":"",c.bumpMap?"#define USE_BUMPMAP":"",c.normalMap?"#define USE_NORMALMAP":"",c.normalMap&&c.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",c.normalMap&&c.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",c.clearcoatMap?"#define USE_CLEARCOATMAP":"",c.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",c.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",c.displacementMap&&c.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",c.specularMap?"#define USE_SPECULARMAP":"",c.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",c.specularColorMap?"#define USE_SPECULARCOLORMAP":"",c.roughnessMap?"#define USE_ROUGHNESSMAP":"",c.metalnessMap?"#define USE_METALNESSMAP":"",c.alphaMap?"#define USE_ALPHAMAP":"",c.transmission?"#define USE_TRANSMISSION":"",c.transmissionMap?"#define USE_TRANSMISSIONMAP":"",c.thicknessMap?"#define USE_THICKNESSMAP":"",c.sheenColorMap?"#define USE_SHEENCOLORMAP":"",c.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",c.vertexTangents?"#define USE_TANGENT":"",c.vertexColors?"#define USE_COLOR":"",c.vertexAlphas?"#define USE_COLOR_ALPHA":"",c.vertexUvs?"#define USE_UV":"",c.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",c.flatShading?"#define FLAT_SHADED":"",c.skinning?"#define USE_SKINNING":"",c.useVertexTexture?"#define BONE_TEXTURE":"",c.morphTargets?"#define USE_MORPHTARGETS":"",c.morphNormals&& !1===c.flatShading?"#define USE_MORPHNORMALS":"",c.morphTargets&&c.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",c.morphTargets&&c.isWebGL2?"#define MORPHTARGETS_COUNT "+c.morphTargetsCount:"",c.doubleSided?"#define DOUBLE_SIDED":"",c.flipSided?"#define FLIP_SIDED":"",c.shadowMapEnabled?"#define USE_SHADOWMAP":"",c.shadowMapEnabled?"#define "+k:"",c.sizeAttenuation?"#define USE_SIZEATTENUATION":"",c.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",c.logarithmicDepthBuffer&&c.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;","\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(ZP).join("\n"),u=[p,iQ(c),"#define SHADER_NAME "+c.shaderName,q,"#define GAMMA_FACTOR "+o,c.useFog&&c.fog?"#define USE_FOG":"",c.useFog&&c.fogExp2?"#define FOG_EXP2":"",c.map?"#define USE_MAP":"",c.matcap?"#define USE_MATCAP":"",c.envMap?"#define USE_ENVMAP":"",c.envMap?"#define "+l:"",c.envMap?"#define "+m:"",c.envMap?"#define "+n:"",c.lightMap?"#define USE_LIGHTMAP":"",c.aoMap?"#define USE_AOMAP":"",c.emissiveMap?"#define USE_EMISSIVEMAP":"",c.bumpMap?"#define USE_BUMPMAP":"",c.normalMap?"#define USE_NORMALMAP":"",c.normalMap&&c.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",c.normalMap&&c.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",c.clearcoat?"#define USE_CLEARCOAT":"",c.clearcoatMap?"#define USE_CLEARCOATMAP":"",c.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",c.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",c.specularMap?"#define USE_SPECULARMAP":"",c.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",c.specularColorMap?"#define USE_SPECULARCOLORMAP":"",c.roughnessMap?"#define USE_ROUGHNESSMAP":"",c.metalnessMap?"#define USE_METALNESSMAP":"",c.alphaMap?"#define USE_ALPHAMAP":"",c.alphaTest?"#define USE_ALPHATEST":"",c.sheen?"#define USE_SHEEN":"",c.sheenColorMap?"#define USE_SHEENCOLORMAP":"",c.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",c.transmission?"#define USE_TRANSMISSION":"",c.transmissionMap?"#define USE_TRANSMISSIONMAP":"",c.thicknessMap?"#define USE_THICKNESSMAP":"",c.vertexTangents?"#define USE_TANGENT":"",c.vertexColors||c.instancingColor?"#define USE_COLOR":"",c.vertexAlphas?"#define USE_COLOR_ALPHA":"",c.vertexUvs?"#define USE_UV":"",c.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",c.gradientMap?"#define USE_GRADIENTMAP":"",c.flatShading?"#define FLAT_SHADED":"",c.doubleSided?"#define DOUBLE_SIDED":"",c.flipSided?"#define FLIP_SIDED":"",c.shadowMapEnabled?"#define USE_SHADOWMAP":"",c.shadowMapEnabled?"#define "+k:"",c.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",c.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",c.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",c.logarithmicDepthBuffer&&c.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(c.extensionShaderTextureLOD||c.envMap)&&c.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==c.toneMapping?"#define TONE_MAPPING":"",0!==c.toneMapping?ZL.tonemapping_pars_fragment:"",0!==c.toneMapping?function(a,b){let c;switch(b){case 1:c="Linear";break;case 2:c="Reinhard";break;case 3:c="OptimizedCineon";break;case 4:c="ACESFilmic";break;case 5:c="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",b),c="Linear"}return"vec3 "+a+"( vec3 color ) { return "+c+"ToneMapping( color ); }"}("toneMapping",c.toneMapping):"",c.dithering?"#define DITHERING":"",c.format===r?"#define OPAQUE":"",ZL.encodings_pars_fragment,c.map?YP("mapTexelToLinear",c.mapEncoding):"",c.matcap?YP("matcapTexelToLinear",c.matcapEncoding):"",c.envMap?YP("envMapTexelToLinear",c.envMapEncoding):"",c.emissiveMap?YP("emissiveMapTexelToLinear",c.emissiveMapEncoding):"",c.specularColorMap?YP("specularColorMapTexelToLinear",c.specularColorMapEncoding):"",c.sheenColorMap?YP("sheenColorMapTexelToLinear",c.sheenColorMapEncoding):"",c.lightMap?YP("lightMapTexelToLinear",c.lightMapEncoding):"",function(a,b){const c=WP(b);return"vec4 "+a+"( vec4 value ) { return LinearTo"+c[0]+c[1]+"; }"}("linearToOutputTexel",c.outputEncoding),c.depthPacking?"#define DEPTH_PACKING "+c.depthPacking:"","\n"].filter(ZP).join("\n")),h=_P(h=$P(h=bQ(h),c),c),i=bQ(i),i=$P(i,c),i=_P(i,c),h=fQ(h),i=fQ(i),c.isWebGL2&& !0!==c.isRawShaderMaterial&&(v="#version 300 es\n",t="precision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\n"+t,u=["#define varying in",c.glslVersion===y?"":"out highp vec4 pc_fragColor;",c.glslVersion===y?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+u);const w=UP(f,35633,v+t+h),x=UP(f,35632,v+u+i);if(f.attachShader(s,w),f.attachShader(s,x),void 0!==c.index0AttributeName?f.bindAttribLocation(s,0,c.index0AttributeName):!0===c.morphTargets&&f.bindAttribLocation(s,0,"position"),f.linkProgram(s),a.debug.checkShaderErrors){const z=f.getProgramInfoLog(s).trim(),A=f.getShaderInfoLog(w).trim(),B=f.getShaderInfoLog(x).trim();let C=!0,D=!0;if(!1===f.getProgramParameter(s,35714)){C=!1;const E=XP(f,w,"vertex"),F=XP(f,x,"fragment");console.error("THREE.WebGLProgram: Shader Error "+f.getError()+" - VALIDATE_STATUS "+f.getProgramParameter(s,35715)+"\n\nProgram Info Log: "+z+"\n"+E+"\n"+F)}else""!==z?console.warn("THREE.WebGLProgram: Program Info Log:",z):(""===A||""===B)&&(D=!1);D&&(this.diagnostics={runnable:C,programLog:z,vertexShader:{log:A,prefix:t},fragmentShader:{log:B,prefix:u}})}f.deleteShader(w),f.deleteShader(x);let G;this.getUniforms=function(){return void 0===G&&(G=new TP(f,s)),G};let H;return this.getAttributes=function(){return void 0===H&&(H=(function(a,b){const c={},d=a.getProgramParameter(b,35721);for(let e=0;e<d;e++){const f=a.getActiveAttrib(b,e),g=f.name;let h=1;35674===f.type&&(h=2),35675===f.type&&(h=3),35676===f.type&&(h=4),c[g]={type:f.type,location:a.getAttribLocation(b,g),locationSize:h}}return c})(f,s)),H},this.destroy=function(){d.releaseStatesOfProgram(this),f.deleteProgram(s),this.program=void 0},this.name=c.shaderName,this.id=VP++,this.cacheKey=b,this.usedTimes=1,this.program=s,this.vertexShader=w,this.fragmentShader=x,this}function kQ(a,b,c,d,e,f,i){const j=[],k=e.isWebGL2,l=e.logarithmicDepthBuffer,m=e.floatVertexTextures,n=e.maxVertexUniforms,o=e.vertexTextures;let p=e.precision;const q={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},r=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap",,"roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","morphTargetsCount","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","specularIntensityMap","specularColorMap","specularColorMapEncoding","transmission","transmissionMap","thicknessMap","sheen","sheenColorMap","sheenColorMapEncoding","sheenRoughnessMap"];function s(a){let b;return a&&a.isTexture?b=a.encoding:a&&a.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),b=a.texture.encoding):b=3000,k&&a&&a.isTexture&&1023===a.format&&1009===a.type&&a.encoding===w&&(b=3000),b}return{getParameters:function(f,j,r,t,u){const v=t.fog,w=f.isMeshStandardMaterial?t.environment:null,y=(f.isMeshStandardMaterial?c:b).get(f.envMap||w),z=q[f.type],A=u.isSkinnedMesh?function(a){const b=a.skeleton,c=b.bones;if(m)return 1024;{const d=n,e=Math.floor((d-20)/4),f=Math.min(e,c.length);return f<c.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+c.length+" bones. This GPU supports "+f+"."),0):f}}(u):0;null!==f.precision&&(p=e.getMaxPrecision(f.precision))!==f.precision&&console.warn("THREE.WebGLProgram.getParameters:",f.precision,"not supported, using",p,"instead.");let B,C;if(z){const D=_L[z];B=D.vertexShader,C=D.fragmentShader}else B=f.vertexShader,C=f.fragmentShader;const E=a.getRenderTarget(),F=f.alphaTest>0,G=f.clearcoat>0,H={isWebGL2:k,shaderID:z,shaderName:f.type,vertexShader:B,fragmentShader:C,defines:f.defines,isRawShaderMaterial:!0===f.isRawShaderMaterial,glslVersion:f.glslVersion,precision:p,instancing:!0===u.isInstancedMesh,instancingColor:!0===u.isInstancedMesh&&null!==u.instanceColor,supportsVertexTextures:o,outputEncoding:null!==E?s(E.texture):a.outputEncoding,map:!!f.map,mapEncoding:s(f.map),matcap:!!f.matcap,matcapEncoding:s(f.matcap),envMap:!!y,envMapMode:y&&y.mapping,envMapEncoding:s(y),envMapCubeUV:!!y&&(306===y.mapping||307===y.mapping),lightMap:!!f.lightMap,lightMapEncoding:s(f.lightMap),aoMap:!!f.aoMap,emissiveMap:!!f.emissiveMap,emissiveMapEncoding:s(f.emissiveMap),bumpMap:!!f.bumpMap,normalMap:!!f.normalMap,objectSpaceNormalMap:1===f.normalMapType,tangentSpaceNormalMap:f.normalMapType===x,clearcoat:G,clearcoatMap:G&&!!f.clearcoatMap,clearcoatRoughnessMap:G&&!!f.clearcoatRoughnessMap,clearcoatNormalMap:G&&!!f.clearcoatNormalMap,displacementMap:!!f.displacementMap,roughnessMap:!!f.roughnessMap,metalnessMap:!!f.metalnessMap,specularMap:!!f.specularMap,specularIntensityMap:!!f.specularIntensityMap,specularColorMap:!!f.specularColorMap,specularColorMapEncoding:s(f.specularColorMap),alphaMap:!!f.alphaMap,alphaTest:F,gradientMap:!!f.gradientMap,sheen:f.sheen>0,sheenColorMap:!!f.sheenColorMap,sheenColorMapEncoding:s(f.sheenColorMap),sheenRoughnessMap:!!f.sheenRoughnessMap,transmission:f.transmission>0,transmissionMap:!!f.transmissionMap,thicknessMap:!!f.thicknessMap,combine:f.combine,vertexTangents:!!f.normalMap&&!!u.geometry&&!!u.geometry.attributes.tangent,vertexColors:f.vertexColors,vertexAlphas:!0===f.vertexColors&&!!u.geometry&&!!u.geometry.attributes.color&&4===u.geometry.attributes.color.itemSize,vertexUvs:!!f.map||!!f.bumpMap||!!f.normalMap||!!f.specularMap||!!f.alphaMap||!!f.emissiveMap||!!f.roughnessMap||!!f.metalnessMap||!!f.clearcoatMap||!!f.clearcoatRoughnessMap||!!f.clearcoatNormalMap||!!f.displacementMap||!!f.transmissionMap||!!f.thicknessMap||!!f.specularIntensityMap||!!f.specularColorMap||!!f.sheenColorMap||f.sheenRoughnessMap,uvsVertexOnly:!(f.map||f.bumpMap||f.normalMap||f.specularMap||f.alphaMap||f.emissiveMap||f.roughnessMap||f.metalnessMap||f.clearcoatNormalMap||f.transmission>0||f.transmissionMap||f.thicknessMap||f.specularIntensityMap||f.specularColorMap|| !!f.sheen>0||f.sheenColorMap||f.sheenRoughnessMap)&&!!f.displacementMap,fog:!!v,useFog:f.fog,fogExp2:v&&v.isFogExp2,flatShading:!!f.flatShading,sizeAttenuation:f.sizeAttenuation,logarithmicDepthBuffer:l,skinning:!0===u.isSkinnedMesh&&A>0,maxBones:A,useVertexTexture:m,morphTargets:!!u.geometry&&!!u.geometry.morphAttributes.position,morphNormals:!!u.geometry&&!!u.geometry.morphAttributes.normal,morphTargetsCount:u.geometry&&u.geometry.morphAttributes.position?u.geometry.morphAttributes.position.length:0,numDirLights:j.directional.length,numPointLights:j.point.length,numSpotLights:j.spot.length,numRectAreaLights:j.rectArea.length,numHemiLights:j.hemi.length,numDirLightShadows:j.directionalShadowMap.length,numPointLightShadows:j.pointShadowMap.length,numSpotLightShadows:j.spotShadowMap.length,numClippingPlanes:i.numPlanes,numClipIntersection:i.numIntersection,format:f.format,dithering:f.dithering,shadowMapEnabled:a.shadowMap.enabled&&r.length>0,shadowMapType:a.shadowMap.type,toneMapping:f.toneMapped?a.toneMapping:0,physicallyCorrectLights:a.physicallyCorrectLights,premultipliedAlpha:f.premultipliedAlpha,doubleSided:f.side===h,flipSided:f.side===g,depthPacking:void 0!==f.depthPacking&&f.depthPacking,index0AttributeName:f.index0AttributeName,extensionDerivatives:f.extensions&&f.extensions.derivatives,extensionFragDepth:f.extensions&&f.extensions.fragDepth,extensionDrawBuffers:f.extensions&&f.extensions.drawBuffers,extensionShaderTextureLOD:f.extensions&&f.extensions.shaderTextureLOD,rendererExtensionFragDepth:k||d.has("EXT_frag_depth"),rendererExtensionDrawBuffers:k||d.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:k||d.has("EXT_shader_texture_lod"),customProgramCacheKey:f.customProgramCacheKey()};return H},getProgramCacheKey:function(b){const c=[];if(b.shaderID?c.push(b.shaderID):(c.push(zd(b.fragmentShader)),c.push(zd(b.vertexShader))),void 0!==b.defines)for(const d in b.defines)c.push(d),c.push(b.defines[d]);if(!1===b.isRawShaderMaterial){for(let e=0;e<r.length;e++)c.push(b[r[e]]);c.push(a.outputEncoding),c.push(a.gammaFactor)}return c.push(b.customProgramCacheKey),c.join()},getUniforms:function(a){const b=q[a.type];let c;if(b){const d=_L[b];c=RH.clone(d.uniforms)}else c=a.uniforms;return c},acquireProgram:function(b,c){let d;for(let e=0,g=j.length;e<g;e++){const h=j[e];if(h.cacheKey===c){d=h,++d.usedTimes;break}}return void 0===d&&(d=new jQ(a,c,b,f),j.push(d)),d},releaseProgram:function(a){if(0== --a.usedTimes){const b=j.indexOf(a);j[b]=j[j.length-1],j.pop(),a.destroy()}},programs:j}}function lQ(){let a=new WeakMap();return{get:function(b){let c=a.get(b);return void 0===c&&(c={},a.set(b,c)),c},remove:function(b){a.delete(b)},update:function(b,c,d){a.get(b)[c]=d},dispose:function(){a=new WeakMap()}}}function mQ(a,b){return a.groupOrder!==b.groupOrder?a.groupOrder-b.groupOrder:a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.program!==b.program?a.program.id-b.program.id:a.material.id!==b.material.id?a.material.id-b.material.id:a.z!==b.z?a.z-b.z:a.id-b.id}function nQ(a,b){return a.groupOrder!==b.groupOrder?a.groupOrder-b.groupOrder:a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.z!==b.z?b.z-a.z:a.id-b.id}function oQ(a){const b=[];let c=0;const d=[],e=[],f=[],g={id:-1};function h(d,e,f,h,i,j){let k=b[c];const l=a.get(f);return void 0===k?(k={id:d.id,object:d,geometry:e,material:f,program:l.program||g,groupOrder:h,renderOrder:d.renderOrder,z:i,group:j},b[c]=k):(k.id=d.id,k.object=d,k.geometry=e,k.material=f,k.program=l.program||g,k.groupOrder=h,k.renderOrder=d.renderOrder,k.z=i,k.group=j),c++,k}return{opaque:d,transmissive:e,transparent:f,init:function(){c=0,d.length=0,e.length=0,f.length=0},push:function(a,b,c,g,i,j){const k=h(a,b,c,g,i,j);c.transmission>0?e.push(k):!0===c.transparent?f.push(k):d.push(k)},unshift:function(a,b,c,g,i,j){const k=h(a,b,c,g,i,j);c.transmission>0?e.unshift(k):!0===c.transparent?f.unshift(k):d.unshift(k)},finish:function(){for(let a=c,d=b.length;a<d;a++){const e=b[a];if(null===e.id)break;e.id=null,e.object=null,e.geometry=null,e.material=null,e.program=null,e.group=null}},sort:function(a,b){d.length>1&&d.sort(a||mQ),e.length>1&&e.sort(b||nQ),f.length>1&&f.sort(b||nQ)}}}function pQ(a){let b=new WeakMap();return{get:function(c,d){let e;return!1===b.has(c)?(e=new oQ(a),b.set(c,[e])):d>=b.get(c).length?(e=new oQ(a),b.get(c).push(e)):e=b.get(c)[d],e},dispose:function(){b=new WeakMap()}}}function qQ(){const a={};return{get:function(b){if(void 0!==a[b.id])return a[b.id];let c;switch(b.type){case"DirectionalLight":c={direction:new Qi(),color:new oz()};break;case"SpotLight":c={position:new Qi(),direction:new Qi(),color:new oz(),distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":c={position:new Qi(),color:new oz(),distance:0,decay:0};break;case"HemisphereLight":c={direction:new Qi(),skyColor:new oz(),groundColor:new oz()};break;case"RectAreaLight":c={color:new oz(),position:new Qi(),halfWidth:new Qi(),halfHeight:new Qi()};break}return a[b.id]=c,c}}}let rQ=0;function sQ(a,b){return(b.castShadow?1:0)-(a.castShadow?1:0)}function tQ(a,b){const c=new qQ(),d=function(){const a={};return{get:function(b){if(void 0!==a[b.id])return a[b.id];let c;switch(b.type){case"DirectionalLight":c={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new da()};break;case"SpotLight":c={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new da()};break;case"PointLight":c={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new da(),shadowCameraNear:1,shadowCameraFar:1000};break}return a[b.id]=c,c}}}(),e={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let f=0;f<9;f++)e.probe.push(new Qi());const g=new Qi(),h=new dp(),i=new dp();return{setup:function(f,g){let h=0,i=0,j=0;for(let k=0;k<9;k++)e.probe[k].set(0,0,0);let l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;f.sort(sQ);const t=!0!==g?Math.PI:1;for(let u=0,v=f.length;u<v;u++){const w=f[u],x=w.color,y=w.intensity,z=w.distance,A=w.shadow&&w.shadow.map?w.shadow.map.texture:null;if(w.isAmbientLight)h+=x.r*y*t,i+=x.g*y*t,j+=x.b*y*t;else if(w.isLightProbe)for(let B=0;B<9;B++)e.probe[B].addScaledVector(w.sh.coefficients[B],y);else if(w.isDirectionalLight){const C=c.get(w);if(C.color.copy(w.color).multiplyScalar(w.intensity*t),w.castShadow){const D=w.shadow,E=d.get(w);E.shadowBias=D.bias,E.shadowNormalBias=D.normalBias,E.shadowRadius=D.radius,E.shadowMapSize=D.mapSize,e.directionalShadow[l]=E,e.directionalShadowMap[l]=A,e.directionalShadowMatrix[l]=w.shadow.matrix,q++}e.directional[l]=C,l++}else if(w.isSpotLight){const F=c.get(w);if(F.position.setFromMatrixPosition(w.matrixWorld),F.color.copy(x).multiplyScalar(y*t),F.distance=z,F.coneCos=Math.cos(w.angle),F.penumbraCos=Math.cos(w.angle*(1-w.penumbra)),F.decay=w.decay,w.castShadow){const G=w.shadow,H=d.get(w);H.shadowBias=G.bias,H.shadowNormalBias=G.normalBias,H.shadowRadius=G.radius,H.shadowMapSize=G.mapSize,e.spotShadow[n]=H,e.spotShadowMap[n]=A,e.spotShadowMatrix[n]=w.shadow.matrix,s++}e.spot[n]=F,n++}else if(w.isRectAreaLight){const I=c.get(w);I.color.copy(x).multiplyScalar(y),I.halfWidth.set(0.5*w.width,0,0),I.halfHeight.set(0,0.5*w.height,0),e.rectArea[o]=I,o++}else if(w.isPointLight){const J=c.get(w);if(J.color.copy(w.color).multiplyScalar(w.intensity*t),J.distance=w.distance,J.decay=w.decay,w.castShadow){const K=w.shadow,L=d.get(w);L.shadowBias=K.bias,L.shadowNormalBias=K.normalBias,L.shadowRadius=K.radius,L.shadowMapSize=K.mapSize,L.shadowCameraNear=K.camera.near,L.shadowCameraFar=K.camera.far,e.pointShadow[m]=L,e.pointShadowMap[m]=A,e.pointShadowMatrix[m]=w.shadow.matrix,r++}e.point[m]=J,m++}else if(w.isHemisphereLight){const M=c.get(w);M.skyColor.copy(w.color).multiplyScalar(y*t),M.groundColor.copy(w.groundColor).multiplyScalar(y*t),e.hemi[p]=M,p++}}o>0&&(b.isWebGL2?(e.rectAreaLTC1=$L.LTC_FLOAT_1,e.rectAreaLTC2=$L.LTC_FLOAT_2):!0===a.has("OES_texture_float_linear")?(e.rectAreaLTC1=$L.LTC_FLOAT_1,e.rectAreaLTC2=$L.LTC_FLOAT_2):!0===a.has("OES_texture_half_float_linear")?(e.rectAreaLTC1=$L.LTC_HALF_1,e.rectAreaLTC2=$L.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),e.ambient[0]=h,e.ambient[1]=i,e.ambient[2]=j;const N=e.hash;(N.directionalLength!==l||N.pointLength!==m||N.spotLength!==n||N.rectAreaLength!==o||N.hemiLength!==p||N.numDirectionalShadows!==q||N.numPointShadows!==r||N.numSpotShadows!==s)&&(e.directional.length=l,e.spot.length=n,e.rectArea.length=o,e.point.length=m,e.hemi.length=p,e.directionalShadow.length=q,e.directionalShadowMap.length=q,e.pointShadow.length=r,e.pointShadowMap.length=r,e.spotShadow.length=s,e.spotShadowMap.length=s,e.directionalShadowMatrix.length=q,e.pointShadowMatrix.length=r,e.spotShadowMatrix.length=s,N.directionalLength=l,N.pointLength=m,N.spotLength=n,N.rectAreaLength=o,N.hemiLength=p,N.numDirectionalShadows=q,N.numPointShadows=r,N.numSpotShadows=s,e.version=rQ++)},setupView:function(a,b){let c=0,d=0,f=0,j=0,k=0;const l=b.matrixWorldInverse;for(let m=0,n=a.length;m<n;m++){const o=a[m];if(o.isDirectionalLight){const p=e.directional[c];p.direction.setFromMatrixPosition(o.matrixWorld),g.setFromMatrixPosition(o.target.matrixWorld),p.direction.sub(g),p.direction.transformDirection(l),c++}else if(o.isSpotLight){const q=e.spot[f];q.position.setFromMatrixPosition(o.matrixWorld),q.position.applyMatrix4(l),q.direction.setFromMatrixPosition(o.matrixWorld),g.setFromMatrixPosition(o.target.matrixWorld),q.direction.sub(g),q.direction.transformDirection(l),f++}else if(o.isRectAreaLight){const r=e.rectArea[j];r.position.setFromMatrixPosition(o.matrixWorld),r.position.applyMatrix4(l),i.identity(),h.copy(o.matrixWorld),h.premultiply(l),i.extractRotation(h),r.halfWidth.set(0.5*o.width,0,0),r.halfHeight.set(0,0.5*o.height,0),r.halfWidth.applyMatrix4(i),r.halfHeight.applyMatrix4(i),j++}else if(o.isPointLight){const s=e.point[d];s.position.setFromMatrixPosition(o.matrixWorld),s.position.applyMatrix4(l),d++}else if(o.isHemisphereLight){const t=e.hemi[k];t.direction.setFromMatrixPosition(o.matrixWorld),t.direction.transformDirection(l),t.direction.normalize(),k++}}},state:e}}function uQ(a,b){const c=new tQ(a,b),d=[],e=[];return{init:function(){d.length=0,e.length=0},state:{lightsArray:d,shadowsArray:e,lights:c},setupLights:function(a){c.setup(d,a)},setupLightsView:function(a){c.setupView(d,a)},pushLight:function(a){d.push(a)},pushShadow:function(a){e.push(a)}}}function vQ(a,b){let c=new WeakMap();return{get:function(d,e=0){let f;return!1===c.has(d)?(f=new uQ(a,b),c.set(d,[f])):e>=c.get(d).length?(f=new uQ(a,b),c.get(d).push(f)):f=c.get(d)[e],f},dispose:function(){c=new WeakMap()}}}class wQ extends Sy{constructor(xQ){super(),this.type="MeshDepthMaterial",this.depthPacking=3200,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(xQ)}copy(yQ){return super.copy(yQ),this.depthPacking=yQ.depthPacking,this.map=yQ.map,this.alphaMap=yQ.alphaMap,this.displacementMap=yQ.displacementMap,this.displacementScale=yQ.displacementScale,this.displacementBias=yQ.displacementBias,this.wireframe=yQ.wireframe,this.wireframeLinewidth=yQ.wireframeLinewidth,this}}wQ.prototype.isMeshDepthMaterial=!0;class zQ extends Sy{constructor(AQ){super(),this.type="MeshDistanceMaterial",this.referencePosition=new Qi(),this.nearDistance=1,this.farDistance=1000,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(AQ)}copy(BQ){return super.copy(BQ),this.referencePosition.copy(BQ.referencePosition),this.nearDistance=BQ.nearDistance,this.farDistance=BQ.farDistance,this.map=BQ.map,this.alphaMap=BQ.alphaMap,this.displacementMap=BQ.displacementMap,this.displacementScale=BQ.displacementScale,this.displacementBias=BQ.displacementBias,this}}function CQ(a,b,c){let d=new xK();const e=new da(),i=new da(),j=new ae(),k=new wQ({depthPacking:3201}),m=new zQ(),n={},p=c.maxTextureSize,q={0:g,1:f,2:h},r=new SH({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new da()},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),s=r.clone();s.defines.HORIZONTAL_PASS=1;const t=new HC();t.setAttribute("position",new OA(new Float32Array([-1,-1,0.5,3,-1,0.5,-1,3,0.5]),3));const u=new qG(t,r),v=this;function w(c,d){const e=b.update(u);r.defines.VSM_SAMPLES!==c.blurSamples&&(r.defines.VSM_SAMPLES=c.blurSamples,s.defines.VSM_SAMPLES=c.blurSamples,r.needsUpdate=!0,s.needsUpdate=!0),r.uniforms.shadow_pass.value=c.map.texture,r.uniforms.resolution.value=c.mapSize,r.uniforms.radius.value=c.radius,a.setRenderTarget(c.mapPass),a.clear(),a.renderBufferDirect(d,null,e,r,u,null),s.uniforms.shadow_pass.value=c.mapPass.texture,s.uniforms.resolution.value=c.mapSize,s.uniforms.radius.value=c.radius,a.setRenderTarget(c.map),a.clear(),a.renderBufferDirect(d,null,e,s,u,null)}function x(b,c,d,e,f,g,h){let i=null;const j=!0===e.isPointLight?b.customDistanceMaterial:b.customDepthMaterial;if(i=void 0!==j?j:!0===e.isPointLight?m:k,a.localClippingEnabled&& !0===d.clipShadows&&0!==d.clippingPlanes.length||d.displacementMap&&0!==d.displacementScale||d.alphaMap&&d.alphaTest>0){const l=i.uuid,o=d.uuid;let p=n[l];void 0===p&&(p={},n[l]=p);let r=p[o];void 0===r&&(r=i.clone(),p[o]=r),i=r}return i.visible=d.visible,i.wireframe=d.wireframe,3===h?i.side=null!==d.shadowSide?d.shadowSide:d.side:i.side=null!==d.shadowSide?d.shadowSide:q[d.side],i.alphaMap=d.alphaMap,i.alphaTest=d.alphaTest,i.clipShadows=d.clipShadows,i.clippingPlanes=d.clippingPlanes,i.clipIntersection=d.clipIntersection,i.displacementMap=d.displacementMap,i.displacementScale=d.displacementScale,i.displacementBias=d.displacementBias,i.wireframeLinewidth=d.wireframeLinewidth,i.linewidth=d.linewidth,!0===e.isPointLight&& !0===i.isMeshDistanceMaterial&&(i.referencePosition.setFromMatrixPosition(e.matrixWorld),i.nearDistance=f,i.farDistance=g),i}function y(c,e,f,g,h){if(!1===c.visible)return;const i=c.layers.test(e.layers);if(i&&(c.isMesh||c.isLine||c.isPoints)&&(c.castShadow||c.receiveShadow&&3===h)&&(!c.frustumCulled||d.intersectsObject(c))){c.modelViewMatrix.multiplyMatrices(f.matrixWorldInverse,c.matrixWorld);const j=b.update(c),k=c.material;if(Array.isArray(k)){const l=j.groups;for(let m=0,n=l.length;m<n;m++){const o=l[m],p=k[o.materialIndex];if(p&&p.visible){const q=x(c,j,p,g,f.near,f.far,h);a.renderBufferDirect(f,null,j,q,c,o)}}}else if(k.visible){const r=x(c,j,k,g,f.near,f.far,h);a.renderBufferDirect(f,null,j,r,c,null)}}const s=c.children;for(let t=0,u=s.length;t<u;t++)y(s[t],e,f,g,h)}this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=1,this.render=function(b,c,f){if(!1===v.enabled)return;if(!1===v.autoUpdate&& !1===v.needsUpdate)return;if(0===b.length)return;const g=a.getRenderTarget(),h=a.getActiveCubeFace(),k=a.getActiveMipmapLevel(),m=a.state;m.setBlending(0),m.buffers.color.setClear(1,1,1,1),m.buffers.depth.setTest(!0),m.setScissorTest(!1);for(let n=0,q=b.length;n<q;n++){const r=b[n],s=r.shadow;if(void 0===s){console.warn("THREE.WebGLShadowMap:",r,"has no shadow.");continue}if(!1===s.autoUpdate&& !1===s.needsUpdate)continue;e.copy(s.mapSize);const t=s.getFrameExtents();if(e.multiply(t),i.copy(s.mapSize),(e.x>p||e.y>p)&&(e.x>p&&(i.x=Math.floor(p/t.x),e.x=i.x*t.x,s.mapSize.x=i.x),e.y>p&&(i.y=Math.floor(p/t.y),e.y=i.y*t.y,s.mapSize.y=i.y)),null===s.map&&!s.isPointLightShadow&&3===this.type){const u={minFilter:o,magFilter:o,format:1023};s.map=new Kf(e.x,e.y,u),s.map.texture.name=r.name+".shadowMap",s.mapPass=new Kf(e.x,e.y,u),s.camera.updateProjectionMatrix()}if(null===s.map){const x={minFilter:l,magFilter:l,format:1023};s.map=new Kf(e.x,e.y,x),s.map.texture.name=r.name+".shadowMap",s.camera.updateProjectionMatrix()}a.setRenderTarget(s.map),a.clear();const z=s.getViewportCount();for(let A=0;A<z;A++){const B=s.getViewport(A);j.set(i.x*B.x,i.y*B.y,i.x*B.z,i.y*B.w),m.viewport(j),s.updateMatrices(r,A),d=s.getFrustum(),y(c,f,s.camera,r,this.type)}s.isPointLightShadow||3!==this.type||w(s,f),s.needsUpdate=!1}v.needsUpdate=!1,a.setRenderTarget(g,h,k)}}function DQ(a,b,c){const d=c.isWebGL2,e=new function(){let b=!1;const c=new ae();let d=null;const e=new ae(0,0,0,0);return{setMask:function(c){d===c||b||(a.colorMask(c,c,c,c),d=c)},setLocked:function(a){b=a},setClear:function(b,d,f,g,h){!0===h&&(b*=g,d*=g,f*=g),c.set(b,d,f,g),!1===e.equals(c)&&(a.clearColor(b,d,f,g),e.copy(c))},reset:function(){b=!1,d=null,e.set(-1,0,0,0)}}}(),f=new function(){let b=!1,c=null,d=null,e=null;return{setTest:function(a){a?M(2929):N(2929)},setMask:function(d){c===d||b||(a.depthMask(d),c=d)},setFunc:function(b){if(d!==b){if(b)switch(b){case 0:a.depthFunc(512);break;case 1:a.depthFunc(519);break;case 2:a.depthFunc(513);break;case 3:a.depthFunc(515);break;case 4:a.depthFunc(514);break;case 5:a.depthFunc(518);break;case 6:a.depthFunc(516);break;case 7:a.depthFunc(517);break;default:a.depthFunc(515)}else a.depthFunc(515);d=b}},setLocked:function(a){b=a},setClear:function(b){e!==b&&(a.clearDepth(b),e=b)},reset:function(){b=!1,c=null,d=null,e=null}}}(),i=new function(){let b=!1,c=null,d=null,e=null,f=null,g=null,h=null,i=null,j=null;return{setTest:function(a){b||(a?M(2960):N(2960))},setMask:function(d){c===d||b||(a.stencilMask(d),c=d)},setFunc:function(b,c,g){(d!==b||e!==c||f!==g)&&(a.stencilFunc(b,c,g),d=b,e=c,f=g)},setOp:function(b,c,d){(g!==b||h!==c||i!==d)&&(a.stencilOp(b,c,d),g=b,h=c,i=d)},setLocked:function(a){b=a},setClear:function(b){j!==b&&(a.clearStencil(b),j=b)},reset:function(){b=!1,c=null,d=null,e=null,f=null,g=null,h=null,i=null,j=null}}}();let j={},k=null,l={},m=null,n=!1,o=null,p=null,q=null,r=null,s=null,t=null,u=null,v=!1,w=null,x=null,y=null,z=null,A=null;const B=a.getParameter(35661);let C=!1;const D=a.getParameter(7938);-1!==D.indexOf("WebGL")?C=parseFloat(/^WebGL (\d)/.exec(D)[1])>=1:-1!==D.indexOf("OpenGL ES")&&(C=parseFloat(/^OpenGL ES (\d)/.exec(D)[1])>=2);let E=null,F={};const G=a.getParameter(3088),H=a.getParameter(2978),I=new ae().fromArray(G),J=new ae().fromArray(H);function K(b,c,d){const e=new Uint8Array(4),f=a.createTexture();a.bindTexture(b,f),a.texParameteri(b,10241,9728),a.texParameteri(b,10240,9728);for(let g=0;g<d;g++)a.texImage2D(c+g,0,6408,1,1,0,6408,5121,e);return f}const L={};function M(b){!0!==j[b]&&(a.enable(b),j[b]=!0)}function N(b){!1!==j[b]&&(a.disable(b),j[b]=!1)}L[3553]=K(3553,3553,1),L[34067]=K(34067,34069,6),e.setClear(0,0,0,1),f.setClear(1),i.setClear(0),M(2929),f.setFunc(3),S(!1),T(1),M(2884),R(0);const O={[100]:32774,[101]:32778,[102]:32779};if(d)O[103]=32775,O[104]=32776;else{const P=b.get("EXT_blend_minmax");null!==P&&(O[103]=P.MIN_EXT,O[104]=P.MAX_EXT)}const Q={[200]:0,[201]:1,[202]:768,[204]:770,[210]:776,[208]:774,[206]:772,[203]:769,[205]:771,[209]:775,[207]:773};function R(b,c,d,e,f,g,h,i){if(0===b){!0===n&&(N(3042),n=!1);return}if(!1===n&&(M(3042),n=!0),5!==b){if(b!==o||i!==v){if((100!==p||100!==s)&&(a.blendEquation(32774),p=100,s=100),i)switch(b){case 1:a.blendFuncSeparate(1,771,1,771);break;case 2:a.blendFunc(1,1);break;case 3:a.blendFuncSeparate(0,0,769,771);break;case 4:a.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",b);break}else switch(b){case 1:a.blendFuncSeparate(770,771,1,771);break;case 2:a.blendFunc(770,1);break;case 3:a.blendFunc(0,769);break;case 4:a.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",b);break}q=null,r=null,t=null,u=null,o=b,v=i}return}f=f||c,g=g||d,h=h||e,(c!==p||f!==s)&&(a.blendEquationSeparate(O[c],O[f]),p=c,s=f),(d!==q||e!==r||g!==t||h!==u)&&(a.blendFuncSeparate(Q[d],Q[e],Q[g],Q[h]),q=d,r=e,t=g,u=h),o=b,v=null}function S(b){w!==b&&(b?a.frontFace(2304):a.frontFace(2305),w=b)}function T(b){0!==b?(M(2884),b!==x&&(1===b?a.cullFace(1029):2===b?a.cullFace(1028):a.cullFace(1032))):N(2884),x=b}function U(b,c,d){b?(M(32823),(z!==c||A!==d)&&(a.polygonOffset(c,d),z=c,A=d)):N(32823)}function V(b){void 0===b&&(b=33984+B-1),E!==b&&(a.activeTexture(b),E=b)}return{buffers:{color:e,depth:f,stencil:i},enable:M,disable:N,bindFramebuffer:function(b,c){return null===c&&null!==k&&(c=k),l[b]!==c&&(a.bindFramebuffer(b,c),l[b]=c,d&&(36009===b&&(l[36160]=c),36160===b&&(l[36009]=c)),!0)},bindXRFramebuffer:function(b){b!==k&&(a.bindFramebuffer(36160,b),k=b)},useProgram:function(b){return m!==b&&(a.useProgram(b),m=b,!0)},setBlending:R,setMaterial:function(a,b){a.side===h?N(2884):M(2884);let c=a.side===g;b&&(c=!c),S(c),1===a.blending&& !1===a.transparent?R(0):R(a.blending,a.blendEquation,a.blendSrc,a.blendDst,a.blendEquationAlpha,a.blendSrcAlpha,a.blendDstAlpha,a.premultipliedAlpha),f.setFunc(a.depthFunc),f.setTest(a.depthTest),f.setMask(a.depthWrite),e.setMask(a.colorWrite);const d=a.stencilWrite;i.setTest(d),d&&(i.setMask(a.stencilWriteMask),i.setFunc(a.stencilFunc,a.stencilRef,a.stencilFuncMask),i.setOp(a.stencilFail,a.stencilZFail,a.stencilZPass)),U(a.polygonOffset,a.polygonOffsetFactor,a.polygonOffsetUnits),!0===a.alphaToCoverage?M(32926):N(32926)},setFlipSided:S,setCullFace:T,setLineWidth:function(b){b!==y&&(C&&a.lineWidth(b),y=b)},setPolygonOffset:U,setScissorTest:function(a){a?M(3089):N(3089)},activeTexture:V,bindTexture:function(b,c){null===E&&V();let d=F[E];void 0===d&&(d={type:void 0,texture:void 0},F[E]=d),(d.type!==b||d.texture!==c)&&(a.bindTexture(b,c||L[b]),d.type=b,d.texture=c)},unbindTexture:function(){const b=F[E];void 0!==b&& void 0!==b.type&&(a.bindTexture(b.type,null),b.type=void 0,b.texture=void 0)},compressedTexImage2D:function(){try{a.compressedTexImage2D.apply(a,arguments)}catch(b){console.error("THREE.WebGLState:",b)}},texImage2D:function(){try{a.texImage2D.apply(a,arguments)}catch(b){console.error("THREE.WebGLState:",b)}},texImage3D:function(){try{a.texImage3D.apply(a,arguments)}catch(b){console.error("THREE.WebGLState:",b)}},scissor:function(b){!1===I.equals(b)&&(a.scissor(b.x,b.y,b.z,b.w),I.copy(b))},viewport:function(b){!1===J.equals(b)&&(a.viewport(b.x,b.y,b.z,b.w),J.copy(b))},reset:function(){a.disable(3042),a.disable(2884),a.disable(2929),a.disable(32823),a.disable(3089),a.disable(2960),a.disable(32926),a.blendEquation(32774),a.blendFunc(1,0),a.blendFuncSeparate(1,0,1,0),a.colorMask(!0,!0,!0,!0),a.clearColor(0,0,0,0),a.depthMask(!0),a.depthFunc(513),a.clearDepth(1),a.stencilMask(4294967295),a.stencilFunc(519,0,4294967295),a.stencilOp(7680,7680,7680),a.clearStencil(0),a.cullFace(1029),a.frontFace(2305),a.polygonOffset(0,0),a.activeTexture(33984),a.bindFramebuffer(36160,null),!0===d&&(a.bindFramebuffer(36009,null),a.bindFramebuffer(36008,null)),a.useProgram(null),a.lineWidth(1),a.scissor(0,0,a.canvas.width,a.canvas.height),a.viewport(0,0,a.canvas.width,a.canvas.height),j={},E=null,F={},k=null,l={},m=null,n=!1,o=null,p=null,q=null,r=null,s=null,t=null,u=null,v=!1,w=null,x=null,y=null,z=null,A=null,I.set(0,0,a.canvas.width,a.canvas.height),J.set(0,0,a.canvas.width,a.canvas.height),e.reset(),f.reset(),i.reset()}}}function EQ(a,b,c,d,e,f,g){const h=e.isWebGL2,s=e.maxTextures,t=e.maxCubemapSize,u=e.maxTextureSize,v=e.maxSamples,x=new WeakMap();let y,z=!1;try{z="undefined"!=typeof OffscreenCanvas&&null!==new OffscreenCanvas(1,1).getContext("2d")}catch(A){}function B(a,b){return z?new OffscreenCanvas(a,b):yd("canvas")}function C(a,b,c,d){let e=1;if((a.width>d||a.height>d)&&(e=d/Math.max(a.width,a.height)),e<1|| !0===b){if(("undefined"==typeof HTMLImageElement||!(a instanceof HTMLImageElement))&&("undefined"==typeof HTMLCanvasElement||!(a instanceof HTMLCanvasElement))&&("undefined"==typeof ImageBitmap||!(a instanceof ImageBitmap)))return"data"in a&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+a.width+"x"+a.height+")."),a;{const f=b?ba:Math.floor,g=f(e*a.width),h=f(e*a.height);void 0===y&&(y=B(g,h));const i=c?B(g,h):y;i.width=g,i.height=h;const j=i.getContext("2d");return j.drawImage(a,0,0,g,h),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+a.width+"x"+a.height+") to ("+g+"x"+h+")."),i}}return a}function D(a){return _(a.width)&&_(a.height)}function E(a,b){return a.generateMipmaps&&b&&a.minFilter!==l&&a.minFilter!==o}function F(b,c,e,f,g=1){a.generateMipmap(b);const h=d.get(c);h.__maxMipLevel=Math.log2(Math.max(e,f,g))}function G(c,d,e,f){if(!1===h)return d;if(null!==c){if(void 0!==a[c])return a[c];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+c+"'")}let g=d;return 6403===d&&(5126===e&&(g=33326),5131===e&&(g=33325),5121===e&&(g=33321)),6407===d&&(5126===e&&(g=34837),5131===e&&(g=34843),5121===e&&(g=32849)),6408===d&&(5126===e&&(g=34836),5131===e&&(g=34842),5121===e&&(g=f===w?35907:32856)),(33325===g||33326===g||34842===g||34836===g)&&b.get("EXT_color_buffer_float"),g}function H(a){return a===l||a===m||a===n?9728:9729}function I(a){const b=a.target;b.removeEventListener("dispose",I),K(b),b.isVideoTexture&&x.delete(b),g.memory.textures--}function J(a){const b=a.target;b.removeEventListener("dispose",J),L(b)}function K(b){const c=d.get(b);void 0!==c.__webglInit&&(a.deleteTexture(c.__webglTexture),d.remove(b))}function L(b){const c=b.texture,e=d.get(b),f=d.get(c);if(b){if(void 0!==f.__webglTexture&&(a.deleteTexture(f.__webglTexture),g.memory.textures--),b.depthTexture&&b.depthTexture.dispose(),b.isWebGLCubeRenderTarget)for(let h=0;h<6;h++)a.deleteFramebuffer(e.__webglFramebuffer[h]),e.__webglDepthbuffer&&a.deleteRenderbuffer(e.__webglDepthbuffer[h]);else a.deleteFramebuffer(e.__webglFramebuffer),e.__webglDepthbuffer&&a.deleteRenderbuffer(e.__webglDepthbuffer),e.__webglMultisampledFramebuffer&&a.deleteFramebuffer(e.__webglMultisampledFramebuffer),e.__webglColorRenderbuffer&&a.deleteRenderbuffer(e.__webglColorRenderbuffer),e.__webglDepthRenderbuffer&&a.deleteRenderbuffer(e.__webglDepthRenderbuffer);if(b.isWebGLMultipleRenderTargets)for(let i=0,j=c.length;i<j;i++){const k=d.get(c[i]);k.__webglTexture&&(a.deleteTexture(k.__webglTexture),g.memory.textures--),d.remove(c[i])}d.remove(c),d.remove(b)}}let M=0;function N(a,b){const e=d.get(a);if(a.isVideoTexture&&Y(a),a.version>0&&e.__version!==a.version){const f=a.image;if(void 0===f)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(!1===f.complete)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{T(e,a,b);return}}c.activeTexture(33984+b),c.bindTexture(3553,e.__webglTexture)}function O(a,b){const e=d.get(a);if(a.version>0&&e.__version!==a.version){U(e,a,b);return}c.activeTexture(33984+b),c.bindTexture(34067,e.__webglTexture)}const P={[i]:10497,[j]:33071,[k]:33648},Q={[l]:9728,[m]:9984,[n]:9986,[o]:9729,[p]:9985,[q]:9987};function R(c,f,g){if(g?(a.texParameteri(c,10242,P[f.wrapS]),a.texParameteri(c,10243,P[f.wrapT]),(32879===c||35866===c)&&a.texParameteri(c,32882,P[f.wrapR]),a.texParameteri(c,10240,Q[f.magFilter]),a.texParameteri(c,10241,Q[f.minFilter])):(a.texParameteri(c,10242,33071),a.texParameteri(c,10243,33071),(32879===c||35866===c)&&a.texParameteri(c,32882,33071),(f.wrapS!==j||f.wrapT!==j)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),a.texParameteri(c,10240,H(f.magFilter)),a.texParameteri(c,10241,H(f.minFilter)),f.minFilter!==l&&f.minFilter!==o&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),!0===b.has("EXT_texture_filter_anisotropic")){const i=b.get("EXT_texture_filter_anisotropic");(1015!==f.type|| !1!==b.has("OES_texture_float_linear"))&&(!1!==h||1016!==f.type|| !1!==b.has("OES_texture_half_float_linear"))&&(f.anisotropy>1||d.get(f).__currentAnisotropy)&&(a.texParameterf(c,i.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(f.anisotropy,e.getMaxAnisotropy())),d.get(f).__currentAnisotropy=f.anisotropy)}}function S(b,c){void 0===b.__webglInit&&(b.__webglInit=!0,c.addEventListener("dispose",I),b.__webglTexture=a.createTexture(),g.memory.textures++)}function T(b,d,e){var g;let i=3553;d.isDataTexture2DArray&&(i=35866),d.isDataTexture3D&&(i=32879),S(b,d),c.activeTexture(33984+e),c.bindTexture(i,b.__webglTexture),a.pixelStorei(37440,d.flipY),a.pixelStorei(37441,d.premultiplyAlpha),a.pixelStorei(3317,d.unpackAlignment),a.pixelStorei(37443,0);const k=(g=d,!h&&(g.wrapS!==j||g.wrapT!==j||g.minFilter!==l&&g.minFilter!==o)&& !1===D(d.image)),m=C(d.image,k,!1,u),n=D(m)||h,p=f.convert(d.format);let q=f.convert(d.type),s=G(d.internalFormat,p,q,d.encoding);R(i,d,n);let t;const v=d.mipmaps;if(d.isDepthTexture)s=6402,h?s=1015===d.type?36012:1014===d.type?33190:1020===d.type?35056:33189:1015===d.type&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),1026===d.format&&6402===s&&1012!==d.type&&1014!==d.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),d.type=1012,q=f.convert(d.type)),1027===d.format&&6402===s&&(s=34041,1020!==d.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),d.type=1020,q=f.convert(d.type))),c.texImage2D(3553,0,s,m.width,m.height,0,p,q,null);else if(d.isDataTexture)if(v.length>0&&n){for(let w=0,x=v.length;w<x;w++)t=v[w],c.texImage2D(3553,w,s,t.width,t.height,0,p,q,t.data);d.generateMipmaps=!1,b.__maxMipLevel=v.length-1}else c.texImage2D(3553,0,s,m.width,m.height,0,p,q,m.data),b.__maxMipLevel=0;else if(d.isCompressedTexture){for(let y=0,z=v.length;y<z;y++)t=v[y],1023!==d.format&&d.format!==r?null!==p?c.compressedTexImage2D(3553,y,s,t.width,t.height,0,t.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):c.texImage2D(3553,y,s,t.width,t.height,0,p,q,t.data);b.__maxMipLevel=v.length-1}else if(d.isDataTexture2DArray)c.texImage3D(35866,0,s,m.width,m.height,m.depth,0,p,q,m.data),b.__maxMipLevel=0;else if(d.isDataTexture3D)c.texImage3D(32879,0,s,m.width,m.height,m.depth,0,p,q,m.data),b.__maxMipLevel=0;else if(v.length>0&&n){for(let A=0,B=v.length;A<B;A++)t=v[A],c.texImage2D(3553,A,s,p,q,t);d.generateMipmaps=!1,b.__maxMipLevel=v.length-1}else c.texImage2D(3553,0,s,p,q,m),b.__maxMipLevel=0;E(d,n)&&F(i,d,m.width,m.height),b.__version=d.version,d.onUpdate&&d.onUpdate(d)}function U(b,d,e){if(6!==d.image.length)return;S(b,d),c.activeTexture(33984+e),c.bindTexture(34067,b.__webglTexture),a.pixelStorei(37440,d.flipY),a.pixelStorei(37441,d.premultiplyAlpha),a.pixelStorei(3317,d.unpackAlignment),a.pixelStorei(37443,0);const g=d&&(d.isCompressedTexture||d.image[0].isCompressedTexture),i=d.image[0]&&d.image[0].isDataTexture,j=[];for(let k=0;k<6;k++)g||i?j[k]=i?d.image[k].image:d.image[k]:j[k]=C(d.image[k],!1,!0,t);const l=j[0],m=D(l)||h,n=f.convert(d.format),o=f.convert(d.type),p=G(d.internalFormat,n,o,d.encoding);R(34067,d,m);let q;if(g){for(let s=0;s<6;s++){q=j[s].mipmaps;for(let u=0;u<q.length;u++){const v=q[u];1023!==d.format&&d.format!==r?null!==n?c.compressedTexImage2D(34069+s,u,p,v.width,v.height,0,v.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):c.texImage2D(34069+s,u,p,v.width,v.height,0,n,o,v.data)}}b.__maxMipLevel=q.length-1}else{q=d.mipmaps;for(let w=0;w<6;w++)if(i){c.texImage2D(34069+w,0,p,j[w].width,j[w].height,0,n,o,j[w].data);for(let x=0;x<q.length;x++){const y=q[x],z=y.image[w].image;c.texImage2D(34069+w,x+1,p,z.width,z.height,0,n,o,z.data)}}else{c.texImage2D(34069+w,0,p,n,o,j[w]);for(let A=0;A<q.length;A++){const B=q[A];c.texImage2D(34069+w,A+1,p,n,o,B.image[w])}}b.__maxMipLevel=q.length}E(d,m)&&F(34067,d,l.width,l.height),b.__version=d.version,d.onUpdate&&d.onUpdate(d)}function V(b,e,g,h,i){const j=f.convert(g.format),k=f.convert(g.type),l=G(g.internalFormat,j,k,g.encoding);32879===i||35866===i?c.texImage3D(i,0,l,e.width,e.height,e.depth,0,j,k,null):c.texImage2D(i,0,l,e.width,e.height,0,j,k,null),c.bindFramebuffer(36160,b),a.framebufferTexture2D(36160,h,i,d.get(g).__webglTexture,0),c.bindFramebuffer(36160,null)}function W(b,c,d){if(a.bindRenderbuffer(36161,b),c.depthBuffer&&!c.stencilBuffer){let e=33189;if(d){const g=c.depthTexture;g&&g.isDepthTexture&&(1015===g.type?e=36012:1014===g.type&&(e=33190));const h=X(c);a.renderbufferStorageMultisample(36161,h,e,c.width,c.height)}else a.renderbufferStorage(36161,e,c.width,c.height);a.framebufferRenderbuffer(36160,36096,36161,b)}else if(c.depthBuffer&&c.stencilBuffer){if(d){const i=X(c);a.renderbufferStorageMultisample(36161,i,35056,c.width,c.height)}else a.renderbufferStorage(36161,34041,c.width,c.height);a.framebufferRenderbuffer(36160,33306,36161,b)}else{const j=!0===c.isWebGLMultipleRenderTargets?c.texture[0]:c.texture,k=f.convert(j.format),l=f.convert(j.type),m=G(j.internalFormat,k,l,j.encoding);if(d){const n=X(c);a.renderbufferStorageMultisample(36161,n,m,c.width,c.height)}else a.renderbufferStorage(36161,m,c.width,c.height)}a.bindRenderbuffer(36161,null)}function X(a){return h&&a.isWebGLMultisampleRenderTarget?Math.min(v,a.samples):0}function Y(a){const b=g.render.frame;x.get(a)!==b&&(x.set(a,b),a.update())}let Z=!1,$=!1;this.allocateTextureUnit=function(){const a=M;return a>=s&&console.warn("THREE.WebGLTextures: Trying to use "+a+" texture units while this GPU supports only "+s),M+=1,a},this.resetTextureUnits=function(){M=0},this.setTexture2D=N,this.setTexture2DArray=function(a,b){const e=d.get(a);if(a.version>0&&e.__version!==a.version){T(e,a,b);return}c.activeTexture(33984+b),c.bindTexture(35866,e.__webglTexture)},this.setTexture3D=function(a,b){const e=d.get(a);if(a.version>0&&e.__version!==a.version){T(e,a,b);return}c.activeTexture(33984+b),c.bindTexture(32879,e.__webglTexture)},this.setTextureCube=O,this.setupRenderTarget=function(b){const i=b.texture,j=d.get(b),k=d.get(i);b.addEventListener("dispose",J),!0!==b.isWebGLMultipleRenderTargets&&(k.__webglTexture=a.createTexture(),k.__version=i.version,g.memory.textures++);const l=!0===b.isWebGLCubeRenderTarget,m=!0===b.isWebGLMultipleRenderTargets,n=!0===b.isWebGLMultisampleRenderTarget,o=i.isDataTexture3D||i.isDataTexture2DArray,p=D(b)||h;if(h&&i.format===r&&(1015===i.type||1016===i.type)&&(i.format=1023,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),l){j.__webglFramebuffer=[];for(let q=0;q<6;q++)j.__webglFramebuffer[q]=a.createFramebuffer()}else if(j.__webglFramebuffer=a.createFramebuffer(),m)if(e.drawBuffers){const s=b.texture;for(let t=0,u=s.length;t<u;t++){const v=d.get(s[t]);void 0===v.__webglTexture&&(v.__webglTexture=a.createTexture(),g.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(n)if(h){j.__webglMultisampledFramebuffer=a.createFramebuffer(),j.__webglColorRenderbuffer=a.createRenderbuffer(),a.bindRenderbuffer(36161,j.__webglColorRenderbuffer);const w=f.convert(i.format),x=f.convert(i.type),y=G(i.internalFormat,w,x,i.encoding),z=X(b);a.renderbufferStorageMultisample(36161,z,y,b.width,b.height),c.bindFramebuffer(36160,j.__webglMultisampledFramebuffer),a.framebufferRenderbuffer(36160,36064,36161,j.__webglColorRenderbuffer),a.bindRenderbuffer(36161,null),b.depthBuffer&&(j.__webglDepthRenderbuffer=a.createRenderbuffer(),W(j.__webglDepthRenderbuffer,b,!0)),c.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(l){c.bindTexture(34067,k.__webglTexture),R(34067,i,p);for(let A=0;A<6;A++)V(j.__webglFramebuffer[A],b,i,36064,34069+A);E(i,p)&&F(34067,i,b.width,b.height),c.unbindTexture()}else if(m){const B=b.texture;for(let C=0,H=B.length;C<H;C++){const I=B[C],K=d.get(I);c.bindTexture(3553,K.__webglTexture),R(3553,I,p),V(j.__webglFramebuffer,b,I,36064+C,3553),E(I,p)&&F(3553,I,b.width,b.height)}c.unbindTexture()}else{let L=3553;if(o)if(h){const M=i.isDataTexture3D;L=M?32879:35866}else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");c.bindTexture(L,k.__webglTexture),R(L,i,p),V(j.__webglFramebuffer,b,i,36064,L),E(i,p)&&F(L,i,b.width,b.height,b.depth),c.unbindTexture()}b.depthBuffer&&(function(b){const e=d.get(b),f=!0===b.isWebGLCubeRenderTarget;if(b.depthTexture){if(f)throw new Error("target.depthTexture not supported in Cube render targets");!function(b,e){const f=e&&e.isWebGLCubeRenderTarget;if(f)throw new Error("Depth Texture with cube render targets is not supported");if(c.bindFramebuffer(36160,b),!(e.depthTexture&&e.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");d.get(e.depthTexture).__webglTexture&&e.depthTexture.image.width===e.width&&e.depthTexture.image.height===e.height||(e.depthTexture.image.width=e.width,e.depthTexture.image.height=e.height,e.depthTexture.needsUpdate=!0),N(e.depthTexture,0);const g=d.get(e.depthTexture).__webglTexture;if(1026===e.depthTexture.format)a.framebufferTexture2D(36160,36096,3553,g,0);else if(1027===e.depthTexture.format)a.framebufferTexture2D(36160,33306,3553,g,0);else throw new Error("Unknown depthTexture format")}(e.__webglFramebuffer,b)}else if(f){e.__webglDepthbuffer=[];for(let g=0;g<6;g++)c.bindFramebuffer(36160,e.__webglFramebuffer[g]),e.__webglDepthbuffer[g]=a.createRenderbuffer(),W(e.__webglDepthbuffer[g],b,!1)}else c.bindFramebuffer(36160,e.__webglFramebuffer),e.__webglDepthbuffer=a.createRenderbuffer(),W(e.__webglDepthbuffer,b,!1);c.bindFramebuffer(36160,null)})(b)},this.updateRenderTargetMipmap=function(a){const b=D(a)||h,e=!0===a.isWebGLMultipleRenderTargets?a.texture:[a.texture];for(let f=0,g=e.length;f<g;f++){const i=e[f];if(E(i,b)){const j=a.isWebGLCubeRenderTarget?34067:3553,k=d.get(i).__webglTexture;c.bindTexture(j,k),F(j,i,a.width,a.height),c.unbindTexture()}}},this.updateMultisampleRenderTarget=function(b){if(b.isWebGLMultisampleRenderTarget)if(h){const e=b.width,f=b.height;let g=16384;b.depthBuffer&&(g|=256),b.stencilBuffer&&(g|=1024);const i=d.get(b);c.bindFramebuffer(36008,i.__webglMultisampledFramebuffer),c.bindFramebuffer(36009,i.__webglFramebuffer),a.blitFramebuffer(0,0,e,f,0,0,e,f,g,9728),c.bindFramebuffer(36008,null),c.bindFramebuffer(36009,i.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")},this.safeSetTexture2D=function(a,b){a&&a.isWebGLRenderTarget&&(!1===Z&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),Z=!0),a=a.texture),N(a,b)},this.safeSetTextureCube=function(a,b){a&&a.isWebGLCubeRenderTarget&&(!1===$&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),$=!0),a=a.texture),O(a,b)}}function FQ(a,b,c){const d=c.isWebGL2;return{convert:function(a){let c;if(1009===a)return 5121;if(1017===a)return 32819;if(1018===a)return 32820;if(1019===a)return 33635;if(1010===a)return 5120;if(1011===a)return 5122;if(1012===a)return 5123;if(1013===a)return 5124;if(1014===a)return 5125;if(1015===a)return 5126;if(1016===a)return d?5131:null!==(c=b.get("OES_texture_half_float"))?c.HALF_FLOAT_OES:null;if(1021===a)return 6406;if(a===r)return 6407;if(1023===a)return 6408;if(1024===a)return 6409;if(1025===a)return 6410;if(1026===a)return 6402;if(1027===a)return 34041;if(1028===a)return 6403;if(1029===a)return 36244;if(1030===a)return 33319;if(1031===a)return 33320;if(1032===a)return 36248;if(1033===a)return 36249;if(33776===a||33777===a||33778===a||33779===a){if(null===(c=b.get("WEBGL_compressed_texture_s3tc")))return null;if(33776===a)return c.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===a)return c.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===a)return c.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===a)return c.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===a||35841===a||35842===a||35843===a){if(null===(c=b.get("WEBGL_compressed_texture_pvrtc")))return null;if(35840===a)return c.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===a)return c.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===a)return c.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===a)return c.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===a)return null!==(c=b.get("WEBGL_compressed_texture_etc1"))?c.COMPRESSED_RGB_ETC1_WEBGL:null;if((37492===a||37496===a)&&null!==(c=b.get("WEBGL_compressed_texture_etc"))){if(37492===a)return c.COMPRESSED_RGB8_ETC2;if(37496===a)return c.COMPRESSED_RGBA8_ETC2_EAC}return 37808===a||37809===a||37810===a||37811===a||37812===a||37813===a||37814===a||37815===a||37816===a||37817===a||37818===a||37819===a||37820===a||37821===a||37840===a||37841===a||37842===a||37843===a||37844===a||37845===a||37846===a||37847===a||37848===a||37849===a||37850===a||37851===a||37852===a||37853===a?null!==(c=b.get("WEBGL_compressed_texture_astc"))?a:null:36492===a?null!==(c=b.get("EXT_texture_compression_bptc"))?a:null:1020===a?d?34042:null!==(c=b.get("WEBGL_depth_texture"))?c.UNSIGNED_INT_24_8_WEBGL:null:void 0}}}zQ.prototype.isMeshDistanceMaterial=!0;class GQ extends iI{constructor(HQ=[]){super(),this.cameras=HQ}}GQ.prototype.isArrayCamera=!0;class IQ extends hv{constructor(){super(),this.type="Group"}}IQ.prototype.isGroup=!0;const JQ={type:"move"};class KQ{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new IQ(),this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new IQ(),this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Qi(),this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Qi()),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new IQ(),this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Qi(),this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Qi()),this._grip}dispatchEvent(LQ){return null!==this._targetRay&&this._targetRay.dispatchEvent(LQ),null!==this._grip&&this._grip.dispatchEvent(LQ),null!==this._hand&&this._hand.dispatchEvent(LQ),this}disconnect(MQ){return this.dispatchEvent({type:"disconnected",data:MQ}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(NQ,OQ,PQ){let QQ=null,RQ=null,SQ=null;const TQ=this._targetRay,UQ=this._grip,VQ=this._hand;if(NQ&&"visible-blurred"!==OQ.session.visibilityState)if(null!==TQ&&null!==(QQ=OQ.getPose(NQ.targetRaySpace,PQ))&&(TQ.matrix.fromArray(QQ.transform.matrix),TQ.matrix.decompose(TQ.position,TQ.rotation,TQ.scale),QQ.linearVelocity?(TQ.hasLinearVelocity=!0,TQ.linearVelocity.copy(QQ.linearVelocity)):TQ.hasLinearVelocity=!1,QQ.angularVelocity?(TQ.hasAngularVelocity=!0,TQ.angularVelocity.copy(QQ.angularVelocity)):TQ.hasAngularVelocity=!1,this.dispatchEvent(JQ)),VQ&&NQ.hand){for(const WQ of(SQ=!0,NQ.hand.values())){const XQ=OQ.getJointPose(WQ,PQ);if(void 0===VQ.joints[WQ.jointName]){const YQ=new IQ();YQ.matrixAutoUpdate=!1,YQ.visible=!1,VQ.joints[WQ.jointName]=YQ,VQ.add(YQ)}const ZQ=VQ.joints[WQ.jointName];null!==XQ&&(ZQ.matrix.fromArray(XQ.transform.matrix),ZQ.matrix.decompose(ZQ.position,ZQ.rotation,ZQ.scale),ZQ.jointRadius=XQ.radius),ZQ.visible=null!==XQ}const $Q=VQ.joints["index-finger-tip"],_Q=VQ.joints["thumb-tip"],aR=$Q.position.distanceTo(_Q.position),bR=0.02,cR=0.005;VQ.inputState.pinching&&aR>bR+cR?(VQ.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:NQ.handedness,target:this})):!VQ.inputState.pinching&&aR<=bR-cR&&(VQ.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:NQ.handedness,target:this}))}else null!==UQ&&NQ.gripSpace&&null!==(RQ=OQ.getPose(NQ.gripSpace,PQ))&&(UQ.matrix.fromArray(RQ.transform.matrix),UQ.matrix.decompose(UQ.position,UQ.rotation,UQ.scale),RQ.linearVelocity?(UQ.hasLinearVelocity=!0,UQ.linearVelocity.copy(RQ.linearVelocity)):UQ.hasLinearVelocity=!1,RQ.angularVelocity?(UQ.hasAngularVelocity=!0,UQ.angularVelocity.copy(RQ.angularVelocity)):UQ.hasAngularVelocity=!1);return null!==TQ&&(TQ.visible=null!==QQ),null!==UQ&&(UQ.visible=null!==RQ),null!==VQ&&(VQ.visible=null!==SQ),this}}class dR extends z{constructor(eR,fR){super();const gR=this,hR=eR.state;let iR=null,jR=1,kR=null,lR="local-floor",mR=null,nR=null,oR=null,pR=null,qR=null,rR=!1,sR=null,tR=null,uR=null,vR=null,wR=null,xR=null;const yR=[],zR=new Map(),AR=new iI();AR.layers.enable(1),AR.viewport=new ae();const BR=new iI();BR.layers.enable(2),BR.viewport=new ae();const CR=[AR,BR],DR=new GQ();DR.layers.enable(1),DR.layers.enable(2);let ER=null,FR=null;function GR(a){const b=zR.get(a.inputSource);b&&b.dispatchEvent({type:a.type,data:a.inputSource})}function HR(){zR.forEach(function(a,b){a.disconnect(b)}),zR.clear(),ER=null,FR=null,hR.bindXRFramebuffer(null),eR.setRenderTarget(eR.getRenderTarget()),oR&&fR.deleteFramebuffer(oR),sR&&fR.deleteFramebuffer(sR),tR&&fR.deleteRenderbuffer(tR),uR&&fR.deleteRenderbuffer(uR),oR=null,sR=null,tR=null,uR=null,qR=null,pR=null,nR=null,iR=null,NR.stop(),gR.isPresenting=!1,gR.dispatchEvent({type:"sessionend"})}function IR(a){const b=iR.inputSources;for(let c=0;c<yR.length;c++)zR.set(b[c],yR[c]);for(let d=0;d<a.removed.length;d++){const e=a.removed[d],f=zR.get(e);f&&(f.dispatchEvent({type:"disconnected",data:e}),zR.delete(e))}for(let g=0;g<a.added.length;g++){const h=a.added[g],i=zR.get(h);i&&i.dispatchEvent({type:"connected",data:h})}}this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(a){let b=yR[a];return void 0===b&&(b=new KQ(),yR[a]=b),b.getTargetRaySpace()},this.getControllerGrip=function(a){let b=yR[a];return void 0===b&&(b=new KQ(),yR[a]=b),b.getGripSpace()},this.getHand=function(a){let b=yR[a];return void 0===b&&(b=new KQ(),yR[a]=b),b.getHandSpace()},this.setFramebufferScaleFactor=function(a){jR=a,!0===gR.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(a){lR=a,!0===gR.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return kR},this.getBaseLayer=function(){return null!==pR?pR:qR},this.getBinding=function(){return nR},this.getFrame=function(){return vR},this.getSession=function(){return iR},this.setSession=async function(a){if(null!==(iR=a)){iR.addEventListener("select",GR),iR.addEventListener("selectstart",GR),iR.addEventListener("selectend",GR),iR.addEventListener("squeeze",GR),iR.addEventListener("squeezestart",GR),iR.addEventListener("squeezeend",GR),iR.addEventListener("end",HR),iR.addEventListener("inputsourceschange",IR);const b=fR.getContextAttributes();if(!0!==b.xrCompatible&&await fR.makeXRCompatible(),void 0===iR.renderState.layers){const c={antialias:b.antialias,alpha:b.alpha,depth:b.depth,stencil:b.stencil,framebufferScaleFactor:jR};qR=new XRWebGLLayer(iR,fR,c),iR.updateRenderState({baseLayer:qR})}else if(fR instanceof WebGLRenderingContext){const d={antialias:!0,alpha:b.alpha,depth:b.depth,stencil:b.stencil,framebufferScaleFactor:jR};qR=new XRWebGLLayer(iR,fR,d),iR.updateRenderState({layers:[qR]})}else{rR=b.antialias;let e=null;b.depth&&(xR=256,b.stencil&&(xR|=1024),wR=b.stencil?33306:36096,e=b.stencil?35056:33190);const f={colorFormat:b.alpha?32856:32849,depthFormat:e,scaleFactor:jR};pR=(nR=new XRWebGLBinding(iR,fR)).createProjectionLayer(f),oR=fR.createFramebuffer(),iR.updateRenderState({layers:[pR]}),rR&&(sR=fR.createFramebuffer(),tR=fR.createRenderbuffer(),fR.bindRenderbuffer(36161,tR),fR.renderbufferStorageMultisample(36161,4,32856,pR.textureWidth,pR.textureHeight),hR.bindFramebuffer(36160,sR),fR.framebufferRenderbuffer(36160,36064,36161,tR),fR.bindRenderbuffer(36161,null),null!==e&&(uR=fR.createRenderbuffer(),fR.bindRenderbuffer(36161,uR),fR.renderbufferStorageMultisample(36161,4,e,pR.textureWidth,pR.textureHeight),fR.framebufferRenderbuffer(36160,wR,36161,uR),fR.bindRenderbuffer(36161,null)),hR.bindFramebuffer(36160,null))}kR=await iR.requestReferenceSpace(lR),NR.setContext(iR),NR.start(),gR.isPresenting=!0,gR.dispatchEvent({type:"sessionstart"})}};const JR=new Qi(),KR=new Qi();function LR(a,b){null===b?a.matrixWorld.copy(a.matrix):a.matrixWorld.multiplyMatrices(b.matrixWorld,a.matrix),a.matrixWorldInverse.copy(a.matrixWorld).invert()}this.updateCamera=function(a){if(null===iR)return;DR.near=BR.near=AR.near=a.near,DR.far=BR.far=AR.far=a.far,(ER!==DR.near||FR!==DR.far)&&(iR.updateRenderState({depthNear:DR.near,depthFar:DR.far}),ER=DR.near,FR=DR.far);const b=a.parent,c=DR.cameras;LR(DR,b);for(let d=0;d<c.length;d++)LR(c[d],b);DR.matrixWorld.decompose(DR.position,DR.quaternion,DR.scale),a.position.copy(DR.position),a.quaternion.copy(DR.quaternion),a.scale.copy(DR.scale),a.matrix.copy(DR.matrix),a.matrixWorld.copy(DR.matrixWorld);const e=a.children;for(let f=0,g=e.length;f<g;f++)e[f].updateMatrixWorld(!0);2===c.length?(function(a,b,c){JR.setFromMatrixPosition(b.matrixWorld),KR.setFromMatrixPosition(c.matrixWorld);const d=JR.distanceTo(KR),e=b.projectionMatrix.elements,f=c.projectionMatrix.elements,g=e[14]/(e[10]-1),h=e[14]/(e[10]+1),i=(e[9]+1)/e[5],j=(e[9]-1)/e[5],k=(e[8]-1)/e[0],l=(f[8]+1)/f[0],m=d/(-k+l),n=-(m*k);b.matrixWorld.decompose(a.position,a.quaternion,a.scale),a.translateX(n),a.translateZ(m),a.matrixWorld.compose(a.position,a.quaternion,a.scale),a.matrixWorldInverse.copy(a.matrixWorld).invert();const o=g+m,p=h+m;a.projectionMatrix.makePerspective(g*k-n,g*l+(d-n),i*h/p*o,j*h/p*o,o,p)})(DR,AR,BR):DR.projectionMatrix.copy(AR.projectionMatrix)},this.getCamera=function(){return DR},this.getFoveation=function(){return null!==pR?pR.fixedFoveation:null!==qR?qR.fixedFoveation:void 0},this.setFoveation=function(a){null!==pR&&(pR.fixedFoveation=a),null!==qR&& void 0!==qR.fixedFoveation&&(qR.fixedFoveation=a)};let MR=null;const NR=new vL();NR.setAnimationLoop(function(a,b){if(mR=b.getViewerPose(kR),vR=b,null!==mR){const c=mR.views;null!==qR&&hR.bindXRFramebuffer(qR.framebuffer);let d=!1;c.length!==DR.cameras.length&&(DR.cameras.length=0,d=!0);for(let e=0;e<c.length;e++){const f=c[e];let g=null;if(null!==qR)g=qR.getViewport(f);else{const h=nR.getViewSubImage(pR,f);hR.bindXRFramebuffer(oR),void 0!==h.depthStencilTexture&&fR.framebufferTexture2D(36160,wR,3553,h.depthStencilTexture,0),fR.framebufferTexture2D(36160,36064,3553,h.colorTexture,0),g=h.viewport}const i=CR[e];i.matrix.fromArray(f.transform.matrix),i.projectionMatrix.fromArray(f.projectionMatrix),i.viewport.set(g.x,g.y,g.width,g.height),0===e&&DR.matrix.copy(i.matrix),!0===d&&DR.cameras.push(i)}rR&&(hR.bindXRFramebuffer(sR),null!==xR&&fR.clear(xR))}const j=iR.inputSources;for(let k=0;k<yR.length;k++){const l=yR[k],m=j[k];l.update(m,b,kR)}if(MR&&MR(a,b),rR){const n=pR.textureWidth,o=pR.textureHeight;hR.bindFramebuffer(36008,sR),hR.bindFramebuffer(36009,oR),fR.invalidateFramebuffer(36008,[wR]),fR.invalidateFramebuffer(36009,[wR]),fR.blitFramebuffer(0,0,n,o,0,0,n,o,16384,9728),fR.invalidateFramebuffer(36008,[36064]),hR.bindFramebuffer(36008,null),hR.bindFramebuffer(36009,null),hR.bindFramebuffer(36160,sR)}vR=null}),this.setAnimationLoop=function(a){MR=a},this.dispose=function(){}}}function OR(a){function b(b,c){b.opacity.value=c.opacity,c.color&&b.diffuse.value.copy(c.color),c.emissive&&b.emissive.value.copy(c.emissive).multiplyScalar(c.emissiveIntensity),c.map&&(b.map.value=c.map),c.alphaMap&&(b.alphaMap.value=c.alphaMap),c.specularMap&&(b.specularMap.value=c.specularMap),c.alphaTest>0&&(b.alphaTest.value=c.alphaTest);const d=a.get(c).envMap;if(d){b.envMap.value=d,b.flipEnvMap.value=d.isCubeTexture&& !1===d.isRenderTargetTexture?-1:1,b.reflectivity.value=c.reflectivity,b.ior.value=c.ior,b.refractionRatio.value=c.refractionRatio;const e=a.get(d).__maxMipLevel;void 0!==e&&(b.maxMipLevel.value=e)}c.lightMap&&(b.lightMap.value=c.lightMap,b.lightMapIntensity.value=c.lightMapIntensity),c.aoMap&&(b.aoMap.value=c.aoMap,b.aoMapIntensity.value=c.aoMapIntensity);let f;c.map?f=c.map:c.specularMap?f=c.specularMap:c.displacementMap?f=c.displacementMap:c.normalMap?f=c.normalMap:c.bumpMap?f=c.bumpMap:c.roughnessMap?f=c.roughnessMap:c.metalnessMap?f=c.metalnessMap:c.alphaMap?f=c.alphaMap:c.emissiveMap?f=c.emissiveMap:c.clearcoatMap?f=c.clearcoatMap:c.clearcoatNormalMap?f=c.clearcoatNormalMap:c.clearcoatRoughnessMap?f=c.clearcoatRoughnessMap:c.specularIntensityMap?f=c.specularIntensityMap:c.specularColorMap?f=c.specularColorMap:c.transmissionMap?f=c.transmissionMap:c.thicknessMap?f=c.thicknessMap:c.sheenColorMap?f=c.sheenColorMap:c.sheenRoughnessMap&&(f=c.sheenRoughnessMap),void 0!==f&&(f.isWebGLRenderTarget&&(f=f.texture),!0===f.matrixAutoUpdate&&f.updateMatrix(),b.uvTransform.value.copy(f.matrix));let g;c.aoMap?g=c.aoMap:c.lightMap&&(g=c.lightMap),void 0!==g&&(g.isWebGLRenderTarget&&(g=g.texture),!0===g.matrixAutoUpdate&&g.updateMatrix(),b.uv2Transform.value.copy(g.matrix))}function c(b,c){b.roughness.value=c.roughness,b.metalness.value=c.metalness,c.roughnessMap&&(b.roughnessMap.value=c.roughnessMap),c.metalnessMap&&(b.metalnessMap.value=c.metalnessMap),c.emissiveMap&&(b.emissiveMap.value=c.emissiveMap),c.bumpMap&&(b.bumpMap.value=c.bumpMap,b.bumpScale.value=c.bumpScale,c.side===g&&(b.bumpScale.value*=-1)),c.normalMap&&(b.normalMap.value=c.normalMap,b.normalScale.value.copy(c.normalScale),c.side===g&&b.normalScale.value.negate()),c.displacementMap&&(b.displacementMap.value=c.displacementMap,b.displacementScale.value=c.displacementScale,b.displacementBias.value=c.displacementBias);const d=a.get(c).envMap;d&&(b.envMapIntensity.value=c.envMapIntensity)}return{refreshFogUniforms:function(a,b){a.fogColor.value.copy(b.color),b.isFog?(a.fogNear.value=b.near,a.fogFar.value=b.far):b.isFogExp2&&(a.fogDensity.value=b.density)},refreshMaterialUniforms:function(a,d,e,f,h){var i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I;let J,K;d.isMeshBasicMaterial?b(a,d):d.isMeshLambertMaterial?(b(a,d),i=a,(j=d).emissiveMap&&(i.emissiveMap.value=j.emissiveMap)):d.isMeshToonMaterial?(b(a,d),k=a,(l=d).gradientMap&&(k.gradientMap.value=l.gradientMap),l.emissiveMap&&(k.emissiveMap.value=l.emissiveMap),l.bumpMap&&(k.bumpMap.value=l.bumpMap,k.bumpScale.value=l.bumpScale,l.side===g&&(k.bumpScale.value*=-1)),l.normalMap&&(k.normalMap.value=l.normalMap,k.normalScale.value.copy(l.normalScale),l.side===g&&k.normalScale.value.negate()),l.displacementMap&&(k.displacementMap.value=l.displacementMap,k.displacementScale.value=l.displacementScale,k.displacementBias.value=l.displacementBias)):d.isMeshPhongMaterial?(b(a,d),m=a,n=d,m.specular.value.copy(n.specular),m.shininess.value=Math.max(n.shininess,0.0001),n.emissiveMap&&(m.emissiveMap.value=n.emissiveMap),n.bumpMap&&(m.bumpMap.value=n.bumpMap,m.bumpScale.value=n.bumpScale,n.side===g&&(m.bumpScale.value*=-1)),n.normalMap&&(m.normalMap.value=n.normalMap,m.normalScale.value.copy(n.normalScale),n.side===g&&m.normalScale.value.negate()),n.displacementMap&&(m.displacementMap.value=n.displacementMap,m.displacementScale.value=n.displacementScale,m.displacementBias.value=n.displacementBias)):d.isMeshStandardMaterial?(b(a,d),d.isMeshPhysicalMaterial?(o=a,p=d,q=h,c(o,p),o.ior.value=p.ior,p.sheen>0&&(o.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),o.sheenRoughness.value=p.sheenRoughness,p.sheenColorMap&&(o.sheenColorMap.value=p.sheenColorMap),p.sheenRoughnessMap&&(o.sheenRoughnessMap.value=p.sheenRoughnessMap)),p.clearcoat>0&&(o.clearcoat.value=p.clearcoat,o.clearcoatRoughness.value=p.clearcoatRoughness,p.clearcoatMap&&(o.clearcoatMap.value=p.clearcoatMap),p.clearcoatRoughnessMap&&(o.clearcoatRoughnessMap.value=p.clearcoatRoughnessMap),p.clearcoatNormalMap&&(o.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),o.clearcoatNormalMap.value=p.clearcoatNormalMap,p.side===g&&o.clearcoatNormalScale.value.negate())),p.transmission>0&&(o.transmission.value=p.transmission,o.transmissionSamplerMap.value=q.texture,o.transmissionSamplerSize.value.set(q.width,q.height),p.transmissionMap&&(o.transmissionMap.value=p.transmissionMap),o.thickness.value=p.thickness,p.thicknessMap&&(o.thicknessMap.value=p.thicknessMap),o.attenuationDistance.value=p.attenuationDistance,o.attenuationColor.value.copy(p.attenuationColor)),o.specularIntensity.value=p.specularIntensity,o.specularColor.value.copy(p.specularColor),p.specularIntensityMap&&(o.specularIntensityMap.value=p.specularIntensityMap),p.specularColorMap&&(o.specularColorMap.value=p.specularColorMap)):c(a,d)):d.isMeshMatcapMaterial?(b(a,d),r=a,(s=d).matcap&&(r.matcap.value=s.matcap),s.bumpMap&&(r.bumpMap.value=s.bumpMap,r.bumpScale.value=s.bumpScale,s.side===g&&(r.bumpScale.value*=-1)),s.normalMap&&(r.normalMap.value=s.normalMap,r.normalScale.value.copy(s.normalScale),s.side===g&&r.normalScale.value.negate()),s.displacementMap&&(r.displacementMap.value=s.displacementMap,r.displacementScale.value=s.displacementScale,r.displacementBias.value=s.displacementBias)):d.isMeshDepthMaterial?(b(a,d),t=a,(u=d).displacementMap&&(t.displacementMap.value=u.displacementMap,t.displacementScale.value=u.displacementScale,t.displacementBias.value=u.displacementBias)):d.isMeshDistanceMaterial?(b(a,d),v=a,(w=d).displacementMap&&(v.displacementMap.value=w.displacementMap,v.displacementScale.value=w.displacementScale,v.displacementBias.value=w.displacementBias),v.referencePosition.value.copy(w.referencePosition),v.nearDistance.value=w.nearDistance,v.farDistance.value=w.farDistance):d.isMeshNormalMaterial?(b(a,d),x=a,(y=d).bumpMap&&(x.bumpMap.value=y.bumpMap,x.bumpScale.value=y.bumpScale,y.side===g&&(x.bumpScale.value*=-1)),y.normalMap&&(x.normalMap.value=y.normalMap,x.normalScale.value.copy(y.normalScale),y.side===g&&x.normalScale.value.negate()),y.displacementMap&&(x.displacementMap.value=y.displacementMap,x.displacementScale.value=y.displacementScale,x.displacementBias.value=y.displacementBias)):d.isLineBasicMaterial?(z=a,A=d,z.diffuse.value.copy(A.color),z.opacity.value=A.opacity,d.isLineDashedMaterial&&(B=a,C=d,B.dashSize.value=C.dashSize,B.totalSize.value=C.dashSize+C.gapSize,B.scale.value=C.scale)):d.isPointsMaterial?(D=a,E=d,F=e,G=f,D.diffuse.value.copy(E.color),D.opacity.value=E.opacity,D.size.value=E.size*F,D.scale.value=0.5*G,E.map&&(D.map.value=E.map),E.alphaMap&&(D.alphaMap.value=E.alphaMap),E.alphaTest>0&&(D.alphaTest.value=E.alphaTest),E.map?J=E.map:E.alphaMap&&(J=E.alphaMap),void 0!==J&&(!0===J.matrixAutoUpdate&&J.updateMatrix(),D.uvTransform.value.copy(J.matrix))):d.isSpriteMaterial?(H=a,I=d,H.diffuse.value.copy(I.color),H.opacity.value=I.opacity,H.rotation.value=I.rotation,I.map&&(H.map.value=I.map),I.alphaMap&&(H.alphaMap.value=I.alphaMap),I.alphaTest>0&&(H.alphaTest.value=I.alphaTest),I.map?K=I.map:I.alphaMap&&(K=I.alphaMap),void 0!==K&&(!0===K.matrixAutoUpdate&&K.updateMatrix(),H.uvTransform.value.copy(K.matrix))):d.isShadowMaterial?(a.color.value.copy(d.color),a.opacity.value=d.opacity):d.isShaderMaterial&&(d.uniformsNeedUpdate=!1)}}}function PR(a={}){const b=void 0!==a.canvas?a.canvas:function(){const a=yd("canvas");return a.style.display="block",a}(),c=void 0!==a.context?a.context:null,d=void 0!==a.alpha&&a.alpha,e=void 0===a.depth||a.depth,i=void 0===a.stencil||a.stencil,k=void 0!==a.antialias&&a.antialias,m=void 0===a.premultipliedAlpha||a.premultipliedAlpha,n=void 0!==a.preserveDrawingBuffer&&a.preserveDrawingBuffer,o=void 0!==a.powerPreference?a.powerPreference:"default",p=void 0!==a.failIfMajorPerformanceCaveat&&a.failIfMajorPerformanceCaveat;let r=null,s=null;const t=[],u=[];this.domElement=b,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=3000,this.physicallyCorrectLights=!1,this.toneMapping=0,this.toneMappingExposure=1;const v=this;let w=!1,x=0,y=0,z=null,A=-1,B=null;const C=new ae(),D=new ae();let E=null,F=b.width,G=b.height,H=1,I=null,J=null;const K=new ae(0,0,F,G),L=new ae(0,0,F,G);let M=!1;const N=[],O=new xK();let P=!1,Q=!1,R=null;const S=new dp(),T=new Qi(),U={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function V(){return null===z?H:1}let W=c;function X(a,c){for(let d=0;d<a.length;d++){const e=a[d],f=b.getContext(e,c);if(null!==f)return f}return null}try{const Y={alpha:d,depth:e,stencil:i,antialias:k,premultipliedAlpha:m,preserveDrawingBuffer:n,powerPreference:o,failIfMajorPerformanceCaveat:p};if(b.addEventListener("webglcontextlost",ya,!1),b.addEventListener("webglcontextrestored",za,!1),null===W){const Z=["webgl2","webgl","experimental-webgl"];if(!0===v.isWebGL1Renderer&&Z.shift(),W=X(Z,Y),null===W){if(X(Z))throw new Error("Error creating WebGL context with your selected attributes.");throw new Error("Error creating WebGL context.")}}void 0===W.getShaderPrecisionFormat&&(W.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch($){throw console.error("THREE.WebGLRenderer: "+$.message),$}let _,aa,ba,ca,da,ea,fa,ga,ha,ia,ja,ka,la,ma,na,oa,pa,qa,ra,sa,ta,ua,va;function wa(){_=new zO(W),aa=new dM(W,_,a),_.init(aa),ua=new FQ(W,_,aa),ba=new DQ(W,_,aa),N[0]=1029,ca=new CO(W),da=new lQ(),ea=new EQ(W,_,ba,da,aa,ua,ca),fa=new fM(v),ga=new yO(v),ha=new wL(W,aa),va=new bM(W,_,ha,aa),ia=new AO(W,ha,ca,va),ja=new MO(W,ia,ha,ca),ra=new LO(W,aa,ea),oa=new eM(da),ka=new kQ(v,fa,ga,_,aa,va,oa),la=new OR(da),ma=new pQ(da),na=new vQ(_,aa),qa=new aM(v,fa,ba,ja,m),pa=new CQ(v,ja,aa),sa=new cM(W,_,ca,aa),ta=new BO(W,_,ca,aa),ca.programs=ka.programs,v.capabilities=aa,v.extensions=_,v.properties=da,v.renderLists=ma,v.shadowMap=pa,v.state=ba,v.info=ca}wa();const xa=new dR(v,W);function ya(a){a.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),w=!0}function za(){console.log("THREE.WebGLRenderer: Context Restored."),w=!1;const a=ca.autoReset,b=pa.enabled,c=pa.autoUpdate,d=pa.needsUpdate,e=pa.type;wa(),ca.autoReset=a,pa.enabled=b,pa.autoUpdate=c,pa.needsUpdate=d,pa.type=e}function Aa(a){const b=a.target;b.removeEventListener("dispose",Aa),Ba(b)}function Ba(a){Ca(a),da.remove(a)}function Ca(a){const b=da.get(a).programs;void 0!==b&&b.forEach(function(a){ka.releaseProgram(a)})}this.xr=xa,this.getContext=function(){return W},this.getContextAttributes=function(){return W.getContextAttributes()},this.forceContextLoss=function(){const a=_.get("WEBGL_lose_context");a&&a.loseContext()},this.forceContextRestore=function(){const a=_.get("WEBGL_lose_context");a&&a.restoreContext()},this.getPixelRatio=function(){return H},this.setPixelRatio=function(a){void 0!==a&&(H=a,this.setSize(F,G,!1))},this.getSize=function(a){return a.set(F,G)},this.setSize=function(a,c,d){if(xa.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}F=a,G=c,b.width=Math.floor(a*H),b.height=Math.floor(c*H),!1!==d&&(b.style.width=a+"px",b.style.height=c+"px"),this.setViewport(0,0,a,c)},this.getDrawingBufferSize=function(a){return a.set(F*H,G*H).floor()},this.setDrawingBufferSize=function(a,c,d){F=a,G=c,H=d,b.width=Math.floor(a*d),b.height=Math.floor(c*d),this.setViewport(0,0,a,c)},this.getCurrentViewport=function(a){return a.copy(C)},this.getViewport=function(a){return a.copy(K)},this.setViewport=function(a,b,c,d){a.isVector4?K.set(a.x,a.y,a.z,a.w):K.set(a,b,c,d),ba.viewport(C.copy(K).multiplyScalar(H).floor())},this.getScissor=function(a){return a.copy(L)},this.setScissor=function(a,b,c,d){a.isVector4?L.set(a.x,a.y,a.z,a.w):L.set(a,b,c,d),ba.scissor(D.copy(L).multiplyScalar(H).floor())},this.getScissorTest=function(){return M},this.setScissorTest=function(a){ba.setScissorTest(M=a)},this.setOpaqueSort=function(a){I=a},this.setTransparentSort=function(a){J=a},this.getClearColor=function(a){return a.copy(qa.getClearColor())},this.setClearColor=function(){qa.setClearColor.apply(qa,arguments)},this.getClearAlpha=function(){return qa.getClearAlpha()},this.setClearAlpha=function(){qa.setClearAlpha.apply(qa,arguments)},this.clear=function(a,b,c){let d=0;(void 0===a||a)&&(d|=16384),(void 0===b||b)&&(d|=256),(void 0===c||c)&&(d|=1024),W.clear(d)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){b.removeEventListener("webglcontextlost",ya,!1),b.removeEventListener("webglcontextrestored",za,!1),ma.dispose(),na.dispose(),da.dispose(),fa.dispose(),ga.dispose(),ja.dispose(),va.dispose(),xa.dispose(),xa.removeEventListener("sessionstart",Ea),xa.removeEventListener("sessionend",Fa),R&&(R.dispose(),R=null),Ga.stop()},this.renderBufferDirect=function(a,b,c,d,e,f){null===b&&(b=U);const g=e.isMesh&&0>e.matrixWorld.determinant(),h=Oa(a,b,c,d,e);ba.setMaterial(d,g);let i=c.index;const j=c.attributes.position;if(null===i){if(void 0===j||0===j.count)return}else if(0===i.count)return;let k=1;!0===d.wireframe&&(i=ia.getWireframeAttribute(c),k=2),va.setup(e,d,h,c,i);let l,m=sa;null!==i&&(l=ha.get(i),(m=ta).setIndex(l));const n=null!==i?i.count:j.count,o=c.drawRange.start*k,p=c.drawRange.count*k,q=null!==f?f.start*k:0,r=null!==f?f.count*k:1/0,s=Math.max(o,q),t=Math.max(0,Math.min(n,o+p,q+r)-1-s+1);if(0!==t){if(e.isMesh)!0===d.wireframe?(ba.setLineWidth(d.wireframeLinewidth*V()),m.setMode(1)):m.setMode(4);else if(e.isLine){let u=d.linewidth;void 0===u&&(u=1),ba.setLineWidth(u*V()),e.isLineSegments?m.setMode(1):e.isLineLoop?m.setMode(2):m.setMode(3)}else e.isPoints?m.setMode(0):e.isSprite&&m.setMode(4);if(e.isInstancedMesh)m.renderInstances(s,t,e.count);else if(c.isInstancedBufferGeometry){const v=Math.min(c.instanceCount,c._maxInstanceCount);m.renderInstances(s,t,v)}else m.render(s,t)}},this.compile=function(a,b){(s=na.get(a)).init(),u.push(s),a.traverseVisible(function(a){a.isLight&&a.layers.test(b.layers)&&(s.pushLight(a),a.castShadow&&s.pushShadow(a))}),s.setupLights(v.physicallyCorrectLights),a.traverse(function(b){const c=b.material;if(c)if(Array.isArray(c))for(let d=0;d<c.length;d++){const e=c[d];Ma(e,a,b)}else Ma(c,a,b)}),u.pop(),s=null};let Da=null;function Ea(){Ga.stop()}function Fa(){Ga.start()}const Ga=new vL();function Ha(a,b,c,d){if(!1===a.visible)return;const e=a.layers.test(b.layers);if(e){if(a.isGroup)c=a.renderOrder;else if(a.isLOD)!0===a.autoUpdate&&a.update(b);else if(a.isLight)s.pushLight(a),a.castShadow&&s.pushShadow(a);else if(a.isSprite){if(!a.frustumCulled||O.intersectsSprite(a)){d&&T.setFromMatrixPosition(a.matrixWorld).applyMatrix4(S);const f=ja.update(a),g=a.material;g.visible&&r.push(a,f,g,c,T.z,null)}}else if((a.isMesh||a.isLine||a.isPoints)&&(a.isSkinnedMesh&&a.skeleton.frame!==ca.render.frame&&(a.skeleton.update(),a.skeleton.frame=ca.render.frame),!a.frustumCulled||O.intersectsObject(a))){d&&T.setFromMatrixPosition(a.matrixWorld).applyMatrix4(S);const h=ja.update(a),i=a.material;if(Array.isArray(i)){const j=h.groups;for(let k=0,l=j.length;k<l;k++){const m=j[k],n=i[m.materialIndex];n&&n.visible&&r.push(a,h,n,c,T.z,m)}}else i.visible&&r.push(a,h,i,c,T.z,null)}}const o=a.children;for(let p=0,q=o.length;p<q;p++)Ha(o[p],b,c,d)}function Ia(a,b,c,d){const e=a.opaque,f=a.transmissive,g=a.transparent;s.setupLightsView(c),f.length>0&&Ja(e,b,c),d&&ba.viewport(C.copy(d)),e.length>0&&Ka(e,b,c),f.length>0&&Ka(f,b,c),g.length>0&&Ka(g,b,c)}function Ja(a,b,c){if(null===R){const d=!0===k&& !0===aa.isWebGL2,e=d?eg:Kf;R=new e(1024,1024,{generateMipmaps:!0,type:null!==ua.convert(1016)?1016:1009,minFilter:q,magFilter:l,wrapS:j,wrapT:j})}const f=v.getRenderTarget();v.setRenderTarget(R),v.clear();const g=v.toneMapping;v.toneMapping=0,Ka(a,b,c),v.toneMapping=g,ea.updateMultisampleRenderTarget(R),ea.updateRenderTargetMipmap(R),v.setRenderTarget(f)}function Ka(a,b,c){const d=!0===b.isScene?b.overrideMaterial:null;for(let e=0,f=a.length;e<f;e++){const g=a[e],h=g.object,i=g.geometry,j=null===d?g.material:d,k=g.group;h.layers.test(c.layers)&&La(h,b,c,i,j,k)}}function La(a,b,c,d,e,i){a.onBeforeRender(v,b,c,d,e,i),a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse,a.matrixWorld),a.normalMatrix.getNormalMatrix(a.modelViewMatrix),e.onBeforeRender(v,b,c,d,a,i),!0===e.transparent&&e.side===h?(e.side=g,e.needsUpdate=!0,v.renderBufferDirect(c,b,d,e,a,i),e.side=f,e.needsUpdate=!0,v.renderBufferDirect(c,b,d,e,a,i),e.side=h):v.renderBufferDirect(c,b,d,e,a,i),a.onAfterRender(v,b,c,d,e,i)}function Ma(a,b,c){!0!==b.isScene&&(b=U);const d=da.get(a),e=s.state.lights,f=s.state.shadowsArray,g=e.state.version,h=ka.getParameters(a,e.state,f,b,c),i=ka.getProgramCacheKey(h);let j=d.programs;d.environment=a.isMeshStandardMaterial?b.environment:null,d.fog=b.fog,d.envMap=(a.isMeshStandardMaterial?ga:fa).get(a.envMap||d.environment),void 0===j&&(a.addEventListener("dispose",Aa),j=new Map(),d.programs=j);let k=j.get(i);if(void 0!==k){if(d.currentProgram===k&&d.lightsStateVersion===g)return Na(a,h),k}else h.uniforms=ka.getUniforms(a),a.onBuild(c,h,v),a.onBeforeCompile(h,v),k=ka.acquireProgram(h,i),j.set(i,k),d.uniforms=h.uniforms;const l=d.uniforms;(a.isShaderMaterial||a.isRawShaderMaterial)&& !0!==a.clipping||(l.clippingPlanes=oa.uniform),Na(a,h),d.needsLights=Qa(a),d.lightsStateVersion=g,d.needsLights&&(l.ambientLightColor.value=e.state.ambient,l.lightProbe.value=e.state.probe,l.directionalLights.value=e.state.directional,l.directionalLightShadows.value=e.state.directionalShadow,l.spotLights.value=e.state.spot,l.spotLightShadows.value=e.state.spotShadow,l.rectAreaLights.value=e.state.rectArea,l.ltc_1.value=e.state.rectAreaLTC1,l.ltc_2.value=e.state.rectAreaLTC2,l.pointLights.value=e.state.point,l.pointLightShadows.value=e.state.pointShadow,l.hemisphereLights.value=e.state.hemi,l.directionalShadowMap.value=e.state.directionalShadowMap,l.directionalShadowMatrix.value=e.state.directionalShadowMatrix,l.spotShadowMap.value=e.state.spotShadowMap,l.spotShadowMatrix.value=e.state.spotShadowMatrix,l.pointShadowMap.value=e.state.pointShadowMap,l.pointShadowMatrix.value=e.state.pointShadowMatrix);const m=k.getUniforms(),n=TP.seqWithValue(m.seq,l);return d.currentProgram=k,d.uniformsList=n,k}function Na(a,b){const c=da.get(a);c.outputEncoding=b.outputEncoding,c.instancing=b.instancing,c.skinning=b.skinning,c.morphTargets=b.morphTargets,c.morphNormals=b.morphNormals,c.morphTargetsCount=b.morphTargetsCount,c.numClippingPlanes=b.numClippingPlanes,c.numIntersection=b.numClipIntersection,c.vertexAlphas=b.vertexAlphas,c.vertexTangents=b.vertexTangents}function Oa(a,b,c,d,e){!0!==b.isScene&&(b=U),ea.resetTextureUnits();const f=b.fog,g=d.isMeshStandardMaterial?b.environment:null,h=null===z?v.outputEncoding:z.texture.encoding,i=(d.isMeshStandardMaterial?ga:fa).get(d.envMap||g),j=!0===d.vertexColors&&!!c.attributes.color&&4===c.attributes.color.itemSize,k=!!d.normalMap&&!!c.attributes.tangent,l=!!c.morphAttributes.position,m=!!c.morphAttributes.normal,n=c.morphAttributes.position?c.morphAttributes.position.length:0,o=da.get(d),p=s.state.lights;if(!0===P&&(!0===Q||a!==B)){const q=a===B&&d.id===A;oa.setState(d,a,q)}let r=!1;d.version===o.__version?o.needsLights&&o.lightsStateVersion!==p.state.version?r=!0:o.outputEncoding!==h?r=!0:e.isInstancedMesh&& !1===o.instancing?r=!0:e.isInstancedMesh|| !0!==o.instancing?e.isSkinnedMesh&& !1===o.skinning?r=!0:e.isSkinnedMesh|| !0!==o.skinning?o.envMap!==i?r=!0:d.fog&&o.fog!==f?r=!0:void 0!==o.numClippingPlanes&&(o.numClippingPlanes!==oa.numPlanes||o.numIntersection!==oa.numIntersection)?r=!0:o.vertexAlphas!==j?r=!0:o.vertexTangents!==k?r=!0:o.morphTargets!==l?r=!0:o.morphNormals!==m?r=!0:!0===aa.isWebGL2&&o.morphTargetsCount!==n&&(r=!0):r=!0:r=!0:(r=!0,o.__version=d.version);let t=o.currentProgram;!0===r&&(t=Ma(d,b,e));let u=!1,w=!1,x=!1;const y=t.getUniforms(),C=o.uniforms;if(ba.useProgram(t.program)&&(u=!0,w=!0,x=!0),d.id!==A&&(A=d.id,w=!0),u||B!==a){if(y.setValue(W,"projectionMatrix",a.projectionMatrix),aa.logarithmicDepthBuffer&&y.setValue(W,"logDepthBufFC",2/(Math.log(a.far+1)/Math.LN2)),B!==a&&(B=a,w=!0,x=!0),d.isShaderMaterial||d.isMeshPhongMaterial||d.isMeshToonMaterial||d.isMeshStandardMaterial||d.envMap){const D=y.map.cameraPosition;void 0!==D&&D.setValue(W,T.setFromMatrixPosition(a.matrixWorld))}(d.isMeshPhongMaterial||d.isMeshToonMaterial||d.isMeshLambertMaterial||d.isMeshBasicMaterial||d.isMeshStandardMaterial||d.isShaderMaterial)&&y.setValue(W,"isOrthographic",!0===a.isOrthographicCamera),(d.isMeshPhongMaterial||d.isMeshToonMaterial||d.isMeshLambertMaterial||d.isMeshBasicMaterial||d.isMeshStandardMaterial||d.isShaderMaterial||d.isShadowMaterial||e.isSkinnedMesh)&&y.setValue(W,"viewMatrix",a.matrixWorldInverse)}if(e.isSkinnedMesh){y.setOptional(W,e,"bindMatrix"),y.setOptional(W,e,"bindMatrixInverse");const E=e.skeleton;E&&(aa.floatVertexTextures?(null===E.boneTexture&&E.computeBoneTexture(),y.setValue(W,"boneTexture",E.boneTexture,ea),y.setValue(W,"boneTextureSize",E.boneTextureSize)):y.setOptional(W,E,"boneMatrices"))}return c&&(void 0!==c.morphAttributes.position|| void 0!==c.morphAttributes.normal)&&ra.update(e,c,d,t),(w||o.receiveShadow!==e.receiveShadow)&&(o.receiveShadow=e.receiveShadow,y.setValue(W,"receiveShadow",e.receiveShadow)),w&&(y.setValue(W,"toneMappingExposure",v.toneMappingExposure),o.needsLights&&Pa(C,x),f&&d.fog&&la.refreshFogUniforms(C,f),la.refreshMaterialUniforms(C,d,H,G,R),TP.upload(W,o.uniformsList,C,ea)),d.isShaderMaterial&& !0===d.uniformsNeedUpdate&&(TP.upload(W,o.uniformsList,C,ea),d.uniformsNeedUpdate=!1),d.isSpriteMaterial&&y.setValue(W,"center",e.center),y.setValue(W,"modelViewMatrix",e.modelViewMatrix),y.setValue(W,"normalMatrix",e.normalMatrix),y.setValue(W,"modelMatrix",e.matrixWorld),t}function Pa(a,b){a.ambientLightColor.needsUpdate=b,a.lightProbe.needsUpdate=b,a.directionalLights.needsUpdate=b,a.directionalLightShadows.needsUpdate=b,a.pointLights.needsUpdate=b,a.pointLightShadows.needsUpdate=b,a.spotLights.needsUpdate=b,a.spotLightShadows.needsUpdate=b,a.rectAreaLights.needsUpdate=b,a.hemisphereLights.needsUpdate=b}function Qa(a){return a.isMeshLambertMaterial||a.isMeshToonMaterial||a.isMeshPhongMaterial||a.isMeshStandardMaterial||a.isShadowMaterial||a.isShaderMaterial&& !0===a.lights}Ga.setAnimationLoop(function(a){Da&&Da(a)}),"undefined"!=typeof window&&Ga.setContext(window),this.setAnimationLoop=function(a){Da=a,xa.setAnimationLoop(a),null===a?Ga.stop():Ga.start()},xa.addEventListener("sessionstart",Ea),xa.addEventListener("sessionend",Fa),this.render=function(a,b){if(void 0!==b&& !0!==b.isCamera){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(!0===w)return;!0===a.autoUpdate&&a.updateMatrixWorld(),null===b.parent&&b.updateMatrixWorld(),!0===xa.enabled&& !0===xa.isPresenting&&(!0===xa.cameraAutoUpdate&&xa.updateCamera(b),b=xa.getCamera()),!0===a.isScene&&a.onBeforeRender(v,a,b,z),(s=na.get(a,u.length)).init(),u.push(s),S.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse),O.setFromProjectionMatrix(S),Q=this.localClippingEnabled,P=oa.init(this.clippingPlanes,Q,b),(r=ma.get(a,t.length)).init(),t.push(r),Ha(a,b,0,v.sortObjects),r.finish(),!0===v.sortObjects&&r.sort(I,J),!0===P&&oa.beginShadows();const c=s.state.shadowsArray;if(pa.render(c,a,b),!0===P&&oa.endShadows(),!0===this.info.autoReset&&this.info.reset(),qa.render(r,a),s.setupLights(v.physicallyCorrectLights),b.isArrayCamera){const d=b.cameras;for(let e=0,f=d.length;e<f;e++){const g=d[e];Ia(r,a,g,g.viewport)}}else Ia(r,a,b);null!==z&&(ea.updateMultisampleRenderTarget(z),ea.updateRenderTargetMipmap(z)),!0===a.isScene&&a.onAfterRender(v,a,b),ba.buffers.depth.setTest(!0),ba.buffers.depth.setMask(!0),ba.buffers.color.setMask(!0),ba.setPolygonOffset(!1),va.resetDefaultState(),A=-1,B=null,u.pop(),s=u.length>0?u[u.length-1]:null,t.pop(),r=t.length>0?t[t.length-1]:null},this.getActiveCubeFace=function(){return x},this.getActiveMipmapLevel=function(){return y},this.getRenderTarget=function(){return z},this.setRenderTarget=function(a,b=0,c=0){z=a,x=b,y=c,a&& void 0===da.get(a).__webglFramebuffer&&ea.setupRenderTarget(a);let d=null,e=!1,f=!1;if(a){const g=a.texture;(g.isDataTexture3D||g.isDataTexture2DArray)&&(f=!0);const h=da.get(a).__webglFramebuffer;a.isWebGLCubeRenderTarget?(d=h[b],e=!0):d=a.isWebGLMultisampleRenderTarget?da.get(a).__webglMultisampledFramebuffer:h,C.copy(a.viewport),D.copy(a.scissor),E=a.scissorTest}else C.copy(K).multiplyScalar(H).floor(),D.copy(L).multiplyScalar(H).floor(),E=M;const i=ba.bindFramebuffer(36160,d);if(i&&aa.drawBuffers){let j=!1;if(a)if(a.isWebGLMultipleRenderTargets){const k=a.texture;if(N.length!==k.length||36064!==N[0]){for(let l=0,m=k.length;l<m;l++)N[l]=36064+l;N.length=k.length,j=!0}}else(1!==N.length||36064!==N[0])&&(N[0]=36064,N.length=1,j=!0);else(1!==N.length||1029!==N[0])&&(N[0]=1029,N.length=1,j=!0);j&&(aa.isWebGL2?W.drawBuffers(N):_.get("WEBGL_draw_buffers").drawBuffersWEBGL(N))}if(ba.viewport(C),ba.scissor(D),ba.setScissorTest(E),e){const n=da.get(a.texture);W.framebufferTexture2D(36160,36064,34069+b,n.__webglTexture,c)}else if(f){const o=da.get(a.texture),p=b||0;W.framebufferTextureLayer(36160,36064,o.__webglTexture,c||0,p)}A=-1},this.readRenderTargetPixels=function(a,b,c,d,e,f,g){if(!(a&&a.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let h=da.get(a).__webglFramebuffer;if(a.isWebGLCubeRenderTarget&& void 0!==g&&(h=h[g]),h){ba.bindFramebuffer(36160,h);try{const i=a.texture,j=i.format,k=i.type;if(1023!==j&&ua.convert(j)!==W.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const l=1016===k&&(_.has("EXT_color_buffer_half_float")||aa.isWebGL2&&_.has("EXT_color_buffer_float"));if(1009!==k&&ua.convert(k)!==W.getParameter(35738)&&!(1015===k&&(aa.isWebGL2||_.has("OES_texture_float")||_.has("WEBGL_color_buffer_float")))&&!l){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}36053===W.checkFramebufferStatus(36160)?b>=0&&b<=a.width-d&&c>=0&&c<=a.height-e&&W.readPixels(b,c,d,e,ua.convert(j),ua.convert(k),f):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const m=null!==z?da.get(z).__webglFramebuffer:null;ba.bindFramebuffer(36160,m)}}},this.copyFramebufferToTexture=function(a,b,c=0){const d=Math.pow(2,-c),e=Math.floor(b.image.width*d),f=Math.floor(b.image.height*d);let g=ua.convert(b.format);aa.isWebGL2&&(6407===g&&(g=32849),6408===g&&(g=32856)),ea.setTexture2D(b,0),W.copyTexImage2D(3553,c,g,a.x,a.y,e,f,0),ba.unbindTexture()},this.copyTextureToTexture=function(a,b,c,d=0){const e=b.image.width,f=b.image.height,g=ua.convert(c.format),h=ua.convert(c.type);ea.setTexture2D(c,0),W.pixelStorei(37440,c.flipY),W.pixelStorei(37441,c.premultiplyAlpha),W.pixelStorei(3317,c.unpackAlignment),b.isDataTexture?W.texSubImage2D(3553,d,a.x,a.y,e,f,g,h,b.image.data):b.isCompressedTexture?W.compressedTexSubImage2D(3553,d,a.x,a.y,b.mipmaps[0].width,b.mipmaps[0].height,g,b.mipmaps[0].data):W.texSubImage2D(3553,d,a.x,a.y,g,h,b.image),0===d&&c.generateMipmaps&&W.generateMipmap(3553),ba.unbindTexture()},this.copyTextureToTexture3D=function(a,b,c,d,e=0){if(v.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const f=a.max.x-a.min.x+1,g=a.max.y-a.min.y+1,h=a.max.z-a.min.z+1,i=ua.convert(d.format),j=ua.convert(d.type);let k;if(d.isDataTexture3D)ea.setTexture3D(d,0),k=32879;else if(d.isDataTexture2DArray)ea.setTexture2DArray(d,0),k=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}W.pixelStorei(37440,d.flipY),W.pixelStorei(37441,d.premultiplyAlpha),W.pixelStorei(3317,d.unpackAlignment);const l=W.getParameter(3314),m=W.getParameter(32878),n=W.getParameter(3316),o=W.getParameter(3315),p=W.getParameter(32877),q=c.isCompressedTexture?c.mipmaps[0]:c.image;W.pixelStorei(3314,q.width),W.pixelStorei(32878,q.height),W.pixelStorei(3316,a.min.x),W.pixelStorei(3315,a.min.y),W.pixelStorei(32877,a.min.z),c.isDataTexture||c.isDataTexture3D?W.texSubImage3D(k,e,b.x,b.y,b.z,f,g,h,i,j,q.data):c.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),W.compressedTexSubImage3D(k,e,b.x,b.y,b.z,f,g,h,i,q.data)):W.texSubImage3D(k,e,b.x,b.y,b.z,f,g,h,i,j,q),W.pixelStorei(3314,l),W.pixelStorei(32878,m),W.pixelStorei(3316,n),W.pixelStorei(3315,o),W.pixelStorei(32877,p),0===e&&d.generateMipmaps&&W.generateMipmap(k),ba.unbindTexture()},this.initTexture=function(a){ea.setTexture2D(a,0),ba.unbindTexture()},this.resetState=function(){x=0,y=0,z=null,ba.reset(),va.reset()},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}PR.prototype.isWebGLRenderer=!0,(class extends PR{}).prototype.isWebGL1Renderer=!0;class QR{constructor(RR,SR=0.00025){this.name="",this.color=new oz(RR),this.density=SR}clone(){return new QR(this.color,this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}QR.prototype.isFogExp2=!0;class TR{constructor(UR,VR=1,WR=1000){this.name="",this.color=new oz(UR),this.near=VR,this.far=WR}clone(){return new TR(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}TR.prototype.isFog=!0;class XR extends hv{constructor(){super(),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(YR,ZR){return super.copy(YR,ZR),null!==YR.background&&(this.background=YR.background.clone()),null!==YR.environment&&(this.environment=YR.environment.clone()),null!==YR.fog&&(this.fog=YR.fog.clone()),null!==YR.overrideMaterial&&(this.overrideMaterial=YR.overrideMaterial.clone()),this.autoUpdate=YR.autoUpdate,this.matrixAutoUpdate=YR.matrixAutoUpdate,this}toJSON($R){const _R=super.toJSON($R);return null!==this.fog&&(_R.object.fog=this.fog.toJSON()),_R}}XR.prototype.isScene=!0;class aS{constructor(bS,cS){this.array=bS,this.stride=cS,this.count=void 0!==bS?bS.length/cS:0,this.usage=35044,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=X()}onUploadCallback(){}set needsUpdate(dS){!0===dS&&this.version++}setUsage(eS){return this.usage=eS,this}copy(fS){return this.array=new fS.array.constructor(fS.array),this.count=fS.count,this.stride=fS.stride,this.usage=fS.usage,this}copyAt(gS,hS,iS){gS*=this.stride,iS*=hS.stride;for(let jS=0,kS=this.stride;jS<kS;jS++)this.array[gS+jS]=hS.array[iS+jS];return this}set(lS,mS=0){return this.array.set(lS,mS),this}clone(nS){void 0===nS.arrayBuffers&&(nS.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=X()),void 0===nS.arrayBuffers[this.array.buffer._uuid]&&(nS.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const oS=new this.array.constructor(nS.arrayBuffers[this.array.buffer._uuid]),pS=new this.constructor(oS,this.stride);return pS.setUsage(this.usage),pS}onUpload(qS){return this.onUploadCallback=qS,this}toJSON(rS){return void 0===rS.arrayBuffers&&(rS.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=X()),void 0===rS.arrayBuffers[this.array.buffer._uuid]&&(rS.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}aS.prototype.isInterleavedBuffer=!0;const sS=new Qi();class tS{constructor(uS,vS,wS,xS=!1){this.name="",this.data=uS,this.itemSize=vS,this.offset=wS,this.normalized=!0===xS}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(yS){this.data.needsUpdate=yS}applyMatrix4(zS){for(let AS=0,BS=this.data.count;AS<BS;AS++)sS.x=this.getX(AS),sS.y=this.getY(AS),sS.z=this.getZ(AS),sS.applyMatrix4(zS),this.setXYZ(AS,sS.x,sS.y,sS.z);return this}applyNormalMatrix(CS){for(let DS=0,ES=this.count;DS<ES;DS++)sS.x=this.getX(DS),sS.y=this.getY(DS),sS.z=this.getZ(DS),sS.applyNormalMatrix(CS),this.setXYZ(DS,sS.x,sS.y,sS.z);return this}transformDirection(FS){for(let GS=0,HS=this.count;GS<HS;GS++)sS.x=this.getX(GS),sS.y=this.getY(GS),sS.z=this.getZ(GS),sS.transformDirection(FS),this.setXYZ(GS,sS.x,sS.y,sS.z);return this}setX(IS,JS){return this.data.array[IS*this.data.stride+this.offset]=JS,this}setY(KS,LS){return this.data.array[KS*this.data.stride+this.offset+1]=LS,this}setZ(MS,NS){return this.data.array[MS*this.data.stride+this.offset+2]=NS,this}setW(OS,PS){return this.data.array[OS*this.data.stride+this.offset+3]=PS,this}getX(QS){return this.data.array[QS*this.data.stride+this.offset]}getY(RS){return this.data.array[RS*this.data.stride+this.offset+1]}getZ(SS){return this.data.array[SS*this.data.stride+this.offset+2]}getW(TS){return this.data.array[TS*this.data.stride+this.offset+3]}setXY(US,VS,WS){return US=US*this.data.stride+this.offset,this.data.array[US+0]=VS,this.data.array[US+1]=WS,this}setXYZ(XS,YS,ZS,$S){return XS=XS*this.data.stride+this.offset,this.data.array[XS+0]=YS,this.data.array[XS+1]=ZS,this.data.array[XS+2]=$S,this}setXYZW(_S,aT,bT,cT,dT){return _S=_S*this.data.stride+this.offset,this.data.array[_S+0]=aT,this.data.array[_S+1]=bT,this.data.array[_S+2]=cT,this.data.array[_S+3]=dT,this}clone(eT){if(void 0!==eT)return void 0===eT.interleavedBuffers&&(eT.interleavedBuffers={}),void 0===eT.interleavedBuffers[this.data.uuid]&&(eT.interleavedBuffers[this.data.uuid]=this.data.clone(eT)),new tS(eT.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized);{console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const fT=[];for(let gT=0;gT<this.count;gT++){const hT=gT*this.data.stride+this.offset;for(let iT=0;iT<this.itemSize;iT++)fT.push(this.data.array[hT+iT])}return new OA(new this.array.constructor(fT),this.itemSize,this.normalized)}}toJSON(jT){if(void 0!==jT)return void 0===jT.interleavedBuffers&&(jT.interleavedBuffers={}),void 0===jT.interleavedBuffers[this.data.uuid]&&(jT.interleavedBuffers[this.data.uuid]=this.data.toJSON(jT)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized};{console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const kT=[];for(let lT=0;lT<this.count;lT++){const mT=lT*this.data.stride+this.offset;for(let nT=0;nT<this.itemSize;nT++)kT.push(this.data.array[mT+nT])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:kT,normalized:this.normalized}}}}tS.prototype.isInterleavedBufferAttribute=!0;class oT extends Sy{constructor(pT){super(),this.type="SpriteMaterial",this.color=new oz(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(pT)}copy(qT){return super.copy(qT),this.color.copy(qT.color),this.map=qT.map,this.alphaMap=qT.alphaMap,this.rotation=qT.rotation,this.sizeAttenuation=qT.sizeAttenuation,this}}oT.prototype.isSpriteMaterial=!0;let rT;const sT=new Qi(),tT=new Qi(),uT=new Qi(),vT=new da(),wT=new da(),xT=new dp(),yT=new Qi(),zT=new Qi(),AT=new Qi(),BT=new da(),CT=new da(),DT=new da();function ET(a,b,c,d,e,f){vT.subVectors(a,c).addScalar(0.5).multiply(d),void 0!==e?(wT.x=f*vT.x-e*vT.y,wT.y=e*vT.x+f*vT.y):wT.copy(vT),a.copy(b),a.x+=wT.x,a.y+=wT.y,a.applyMatrix4(xT)}(class extends hv{constructor(FT){if(super(),this.type="Sprite",void 0===rT){rT=new HC();const GT=new Float32Array([-0.5,-0.5,0,0,0,0.5,-0.5,0,1,0,0.5,0.5,0,1,1,-0.5,0.5,0,0,1]),HT=new aS(GT,5);rT.setIndex([0,1,2,0,2,3]),rT.setAttribute("position",new tS(HT,3,0,!1)),rT.setAttribute("uv",new tS(HT,2,3,!1))}this.geometry=rT,this.material=void 0!==FT?FT:new oT(),this.center=new da(0.5,0.5)}raycast(IT,JT){null===IT.camera&&console.error("THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites."),tT.setFromMatrixScale(this.matrixWorld),xT.copy(IT.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(IT.camera.matrixWorldInverse,this.matrixWorld),uT.setFromMatrixPosition(this.modelViewMatrix),IT.camera.isPerspectiveCamera&& !1===this.material.sizeAttenuation&&tT.multiplyScalar(-uT.z);const KT=this.material.rotation;let LT,MT;0!==KT&&(MT=Math.cos(KT),LT=Math.sin(KT));const NT=this.center;ET(yT.set(-0.5,-0.5,0),uT,NT,tT,LT,MT),ET(zT.set(0.5,-0.5,0),uT,NT,tT,LT,MT),ET(AT.set(0.5,0.5,0),uT,NT,tT,LT,MT),BT.set(0,0),CT.set(1,0),DT.set(1,1);let OT=IT.ray.intersectTriangle(yT,zT,AT,!1,sT);if(null===OT&&(ET(zT.set(-0.5,0.5,0),uT,NT,tT,LT,MT),CT.set(0,1),null===(OT=IT.ray.intersectTriangle(yT,AT,zT,!1,sT))))return;const PT=IT.ray.origin.distanceTo(sT);PT<IT.near||PT>IT.far||JT.push({distance:PT,point:sT.clone(),uv:px.getUV(sT,yT,zT,AT,BT,CT,DT,new da()),face:null,object:this})}copy(QT){return super.copy(QT),void 0!==QT.center&&this.center.copy(QT.center),this.material=QT.material,this}}).prototype.isSprite=!0,new Qi(),new Qi();const RT=new Qi(),ST=new ae(),TT=new ae(),UT=new Qi(),VT=new dp();class WT extends qG{constructor(XT,YT){super(XT,YT),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new dp(),this.bindMatrixInverse=new dp()}copy(ZT){return super.copy(ZT),this.bindMode=ZT.bindMode,this.bindMatrix.copy(ZT.bindMatrix),this.bindMatrixInverse.copy(ZT.bindMatrixInverse),this.skeleton=ZT.skeleton,this}bind($T,_T){this.skeleton=$T,void 0===_T&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),_T=this.matrixWorld),this.bindMatrix.copy(_T),this.bindMatrixInverse.copy(_T).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const aU=new ae(),bU=this.geometry.attributes.skinWeight;for(let cU=0,dU=bU.count;cU<dU;cU++){aU.x=bU.getX(cU),aU.y=bU.getY(cU),aU.z=bU.getZ(cU),aU.w=bU.getW(cU);const eU=1/aU.manhattanLength();eU!==1/0?aU.multiplyScalar(eU):aU.set(1,0,0,0),bU.setXYZW(cU,aU.x,aU.y,aU.z,aU.w)}}updateMatrixWorld(fU){super.updateMatrixWorld(fU),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(gU,hU){const iU=this.skeleton,jU=this.geometry;ST.fromBufferAttribute(jU.attributes.skinIndex,gU),TT.fromBufferAttribute(jU.attributes.skinWeight,gU),RT.copy(hU).applyMatrix4(this.bindMatrix),hU.set(0,0,0);for(let kU=0;kU<4;kU++){const lU=TT.getComponent(kU);if(0!==lU){const mU=ST.getComponent(kU);VT.multiplyMatrices(iU.bones[mU].matrixWorld,iU.boneInverses[mU]),hU.addScaledVector(UT.copy(RT).applyMatrix4(VT),lU)}}return hU.applyMatrix4(this.bindMatrixInverse)}}WT.prototype.isSkinnedMesh=!0;class nU extends hv{constructor(){super(),this.type="Bone"}}nU.prototype.isBone=!0;class oU extends Gd{constructor(pU=null,qU=1,rU=1,sU,tU,uU,vU,wU,xU=l,yU=l,zU,AU){super(null,uU,vU,wU,xU,yU,sU,tU,zU,AU),this.image={data:pU,width:qU,height:rU},this.magFilter=xU,this.minFilter=yU,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}oU.prototype.isDataTexture=!0;const BU=new dp(),CU=new dp();class DU{constructor(EU=[],FU=[]){this.uuid=X(),this.bones=EU.slice(0),this.boneInverses=FU,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const GU=this.bones,HU=this.boneInverses;if(this.boneMatrices=new Float32Array(16*GU.length),0===HU.length)this.calculateInverses();else if(GU.length!==HU.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let IU=0,JU=this.bones.length;IU<JU;IU++)this.boneInverses.push(new dp())}}calculateInverses(){this.boneInverses.length=0;for(let KU=0,LU=this.bones.length;KU<LU;KU++){const MU=new dp();this.bones[KU]&&MU.copy(this.bones[KU].matrixWorld).invert(),this.boneInverses.push(MU)}}pose(){for(let NU=0,OU=this.bones.length;NU<OU;NU++){const PU=this.bones[NU];PU&&PU.matrixWorld.copy(this.boneInverses[NU]).invert()}for(let QU=0,RU=this.bones.length;QU<RU;QU++){const SU=this.bones[QU];SU&&(SU.parent&&SU.parent.isBone?(SU.matrix.copy(SU.parent.matrixWorld).invert(),SU.matrix.multiply(SU.matrixWorld)):SU.matrix.copy(SU.matrixWorld),SU.matrix.decompose(SU.position,SU.quaternion,SU.scale))}}update(){const TU=this.bones,UU=this.boneInverses,VU=this.boneMatrices,WU=this.boneTexture;for(let XU=0,YU=TU.length;XU<YU;XU++){const ZU=TU[XU]?TU[XU].matrixWorld:CU;BU.multiplyMatrices(ZU,UU[XU]),BU.toArray(VU,16*XU)}null!==WU&&(WU.needsUpdate=!0)}clone(){return new DU(this.bones,this.boneInverses)}computeBoneTexture(){let $U=Math.sqrt(4*this.bones.length);$U=Math.max($U=aa($U),4);const _U=new Float32Array($U*$U*4);_U.set(this.boneMatrices);const aV=new oU(_U,$U,$U,1023,1015);return this.boneMatrices=_U,this.boneTexture=aV,this.boneTextureSize=$U,this}getBoneByName(bV){for(let cV=0,dV=this.bones.length;cV<dV;cV++){const eV=this.bones[cV];if(eV.name===bV)return eV}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(fV,gV){this.uuid=fV.uuid;for(let hV=0,iV=fV.bones.length;hV<iV;hV++){const jV=fV.bones[hV];let kV=gV[jV];void 0===kV&&(console.warn("THREE.Skeleton: No bone found with UUID:",jV),kV=new nU()),this.bones.push(kV),this.boneInverses.push(new dp().fromArray(fV.boneInverses[hV]))}return this.init(),this}toJSON(){const lV={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};lV.uuid=this.uuid;const mV=this.bones,nV=this.boneInverses;for(let oV=0,pV=mV.length;oV<pV;oV++){const qV=mV[oV];lV.bones.push(qV.uuid);const rV=nV[oV];lV.boneInverses.push(rV.toArray())}return lV}}class sV extends OA{constructor(tV,uV,vV,wV=1){"number"==typeof vV&&(wV=vV,vV=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(tV,uV,vV),this.meshPerAttribute=wV}copy(xV){return super.copy(xV),this.meshPerAttribute=xV.meshPerAttribute,this}toJSON(){const yV=super.toJSON();return yV.meshPerAttribute=this.meshPerAttribute,yV.isInstancedBufferAttribute=!0,yV}}sV.prototype.isInstancedBufferAttribute=!0;const zV=new dp(),AV=new dp(),BV=[],CV=new qG();(class extends qG{constructor(DV,EV,FV){super(DV,EV),this.instanceMatrix=new sV(new Float32Array(16*FV),16),this.instanceColor=null,this.count=FV,this.frustumCulled=!1}copy(GV){return super.copy(GV),this.instanceMatrix.copy(GV.instanceMatrix),null!==GV.instanceColor&&(this.instanceColor=GV.instanceColor.clone()),this.count=GV.count,this}getColorAt(HV,IV){IV.fromArray(this.instanceColor.array,3*HV)}getMatrixAt(JV,KV){KV.fromArray(this.instanceMatrix.array,16*JV)}raycast(LV,MV){const NV=this.matrixWorld,OV=this.count;if(CV.geometry=this.geometry,CV.material=this.material,void 0!==CV.material)for(let PV=0;PV<OV;PV++){this.getMatrixAt(PV,zV),AV.multiplyMatrices(NV,zV),CV.matrixWorld=AV,CV.raycast(LV,BV);for(let QV=0,RV=BV.length;QV<RV;QV++){const SV=BV[QV];SV.instanceId=PV,SV.object=this,MV.push(SV)}BV.length=0}}setColorAt(TV,UV){null===this.instanceColor&&(this.instanceColor=new sV(new Float32Array(3*this.instanceMatrix.count),3)),UV.toArray(this.instanceColor.array,3*TV)}setMatrixAt(VV,WV){WV.toArray(this.instanceMatrix.array,16*VV)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}).prototype.isInstancedMesh=!0;class XV extends Sy{constructor(YV){super(),this.type="LineBasicMaterial",this.color=new oz(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(YV)}copy(ZV){return super.copy(ZV),this.color.copy(ZV.color),this.linewidth=ZV.linewidth,this.linecap=ZV.linecap,this.linejoin=ZV.linejoin,this}}XV.prototype.isLineBasicMaterial=!0;const $V=new Qi(),_V=new Qi(),aW=new dp(),bW=new Kn(),cW=new $m();class dW extends hv{constructor(eW=new HC(),fW=new XV()){super(),this.type="Line",this.geometry=eW,this.material=fW,this.updateMorphTargets()}copy(gW){return super.copy(gW),this.material=gW.material,this.geometry=gW.geometry,this}computeLineDistances(){const hW=this.geometry;if(hW.isBufferGeometry)if(null===hW.index){const iW=hW.attributes.position,jW=[0];for(let kW=1,lW=iW.count;kW<lW;kW++)$V.fromBufferAttribute(iW,kW-1),_V.fromBufferAttribute(iW,kW),jW[kW]=jW[kW-1],jW[kW]+=$V.distanceTo(_V);hW.setAttribute("lineDistance",new wC(jW,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else hW.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(mW,nW){const oW=this.geometry,pW=this.matrixWorld,qW=mW.params.Line.threshold,rW=oW.drawRange;if(null===oW.boundingSphere&&oW.computeBoundingSphere(),cW.copy(oW.boundingSphere),cW.applyMatrix4(pW),cW.radius+=qW,!1===mW.ray.intersectsSphere(cW))return;aW.copy(pW).invert(),bW.copy(mW.ray).applyMatrix4(aW);const sW=qW/((this.scale.x+this.scale.y+this.scale.z)/3),tW=sW*sW,uW=new Qi(),vW=new Qi(),wW=new Qi(),xW=new Qi(),yW=this.isLineSegments?2:1;if(oW.isBufferGeometry){const zW=oW.index,AW=oW.attributes,BW=AW.position;if(null!==zW){const CW=Math.max(0,rW.start),DW=Math.min(zW.count,rW.start+rW.count);for(let EW=CW,FW=DW-1;EW<FW;EW+=yW){const GW=zW.getX(EW),HW=zW.getX(EW+1);uW.fromBufferAttribute(BW,GW),vW.fromBufferAttribute(BW,HW);const IW=bW.distanceSqToSegment(uW,vW,xW,wW);if(IW>tW)continue;xW.applyMatrix4(this.matrixWorld);const JW=mW.ray.origin.distanceTo(xW);JW<mW.near||JW>mW.far||nW.push({distance:JW,point:wW.clone().applyMatrix4(this.matrixWorld),index:EW,face:null,faceIndex:null,object:this})}}else{const KW=Math.max(0,rW.start),LW=Math.min(BW.count,rW.start+rW.count);for(let MW=KW,NW=LW-1;MW<NW;MW+=yW){uW.fromBufferAttribute(BW,MW),vW.fromBufferAttribute(BW,MW+1);const OW=bW.distanceSqToSegment(uW,vW,xW,wW);if(OW>tW)continue;xW.applyMatrix4(this.matrixWorld);const PW=mW.ray.origin.distanceTo(xW);PW<mW.near||PW>mW.far||nW.push({distance:PW,point:wW.clone().applyMatrix4(this.matrixWorld),index:MW,face:null,faceIndex:null,object:this})}}}else oW.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const QW=this.geometry;if(QW.isBufferGeometry){const RW=QW.morphAttributes,SW=Object.keys(RW);if(SW.length>0){const TW=RW[SW[0]];if(void 0!==TW){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let UW=0,VW=TW.length;UW<VW;UW++){const WW=TW[UW].name||String(UW);this.morphTargetInfluences.push(0),this.morphTargetDictionary[WW]=UW}}}}else{const XW=QW.morphTargets;void 0!==XW&&XW.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}dW.prototype.isLine=!0;const YW=new Qi(),ZW=new Qi();class $W extends dW{constructor(_W,aX){super(_W,aX),this.type="LineSegments"}computeLineDistances(){const bX=this.geometry;if(bX.isBufferGeometry)if(null===bX.index){const cX=bX.attributes.position,dX=[];for(let eX=0,fX=cX.count;eX<fX;eX+=2)YW.fromBufferAttribute(cX,eX),ZW.fromBufferAttribute(cX,eX+1),dX[eX]=0===eX?0:dX[eX-1],dX[eX+1]=dX[eX]+YW.distanceTo(ZW);bX.setAttribute("lineDistance",new wC(dX,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else bX.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}$W.prototype.isLineSegments=!0;class gX extends dW{constructor(hX,iX){super(hX,iX),this.type="LineLoop"}}gX.prototype.isLineLoop=!0;class jX extends Sy{constructor(kX){super(),this.type="PointsMaterial",this.color=new oz(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(kX)}copy(lX){return super.copy(lX),this.color.copy(lX.color),this.map=lX.map,this.alphaMap=lX.alphaMap,this.size=lX.size,this.sizeAttenuation=lX.sizeAttenuation,this}}jX.prototype.isPointsMaterial=!0;const mX=new dp(),nX=new Kn(),oX=new $m(),pX=new Qi();class qX extends hv{constructor(rX=new HC(),sX=new jX()){super(),this.type="Points",this.geometry=rX,this.material=sX,this.updateMorphTargets()}copy(tX){return super.copy(tX),this.material=tX.material,this.geometry=tX.geometry,this}raycast(uX,vX){const wX=this.geometry,xX=this.matrixWorld,yX=uX.params.Points.threshold,zX=wX.drawRange;if(null===wX.boundingSphere&&wX.computeBoundingSphere(),oX.copy(wX.boundingSphere),oX.applyMatrix4(xX),oX.radius+=yX,!1===uX.ray.intersectsSphere(oX))return;mX.copy(xX).invert(),nX.copy(uX.ray).applyMatrix4(mX);const AX=yX/((this.scale.x+this.scale.y+this.scale.z)/3),BX=AX*AX;if(wX.isBufferGeometry){const CX=wX.index,DX=wX.attributes,EX=DX.position;if(null!==CX){const FX=Math.max(0,zX.start),GX=Math.min(CX.count,zX.start+zX.count);for(let HX=FX,IX=GX;HX<IX;HX++){const JX=CX.getX(HX);pX.fromBufferAttribute(EX,JX),WX(pX,JX,BX,xX,uX,vX,this)}}else{const KX=Math.max(0,zX.start),LX=Math.min(EX.count,zX.start+zX.count);for(let MX=KX,NX=LX;MX<NX;MX++)pX.fromBufferAttribute(EX,MX),WX(pX,MX,BX,xX,uX,vX,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const OX=this.geometry;if(OX.isBufferGeometry){const PX=OX.morphAttributes,QX=Object.keys(PX);if(QX.length>0){const RX=PX[QX[0]];if(void 0!==RX){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let SX=0,TX=RX.length;SX<TX;SX++){const UX=RX[SX].name||String(SX);this.morphTargetInfluences.push(0),this.morphTargetDictionary[UX]=SX}}}}else{const VX=OX.morphTargets;void 0!==VX&&VX.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}function WX(a,b,c,d,e,f,g){const h=nX.distanceSqToPoint(a);if(h<c){const i=new Qi();nX.closestPointToPoint(a,i),i.applyMatrix4(d);const j=e.ray.origin.distanceTo(i);if(j<e.near||j>e.far)return;f.push({distance:j,distanceToRay:Math.sqrt(h),point:i,index:b,face:null,object:g})}}qX.prototype.isPoints=!0,(class extends Gd{constructor(XX,YX,ZX,$X,_X,aY,bY,cY,dY){super(XX,YX,ZX,$X,_X,aY,bY,cY,dY),this.format=void 0!==bY?bY:r,this.minFilter=void 0!==aY?aY:o,this.magFilter=void 0!==_X?_X:o,this.generateMipmaps=!1;const eY=this;function fY(){eY.needsUpdate=!0,XX.requestVideoFrameCallback(fY)}"requestVideoFrameCallback"in XX&&XX.requestVideoFrameCallback(fY)}clone(){return new this.constructor(this.image).copy(this)}update(){const gY=this.image;!1=="requestVideoFrameCallback"in gY&&gY.readyState>=gY.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}).prototype.isVideoTexture=!0,(class extends Gd{constructor(hY,iY,jY,kY,lY,mY,nY,oY,pY,qY,rY,sY){super(null,mY,nY,oY,pY,qY,kY,lY,rY,sY),this.image={width:iY,height:jY},this.mipmaps=hY,this.flipY=!1,this.generateMipmaps=!1}}).prototype.isCompressedTexture=!0,(class extends Gd{constructor(tY,uY,vY,wY,xY,yY,zY,AY,BY){super(tY,uY,vY,wY,xY,yY,zY,AY,BY),this.needsUpdate=!0}}).prototype.isCanvasTexture=!0,(class extends Gd{constructor(CY,DY,EY,FY,GY,HY,IY,JY,KY,LY){if(1026!==(LY=void 0!==LY?LY:1026)&&1027!==LY)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===EY&&1026===LY&&(EY=1012),void 0===EY&&1027===LY&&(EY=1020),super(null,FY,GY,HY,IY,JY,LY,EY,KY),this.image={width:CY,height:DY},this.magFilter=void 0!==IY?IY:l,this.minFilter=void 0!==JY?JY:l,this.flipY=!1,this.generateMipmaps=!1}}).prototype.isDepthTexture=!0;class MY extends HC{constructor(NY=1,OY=8,PY=0,QY=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:NY,segments:OY,thetaStart:PY,thetaLength:QY},OY=Math.max(3,OY);const RY=[],SY=[],TY=[],UY=[],VY=new Qi(),WY=new da();SY.push(0,0,0),TY.push(0,0,1),UY.push(0.5,0.5);for(let XY=0,YY=3;XY<=OY;XY++,YY+=3){const ZY=PY+XY/OY*QY;VY.x=NY*Math.cos(ZY),VY.y=NY*Math.sin(ZY),SY.push(VY.x,VY.y,VY.z),TY.push(0,0,1),WY.x=(SY[YY]/NY+1)/2,WY.y=(SY[YY+1]/NY+1)/2,UY.push(WY.x,WY.y)}for(let $Y=1;$Y<=OY;$Y++)RY.push($Y,$Y+1,0);this.setIndex(RY),this.setAttribute("position",new wC(SY,3)),this.setAttribute("normal",new wC(TY,3)),this.setAttribute("uv",new wC(UY,2))}static fromJSON(_Y){return new MY(_Y.radius,_Y.segments,_Y.thetaStart,_Y.thetaLength)}}class aZ extends HC{constructor(bZ=1,cZ=1,dZ=1,eZ=8,fZ=1,gZ=!1,hZ=0,iZ=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:bZ,radiusBottom:cZ,height:dZ,radialSegments:eZ,heightSegments:fZ,openEnded:gZ,thetaStart:hZ,thetaLength:iZ};const jZ=this;eZ=Math.floor(eZ),fZ=Math.floor(fZ);const kZ=[],lZ=[],mZ=[],nZ=[];let oZ=0;const pZ=[],qZ=dZ/2;let rZ=0;function sZ(a){const b=oZ,c=new da(),d=new Qi();let e=0;const f=!0===a?bZ:cZ,g=!0===a?1:-1;for(let h=1;h<=eZ;h++)lZ.push(0,qZ*g,0),mZ.push(0,g,0),nZ.push(0.5,0.5),oZ++;const i=oZ;for(let j=0;j<=eZ;j++){const k=j/eZ,l=k*iZ+hZ,m=Math.cos(l),n=Math.sin(l);d.x=f*n,d.y=qZ*g,d.z=f*m,lZ.push(d.x,d.y,d.z),mZ.push(0,g,0),c.x=0.5*m+0.5,c.y=0.5*n*g+0.5,nZ.push(c.x,c.y),oZ++}for(let o=0;o<eZ;o++){const p=b+o,q=i+o;!0===a?kZ.push(q,q+1,p):kZ.push(q+1,q,p),e+=3}jZ.addGroup(rZ,e,!0===a?1:2),rZ+=e}(function(){const a=new Qi(),b=new Qi();let c=0;const d=(cZ-bZ)/dZ;for(let e=0;e<=fZ;e++){const f=[],g=e/fZ,h=g*(cZ-bZ)+bZ;for(let i=0;i<=eZ;i++){const j=i/eZ,k=j*iZ+hZ,l=Math.sin(k),m=Math.cos(k);b.x=h*l,b.y=-g*dZ+qZ,b.z=h*m,lZ.push(b.x,b.y,b.z),a.set(l,d,m).normalize(),mZ.push(a.x,a.y,a.z),nZ.push(j,1-g),f.push(oZ++)}pZ.push(f)}for(let n=0;n<eZ;n++)for(let o=0;o<fZ;o++){const p=pZ[o][n],q=pZ[o+1][n],r=pZ[o+1][n+1],s=pZ[o][n+1];kZ.push(p,q,s),kZ.push(q,r,s),c+=6}jZ.addGroup(rZ,c,0),rZ+=c})(),!1===gZ&&(bZ>0&&sZ(!0),cZ>0&&sZ(!1)),this.setIndex(kZ),this.setAttribute("position",new wC(lZ,3)),this.setAttribute("normal",new wC(mZ,3)),this.setAttribute("uv",new wC(nZ,2))}static fromJSON(tZ){return new aZ(tZ.radiusTop,tZ.radiusBottom,tZ.height,tZ.radialSegments,tZ.heightSegments,tZ.openEnded,tZ.thetaStart,tZ.thetaLength)}}class uZ extends aZ{constructor(vZ=1,wZ=1,xZ=8,yZ=1,zZ=!1,AZ=0,BZ=2*Math.PI){super(0,vZ,wZ,xZ,yZ,zZ,AZ,BZ),this.type="ConeGeometry",this.parameters={radius:vZ,height:wZ,radialSegments:xZ,heightSegments:yZ,openEnded:zZ,thetaStart:AZ,thetaLength:BZ}}static fromJSON(CZ){return new uZ(CZ.radius,CZ.height,CZ.radialSegments,CZ.heightSegments,CZ.openEnded,CZ.thetaStart,CZ.thetaLength)}}class DZ extends HC{constructor(EZ=[],FZ=[],GZ=1,HZ=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:EZ,indices:FZ,radius:GZ,detail:HZ};const IZ=[],JZ=[];function KZ(a,b,c,d){const e=d+1,f=[];for(let g=0;g<=e;g++){f[g]=[];const h=a.clone().lerp(c,g/e),i=b.clone().lerp(c,g/e),j=e-g;for(let k=0;k<=j;k++)0===k&&g===e?f[g][k]=h:f[g][k]=h.clone().lerp(i,k/j)}for(let l=0;l<e;l++)for(let m=0;m<2*(e-l)-1;m++){const n=Math.floor(m/2);m%2==0?(LZ(f[l][n+1]),LZ(f[l+1][n]),LZ(f[l][n])):(LZ(f[l][n+1]),LZ(f[l+1][n+1]),LZ(f[l+1][n]))}}function LZ(a){IZ.push(a.x,a.y,a.z)}function MZ(a,b){const c=3*a;b.x=EZ[c+0],b.y=EZ[c+1],b.z=EZ[c+2]}function NZ(a,b,c,d){d<0&&1===a.x&&(JZ[b]=a.x-1),0===c.x&&0===c.z&&(JZ[b]=d/2/Math.PI+0.5)}function OZ(a){return Math.atan2(a.z,-a.x)}function PZ(a){return Math.atan2(-a.y,Math.sqrt(a.x*a.x+a.z*a.z))}(function(a){const b=new Qi(),c=new Qi(),d=new Qi();for(let e=0;e<FZ.length;e+=3)MZ(FZ[e+0],b),MZ(FZ[e+1],c),MZ(FZ[e+2],d),KZ(b,c,d,a)})(HZ),(function(a){const b=new Qi();for(let c=0;c<IZ.length;c+=3)b.x=IZ[c+0],b.y=IZ[c+1],b.z=IZ[c+2],b.normalize().multiplyScalar(a),IZ[c+0]=b.x,IZ[c+1]=b.y,IZ[c+2]=b.z})(GZ),(function(){const a=new Qi();for(let b=0;b<IZ.length;b+=3){a.x=IZ[b+0],a.y=IZ[b+1],a.z=IZ[b+2];const c=OZ(a)/2/Math.PI+0.5,d=PZ(a)/Math.PI+0.5;JZ.push(c,1-d)}(function(){const a=new Qi(),b=new Qi(),c=new Qi(),d=new Qi(),e=new da(),f=new da(),g=new da();for(let h=0,i=0;h<IZ.length;h+=9,i+=6){a.set(IZ[h+0],IZ[h+1],IZ[h+2]),b.set(IZ[h+3],IZ[h+4],IZ[h+5]),c.set(IZ[h+6],IZ[h+7],IZ[h+8]),e.set(JZ[i+0],JZ[i+1]),f.set(JZ[i+2],JZ[i+3]),g.set(JZ[i+4],JZ[i+5]),d.copy(a).add(b).add(c).divideScalar(3);const j=OZ(d);NZ(e,i+0,a,j),NZ(f,i+2,b,j),NZ(g,i+4,c,j)}})(),(function(){for(let a=0;a<JZ.length;a+=6){const b=JZ[a+0],c=JZ[a+2],d=JZ[a+4],e=Math.max(b,c,d),f=Math.min(b,c,d);e>0.9&&f<0.1&&(b<0.2&&(JZ[a+0]+=1),c<0.2&&(JZ[a+2]+=1),d<0.2&&(JZ[a+4]+=1))}})()})(),this.setAttribute("position",new wC(IZ,3)),this.setAttribute("normal",new wC(IZ.slice(),3)),this.setAttribute("uv",new wC(JZ,2)),0===HZ?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(QZ){return new DZ(QZ.vertices,QZ.indices,QZ.radius,QZ.details)}}class RZ extends DZ{constructor(SZ=1,TZ=0){const UZ=(1+Math.sqrt(5))/2,VZ=1/UZ;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-VZ,-UZ,0,-VZ,UZ,0,VZ,-UZ,0,VZ,UZ,-VZ,-UZ,0,-VZ,UZ,0,VZ,-UZ,0,VZ,UZ,0,-UZ,0,-VZ,UZ,0,-VZ,-UZ,0,VZ,UZ,0,VZ],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],SZ,TZ),this.type="DodecahedronGeometry",this.parameters={radius:SZ,detail:TZ}}static fromJSON(WZ){return new RZ(WZ.radius,WZ.detail)}}const XZ=new Qi(),YZ=new Qi(),ZZ=new Qi(),$Z=new px();class _Z{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(a$,b$){const c$=this.getUtoTmapping(a$);return this.getPoint(c$,b$)}getPoints(d$=5){const e$=[];for(let f$=0;f$<=d$;f$++)e$.push(this.getPoint(f$/d$));return e$}getSpacedPoints(g$=5){const h$=[];for(let i$=0;i$<=g$;i$++)h$.push(this.getPointAt(i$/g$));return h$}getLength(){const j$=this.getLengths();return j$[j$.length-1]}getLengths(k$=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===k$+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const l$=[];let m$,n$=this.getPoint(0),o$=0;l$.push(0);for(let p$=1;p$<=k$;p$++)o$+=(m$=this.getPoint(p$/k$)).distanceTo(n$),l$.push(o$),n$=m$;return this.cacheArcLengths=l$,l$}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(q$,r$){const s$=this.getLengths();let t$=0;const u$=s$.length;let v$;v$=r$||q$*s$[u$-1];let w$=0,x$=u$-1,y$;for(;w$<=x$;)if((y$=s$[t$=Math.floor(w$+(x$-w$)/2)]-v$)<0)w$=t$+1;else if(y$>0)x$=t$-1;else{x$=t$;break}if(s$[t$=x$]===v$)return t$/(u$-1);const z$=s$[t$],A$=s$[t$+1];return(t$+(v$-z$)/(A$-z$))/(u$-1)}getTangent(B$,C$){const D$=0.0001;let E$=B$-D$,F$=B$+D$;E$<0&&(E$=0),F$>1&&(F$=1);const G$=this.getPoint(E$),H$=this.getPoint(F$),I$=C$||(G$.isVector2?new da():new Qi());return I$.copy(H$).sub(G$).normalize(),I$}getTangentAt(J$,K$){const L$=this.getUtoTmapping(J$);return this.getTangent(L$,K$)}computeFrenetFrames(M$,N$){const O$=new Qi(),P$=[],Q$=[],R$=[],S$=new Qi(),T$=new dp();for(let U$=0;U$<=M$;U$++){const V$=U$/M$;P$[U$]=this.getTangentAt(V$,new Qi())}Q$[0]=new Qi(),R$[0]=new Qi();let W$=Number.MAX_VALUE;const X$=Math.abs(P$[0].x),Y$=Math.abs(P$[0].y),Z$=Math.abs(P$[0].z);X$<=W$&&(W$=X$,O$.set(1,0,0)),Y$<=W$&&(W$=Y$,O$.set(0,1,0)),Z$<=W$&&O$.set(0,0,1),S$.crossVectors(P$[0],O$).normalize(),Q$[0].crossVectors(P$[0],S$),R$[0].crossVectors(P$[0],Q$[0]);for(let $$=1;$$<=M$;$$++){if(Q$[$$]=Q$[$$-1].clone(),R$[$$]=R$[$$-1].clone(),S$.crossVectors(P$[$$-1],P$[$$]),S$.length()>Number.EPSILON){S$.normalize();const _$=Math.acos(Y(P$[$$-1].dot(P$[$$]),-1,1));Q$[$$].applyMatrix4(T$.makeRotationAxis(S$,_$))}R$[$$].crossVectors(P$[$$],Q$[$$])}if(!0===N$){let a_=Math.acos(Y(Q$[0].dot(Q$[M$]),-1,1));a_/=M$,P$[0].dot(S$.crossVectors(Q$[0],Q$[M$]))>0&&(a_=-a_);for(let b_=1;b_<=M$;b_++)Q$[b_].applyMatrix4(T$.makeRotationAxis(P$[b_],a_*b_)),R$[b_].crossVectors(P$[b_],Q$[b_])}return{tangents:P$,normals:Q$,binormals:R$}}clone(){return new this.constructor().copy(this)}copy(c_){return this.arcLengthDivisions=c_.arcLengthDivisions,this}toJSON(){const d_={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return d_.arcLengthDivisions=this.arcLengthDivisions,d_.type=this.type,d_}fromJSON(e_){return this.arcLengthDivisions=e_.arcLengthDivisions,this}}class f_ extends _Z{constructor(g_=0,h_=0,i_=1,j_=1,k_=0,l_=2*Math.PI,m_=!1,n_=0){super(),this.type="EllipseCurve",this.aX=g_,this.aY=h_,this.xRadius=i_,this.yRadius=j_,this.aStartAngle=k_,this.aEndAngle=l_,this.aClockwise=m_,this.aRotation=n_}getPoint(o_,p_){const q_=p_||new da(),r_=2*Math.PI;let s_=this.aEndAngle-this.aStartAngle;const t_=Math.abs(s_)<Number.EPSILON;for(;s_<0;)s_+=r_;for(;s_>r_;)s_-=r_;s_<Number.EPSILON&&(s_=t_?0:r_),!0!==this.aClockwise||t_||(s_===r_?s_=-r_:s_-=r_);const u_=this.aStartAngle+o_*s_;let v_=this.aX+this.xRadius*Math.cos(u_),w_=this.aY+this.yRadius*Math.sin(u_);if(0!==this.aRotation){const x_=Math.cos(this.aRotation),y_=Math.sin(this.aRotation),z_=v_-this.aX,A_=w_-this.aY;v_=z_*x_-A_*y_+this.aX,w_=z_*y_+A_*x_+this.aY}return q_.set(v_,w_)}copy(B_){return super.copy(B_),this.aX=B_.aX,this.aY=B_.aY,this.xRadius=B_.xRadius,this.yRadius=B_.yRadius,this.aStartAngle=B_.aStartAngle,this.aEndAngle=B_.aEndAngle,this.aClockwise=B_.aClockwise,this.aRotation=B_.aRotation,this}toJSON(){const C_=super.toJSON();return C_.aX=this.aX,C_.aY=this.aY,C_.xRadius=this.xRadius,C_.yRadius=this.yRadius,C_.aStartAngle=this.aStartAngle,C_.aEndAngle=this.aEndAngle,C_.aClockwise=this.aClockwise,C_.aRotation=this.aRotation,C_}fromJSON(D_){return super.fromJSON(D_),this.aX=D_.aX,this.aY=D_.aY,this.xRadius=D_.xRadius,this.yRadius=D_.yRadius,this.aStartAngle=D_.aStartAngle,this.aEndAngle=D_.aEndAngle,this.aClockwise=D_.aClockwise,this.aRotation=D_.aRotation,this}}f_.prototype.isEllipseCurve=!0;class E_ extends f_{constructor(F_,G_,H_,I_,J_,K_){super(F_,G_,H_,H_,I_,J_,K_),this.type="ArcCurve"}}function L_(){let a=0,b=0,c=0,d=0;function e(e,f,g,h){a=e,b=g,c=-3*e+3*f-2*g-h,d=2*e-2*f+g+h}return{initCatmullRom:function(a,b,c,d,f){e(b,c,f*(c-a),f*(d-b))},initNonuniformCatmullRom:function(a,b,c,d,f,g,h){let i=(b-a)/f-(c-a)/(f+g)+(c-b)/g,j=(c-b)/g-(d-b)/(g+h)+(d-c)/h;i*=g,j*=g,e(b,c,i,j)},calc:function(e){const f=e*e;return a+b*e+c*f+d*(f*e)}}}E_.prototype.isArcCurve=!0;const M_=new Qi(),N_=new L_(),O_=new L_(),P_=new L_();class Q_ extends _Z{constructor(R_=[],S_=!1,T_="centripetal",U_=0.5){super(),this.type="CatmullRomCurve3",this.points=R_,this.closed=S_,this.curveType=T_,this.tension=U_}getPoint(V_,W_=new Qi()){const X_=W_,Y_=this.points,Z_=Y_.length,$_=(Z_-(this.closed?0:1))*V_;let __=Math.floor($_),a0=$_-__;this.closed?__+=__>0?0:(Math.floor(Math.abs(__)/Z_)+1)*Z_:0===a0&&__===Z_-1&&(__=Z_-2,a0=1);let b0,c0;this.closed||__>0?b0=Y_[(__-1)%Z_]:(M_.subVectors(Y_[0],Y_[1]).add(Y_[0]),b0=M_);const d0=Y_[__%Z_],e0=Y_[(__+1)%Z_];if(this.closed||__+2<Z_?c0=Y_[(__+2)%Z_]:(M_.subVectors(Y_[Z_-1],Y_[Z_-2]).add(Y_[Z_-1]),c0=M_),"centripetal"===this.curveType||"chordal"===this.curveType){const f0="chordal"===this.curveType?0.5:0.25;let g0=Math.pow(b0.distanceToSquared(d0),f0),h0=Math.pow(d0.distanceToSquared(e0),f0),i0=Math.pow(e0.distanceToSquared(c0),f0);h0<0.0001&&(h0=1),g0<0.0001&&(g0=h0),i0<0.0001&&(i0=h0),N_.initNonuniformCatmullRom(b0.x,d0.x,e0.x,c0.x,g0,h0,i0),O_.initNonuniformCatmullRom(b0.y,d0.y,e0.y,c0.y,g0,h0,i0),P_.initNonuniformCatmullRom(b0.z,d0.z,e0.z,c0.z,g0,h0,i0)}else"catmullrom"===this.curveType&&(N_.initCatmullRom(b0.x,d0.x,e0.x,c0.x,this.tension),O_.initCatmullRom(b0.y,d0.y,e0.y,c0.y,this.tension),P_.initCatmullRom(b0.z,d0.z,e0.z,c0.z,this.tension));return X_.set(N_.calc(a0),O_.calc(a0),P_.calc(a0)),X_}copy(j0){super.copy(j0),this.points=[];for(let k0=0,l0=j0.points.length;k0<l0;k0++){const m0=j0.points[k0];this.points.push(m0.clone())}return this.closed=j0.closed,this.curveType=j0.curveType,this.tension=j0.tension,this}toJSON(){const n0=super.toJSON();n0.points=[];for(let o0=0,p0=this.points.length;o0<p0;o0++){const q0=this.points[o0];n0.points.push(q0.toArray())}return n0.closed=this.closed,n0.curveType=this.curveType,n0.tension=this.tension,n0}fromJSON(r0){super.fromJSON(r0),this.points=[];for(let s0=0,t0=r0.points.length;s0<t0;s0++){const u0=r0.points[s0];this.points.push(new Qi().fromArray(u0))}return this.closed=r0.closed,this.curveType=r0.curveType,this.tension=r0.tension,this}}function v0(a,b,c,d,e){const f=(d-b)*0.5,g=(e-c)*0.5,h=a*a;return(2*c-2*d+f+g)*(a*h)+(-3*c+3*d-2*f-g)*h+f*a+c}function w0(a,b,c,d){var e,f;return(function(a,b){const c=1-a;return c*c*b})(a,b)+2*(1-(e=a))*e*c+(f=a)*f*d}function x0(a,b,c,d,e){var f,g;return(function(a,b){const c=1-a;return c*c*c*b})(a,b)+(function(a,b){const c=1-a;return 3*c*c*a*b})(a,c)+3*(1-(f=a))*f*f*d+(g=a)*g*g*e}Q_.prototype.isCatmullRomCurve3=!0;class y0 extends _Z{constructor(z0=new da(),A0=new da(),B0=new da(),C0=new da()){super(),this.type="CubicBezierCurve",this.v0=z0,this.v1=A0,this.v2=B0,this.v3=C0}getPoint(D0,E0=new da()){const F0=E0,G0=this.v0,H0=this.v1,I0=this.v2,J0=this.v3;return F0.set(x0(D0,G0.x,H0.x,I0.x,J0.x),x0(D0,G0.y,H0.y,I0.y,J0.y)),F0}copy(K0){return super.copy(K0),this.v0.copy(K0.v0),this.v1.copy(K0.v1),this.v2.copy(K0.v2),this.v3.copy(K0.v3),this}toJSON(){const L0=super.toJSON();return L0.v0=this.v0.toArray(),L0.v1=this.v1.toArray(),L0.v2=this.v2.toArray(),L0.v3=this.v3.toArray(),L0}fromJSON(M0){return super.fromJSON(M0),this.v0.fromArray(M0.v0),this.v1.fromArray(M0.v1),this.v2.fromArray(M0.v2),this.v3.fromArray(M0.v3),this}}y0.prototype.isCubicBezierCurve=!0;class N0 extends _Z{constructor(O0=new Qi(),P0=new Qi(),Q0=new Qi(),R0=new Qi()){super(),this.type="CubicBezierCurve3",this.v0=O0,this.v1=P0,this.v2=Q0,this.v3=R0}getPoint(S0,T0=new Qi()){const U0=T0,V0=this.v0,W0=this.v1,X0=this.v2,Y0=this.v3;return U0.set(x0(S0,V0.x,W0.x,X0.x,Y0.x),x0(S0,V0.y,W0.y,X0.y,Y0.y),x0(S0,V0.z,W0.z,X0.z,Y0.z)),U0}copy(Z0){return super.copy(Z0),this.v0.copy(Z0.v0),this.v1.copy(Z0.v1),this.v2.copy(Z0.v2),this.v3.copy(Z0.v3),this}toJSON(){const $0=super.toJSON();return $0.v0=this.v0.toArray(),$0.v1=this.v1.toArray(),$0.v2=this.v2.toArray(),$0.v3=this.v3.toArray(),$0}fromJSON(_0){return super.fromJSON(_0),this.v0.fromArray(_0.v0),this.v1.fromArray(_0.v1),this.v2.fromArray(_0.v2),this.v3.fromArray(_0.v3),this}}N0.prototype.isCubicBezierCurve3=!0;class a1 extends _Z{constructor(b1=new da(),c1=new da()){super(),this.type="LineCurve",this.v1=b1,this.v2=c1}getPoint(d1,e1=new da()){const f1=e1;return 1===d1?f1.copy(this.v2):(f1.copy(this.v2).sub(this.v1),f1.multiplyScalar(d1).add(this.v1)),f1}getPointAt(g1,h1){return this.getPoint(g1,h1)}getTangent(i1,j1){const k1=j1||new da();return k1.copy(this.v2).sub(this.v1).normalize(),k1}copy(l1){return super.copy(l1),this.v1.copy(l1.v1),this.v2.copy(l1.v2),this}toJSON(){const m1=super.toJSON();return m1.v1=this.v1.toArray(),m1.v2=this.v2.toArray(),m1}fromJSON(n1){return super.fromJSON(n1),this.v1.fromArray(n1.v1),this.v2.fromArray(n1.v2),this}}a1.prototype.isLineCurve=!0;class o1 extends _Z{constructor(p1=new da(),q1=new da(),r1=new da()){super(),this.type="QuadraticBezierCurve",this.v0=p1,this.v1=q1,this.v2=r1}getPoint(s1,t1=new da()){const u1=t1,v1=this.v0,w1=this.v1,x1=this.v2;return u1.set(w0(s1,v1.x,w1.x,x1.x),w0(s1,v1.y,w1.y,x1.y)),u1}copy(y1){return super.copy(y1),this.v0.copy(y1.v0),this.v1.copy(y1.v1),this.v2.copy(y1.v2),this}toJSON(){const z1=super.toJSON();return z1.v0=this.v0.toArray(),z1.v1=this.v1.toArray(),z1.v2=this.v2.toArray(),z1}fromJSON(A1){return super.fromJSON(A1),this.v0.fromArray(A1.v0),this.v1.fromArray(A1.v1),this.v2.fromArray(A1.v2),this}}o1.prototype.isQuadraticBezierCurve=!0;class B1 extends _Z{constructor(C1=new Qi(),D1=new Qi(),E1=new Qi()){super(),this.type="QuadraticBezierCurve3",this.v0=C1,this.v1=D1,this.v2=E1}getPoint(F1,G1=new Qi()){const H1=G1,I1=this.v0,J1=this.v1,K1=this.v2;return H1.set(w0(F1,I1.x,J1.x,K1.x),w0(F1,I1.y,J1.y,K1.y),w0(F1,I1.z,J1.z,K1.z)),H1}copy(L1){return super.copy(L1),this.v0.copy(L1.v0),this.v1.copy(L1.v1),this.v2.copy(L1.v2),this}toJSON(){const M1=super.toJSON();return M1.v0=this.v0.toArray(),M1.v1=this.v1.toArray(),M1.v2=this.v2.toArray(),M1}fromJSON(N1){return super.fromJSON(N1),this.v0.fromArray(N1.v0),this.v1.fromArray(N1.v1),this.v2.fromArray(N1.v2),this}}B1.prototype.isQuadraticBezierCurve3=!0;class O1 extends _Z{constructor(P1=[]){super(),this.type="SplineCurve",this.points=P1}getPoint(Q1,R1=new da()){const S1=R1,T1=this.points,U1=(T1.length-1)*Q1,V1=Math.floor(U1),W1=U1-V1,X1=T1[0===V1?V1:V1-1],Y1=T1[V1],Z1=T1[V1>T1.length-2?T1.length-1:V1+1],$1=T1[V1>T1.length-3?T1.length-1:V1+2];return S1.set(v0(W1,X1.x,Y1.x,Z1.x,$1.x),v0(W1,X1.y,Y1.y,Z1.y,$1.y)),S1}copy(_1){super.copy(_1),this.points=[];for(let a2=0,b2=_1.points.length;a2<b2;a2++){const c2=_1.points[a2];this.points.push(c2.clone())}return this}toJSON(){const d2=super.toJSON();d2.points=[];for(let e2=0,f2=this.points.length;e2<f2;e2++){const g2=this.points[e2];d2.points.push(g2.toArray())}return d2}fromJSON(h2){super.fromJSON(h2),this.points=[];for(let i2=0,j2=h2.points.length;i2<j2;i2++){const k2=h2.points[i2];this.points.push(new da().fromArray(k2))}return this}}O1.prototype.isSplineCurve=!0;var l2=Object.freeze({__proto__:null,ArcCurve:E_,CatmullRomCurve3:Q_,CubicBezierCurve:y0,CubicBezierCurve3:N0,EllipseCurve:f_,LineCurve:a1,LineCurve3:class extends _Z{constructor(m2=new Qi(),n2=new Qi()){super(),this.type="LineCurve3",this.isLineCurve3=!0,this.v1=m2,this.v2=n2}getPoint(o2,p2=new Qi()){const q2=p2;return 1===o2?q2.copy(this.v2):(q2.copy(this.v2).sub(this.v1),q2.multiplyScalar(o2).add(this.v1)),q2}getPointAt(r2,s2){return this.getPoint(r2,s2)}copy(t2){return super.copy(t2),this.v1.copy(t2.v1),this.v2.copy(t2.v2),this}toJSON(){const u2=super.toJSON();return u2.v1=this.v1.toArray(),u2.v2=this.v2.toArray(),u2}fromJSON(v2){return super.fromJSON(v2),this.v1.fromArray(v2.v1),this.v2.fromArray(v2.v2),this}},QuadraticBezierCurve:o1,QuadraticBezierCurve3:B1,SplineCurve:O1});class w2 extends _Z{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(x2){this.curves.push(x2)}closePath(){const y2=this.curves[0].getPoint(0),z2=this.curves[this.curves.length-1].getPoint(1);y2.equals(z2)||this.curves.push(new a1(z2,y2))}getPoint(A2,B2){const C2=A2*this.getLength(),D2=this.getCurveLengths();let E2=0;for(;E2<D2.length;){if(D2[E2]>=C2){const F2=D2[E2]-C2,G2=this.curves[E2],H2=G2.getLength(),I2=0===H2?0:1-F2/H2;return G2.getPointAt(I2,B2)}E2++}return null}getLength(){const J2=this.getCurveLengths();return J2[J2.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const K2=[];let L2=0;for(let M2=0,N2=this.curves.length;M2<N2;M2++)L2+=this.curves[M2].getLength(),K2.push(L2);return this.cacheLengths=K2,K2}getSpacedPoints(O2=40){const P2=[];for(let Q2=0;Q2<=O2;Q2++)P2.push(this.getPoint(Q2/O2));return this.autoClose&&P2.push(P2[0]),P2}getPoints(R2=12){const S2=[];let T2;for(let U2=0,V2=this.curves;U2<V2.length;U2++){const W2=V2[U2],X2=W2&&W2.isEllipseCurve?2*R2:W2&&(W2.isLineCurve||W2.isLineCurve3)?1:W2&&W2.isSplineCurve?R2*W2.points.length:R2,Y2=W2.getPoints(X2);for(let Z2=0;Z2<Y2.length;Z2++){const $2=Y2[Z2];T2&&T2.equals($2)||(S2.push($2),T2=$2)}}return this.autoClose&&S2.length>1&&!S2[S2.length-1].equals(S2[0])&&S2.push(S2[0]),S2}copy(_2){super.copy(_2),this.curves=[];for(let a3=0,b3=_2.curves.length;a3<b3;a3++){const c3=_2.curves[a3];this.curves.push(c3.clone())}return this.autoClose=_2.autoClose,this}toJSON(){const d3=super.toJSON();d3.autoClose=this.autoClose,d3.curves=[];for(let e3=0,f3=this.curves.length;e3<f3;e3++){const g3=this.curves[e3];d3.curves.push(g3.toJSON())}return d3}fromJSON(h3){super.fromJSON(h3),this.autoClose=h3.autoClose,this.curves=[];for(let i3=0,j3=h3.curves.length;i3<j3;i3++){const k3=h3.curves[i3];this.curves.push(new l2[k3.type]().fromJSON(k3))}return this}}class l3 extends w2{constructor(m3){super(),this.type="Path",this.currentPoint=new da(),m3&&this.setFromPoints(m3)}setFromPoints(n3){this.moveTo(n3[0].x,n3[0].y);for(let o3=1,p3=n3.length;o3<p3;o3++)this.lineTo(n3[o3].x,n3[o3].y);return this}moveTo(q3,r3){return this.currentPoint.set(q3,r3),this}lineTo(s3,t3){const u3=new a1(this.currentPoint.clone(),new da(s3,t3));return this.curves.push(u3),this.currentPoint.set(s3,t3),this}quadraticCurveTo(v3,w3,x3,y3){const z3=new o1(this.currentPoint.clone(),new da(v3,w3),new da(x3,y3));return this.curves.push(z3),this.currentPoint.set(x3,y3),this}bezierCurveTo(A3,B3,C3,D3,E3,F3){const G3=new y0(this.currentPoint.clone(),new da(A3,B3),new da(C3,D3),new da(E3,F3));return this.curves.push(G3),this.currentPoint.set(E3,F3),this}splineThru(H3){const I3=[this.currentPoint.clone()].concat(H3),J3=new O1(I3);return this.curves.push(J3),this.currentPoint.copy(H3[H3.length-1]),this}arc(K3,L3,M3,N3,O3,P3){const Q3=this.currentPoint.x,R3=this.currentPoint.y;return this.absarc(K3+Q3,L3+R3,M3,N3,O3,P3),this}absarc(S3,T3,U3,V3,W3,X3){return this.absellipse(S3,T3,U3,U3,V3,W3,X3),this}ellipse(Y3,Z3,$3,_3,a4,b4,c4,d4){const e4=this.currentPoint.x,f4=this.currentPoint.y;return this.absellipse(Y3+e4,Z3+f4,$3,_3,a4,b4,c4,d4),this}absellipse(g4,h4,i4,j4,k4,l4,m4,n4){const o4=new f_(g4,h4,i4,j4,k4,l4,m4,n4);if(this.curves.length>0){const p4=o4.getPoint(0);p4.equals(this.currentPoint)||this.lineTo(p4.x,p4.y)}this.curves.push(o4);const q4=o4.getPoint(1);return this.currentPoint.copy(q4),this}copy(r4){return super.copy(r4),this.currentPoint.copy(r4.currentPoint),this}toJSON(){const s4=super.toJSON();return s4.currentPoint=this.currentPoint.toArray(),s4}fromJSON(t4){return super.fromJSON(t4),this.currentPoint.fromArray(t4.currentPoint),this}}class u4 extends l3{constructor(v4){super(v4),this.uuid=X(),this.type="Shape",this.holes=[]}getPointsHoles(w4){const x4=[];for(let y4=0,z4=this.holes.length;y4<z4;y4++)x4[y4]=this.holes[y4].getPoints(w4);return x4}extractPoints(A4){return{shape:this.getPoints(A4),holes:this.getPointsHoles(A4)}}copy(B4){super.copy(B4),this.holes=[];for(let C4=0,D4=B4.holes.length;C4<D4;C4++){const E4=B4.holes[C4];this.holes.push(E4.clone())}return this}toJSON(){const F4=super.toJSON();F4.uuid=this.uuid,F4.holes=[];for(let G4=0,H4=this.holes.length;G4<H4;G4++){const I4=this.holes[G4];F4.holes.push(I4.toJSON())}return F4}fromJSON(J4){super.fromJSON(J4),this.uuid=J4.uuid,this.holes=[];for(let K4=0,L4=J4.holes.length;K4<L4;K4++){const M4=J4.holes[K4];this.holes.push(new l3().fromJSON(M4))}return this}}const N4={triangulate:function(a,b,c=2){const d=b&&b.length,e=d?b[0]*c:a.length;let f=O4(a,0,e,c,!0);const g=[];if(!f||f.next===f.prev)return g;let h,i,j,k,l,m,n;if(d&&(f=V4(a,b,f,c)),a.length>80*c){h=j=a[0],i=k=a[1];for(let o=c;o<e;o+=c)l=a[o],m=a[o+1],l<h&&(h=l),m<i&&(i=m),l>j&&(j=l),m>k&&(k=m);n=0!==(n=Math.max(j-h,k-i))?1/n:0}return Q4(f,g,c,h,i,n),g}};function O4(a,b,c,d,e){let f,g;if(e===q5(a,b,c,d)>0)for(f=b;f<c;f+=d)g=n5(f,a[f],a[f+1],g);else for(f=c-d;f>=b;f-=d)g=n5(f,a[f],a[f+1],g);return g&&f5(g,g.next)&&(o5(g),g=g.next),g}function P4(a,b){if(!a)return a;b||(b=a);let c=a,d;do if(d=!1,!c.steiner&&(f5(c,c.next)||0===e5(c.prev,c,c.next))){if(o5(c),(c=b=c.prev)===c.next)break;d=!0}else c=c.next;while(d||c!==b)return b}function Q4(a,b,c,d,e,f,g){if(!a)return;!g&&f&&$4(a,d,e,f);let h=a,i,j;for(;a.prev!==a.next;){if(i=a.prev,j=a.next,f?S4(a,d,e,f):R4(a)){b.push(i.i/c),b.push(a.i/c),b.push(j.i/c),o5(a),a=j.next,h=j.next;continue}if((a=j)===h){g?1===g?Q4(a=T4(P4(a),b,c),b,c,d,e,f,2):2===g&&U4(a,b,c,d,e,f):Q4(P4(a),b,c,d,e,f,1);break}}}function R4(a){const b=a.prev,c=a,d=a.next;if(e5(b,c,d)>=0)return!1;let e=a.next.next;for(;e!==a.prev;){if(c5(b.x,b.y,c.x,c.y,d.x,d.y,e.x,e.y)&&e5(e.prev,e,e.next)>=0)return!1;e=e.next}return!0}function S4(a,b,c,d){const e=a.prev,f=a,g=a.next;if(e5(e,f,g)>=0)return!1;const h=e.x<f.x?e.x<g.x?e.x:g.x:f.x<g.x?f.x:g.x,i=e.y<f.y?e.y<g.y?e.y:g.y:f.y<g.y?f.y:g.y,j=e.x>f.x?e.x>g.x?e.x:g.x:f.x>g.x?f.x:g.x,k=e.y>f.y?e.y>g.y?e.y:g.y:f.y>g.y?f.y:g.y,l=a5(h,i,b,c,d),m=a5(j,k,b,c,d);let n=a.prevZ,o=a.nextZ;for(;n&&n.z>=l&&o&&o.z<=m;){if(n!==a.prev&&n!==a.next&&c5(e.x,e.y,f.x,f.y,g.x,g.y,n.x,n.y)&&e5(n.prev,n,n.next)>=0)return!1;if(n=n.prevZ,o!==a.prev&&o!==a.next&&c5(e.x,e.y,f.x,f.y,g.x,g.y,o.x,o.y)&&e5(o.prev,o,o.next)>=0)return!1;o=o.nextZ}for(;n&&n.z>=l;){if(n!==a.prev&&n!==a.next&&c5(e.x,e.y,f.x,f.y,g.x,g.y,n.x,n.y)&&e5(n.prev,n,n.next)>=0)return!1;n=n.prevZ}for(;o&&o.z<=m;){if(o!==a.prev&&o!==a.next&&c5(e.x,e.y,f.x,f.y,g.x,g.y,o.x,o.y)&&e5(o.prev,o,o.next)>=0)return!1;o=o.nextZ}return!0}function T4(a,b,c){let d=a;do{const e=d.prev,f=d.next.next;!f5(e,f)&&g5(e,d,d.next,f)&&k5(e,f)&&k5(f,e)&&(b.push(e.i/c),b.push(d.i/c),b.push(f.i/c),o5(d),o5(d.next),d=a=f),d=d.next}while(d!==a)return P4(d)}function U4(a,b,c,d,e,f){let g=a;do{let h=g.next.next;for(;h!==g.prev;){if(g.i!==h.i&&d5(g,h)){let i=m5(g,h);g=P4(g,g.next),i=P4(i,i.next),Q4(g,b,c,d,e,f),Q4(i,b,c,d,e,f);return}h=h.next}g=g.next}while(g!==a)}function V4(a,b,c,d){const e=[];let f,g,h,i,j;for(f=0,g=b.length;f<g;f++)h=b[f]*d,i=f<g-1?b[f+1]*d:a.length,j=O4(a,h,i,d,!1),j===j.next&&(j.steiner=!0),e.push(b5(j));for(e.sort(W4),f=0;f<e.length;f++)X4(e[f],c),c=P4(c,c.next);return c}function W4(a,b){return a.x-b.x}function X4(a,b){if(b=Y4(a,b)){const c=m5(b,a);P4(b,b.next),P4(c,c.next)}}function Y4(a,b){let c=b;const d=a.x,e=a.y;let f=-1/0,g;do{if(e<=c.y&&e>=c.next.y&&c.next.y!==c.y){const h=c.x+(e-c.y)*(c.next.x-c.x)/(c.next.y-c.y);if(h<=d&&h>f){if(f=h,h===d){if(e===c.y)return c;if(e===c.next.y)return c.next}g=c.x<c.next.x?c:c.next}}c=c.next}while(c!==b)if(!g)return null;if(d===f)return g;const i=g,j=g.x,k=g.y;let l=1/0,m;c=g;do d>=c.x&&c.x>=j&&d!==c.x&&c5(e<k?d:f,e,j,k,e<k?f:d,e,c.x,c.y)&&(m=Math.abs(e-c.y)/(d-c.x),k5(c,a)&&(m<l||m===l&&(c.x>g.x||c.x===g.x&&Z4(g,c)))&&(g=c,l=m)),c=c.next;while(c!==i)return g}function Z4(a,b){return 0>e5(a.prev,a,b.prev)&&0>e5(b.next,a,a.next)}function $4(a,b,c,d){let e=a;do null===e.z&&(e.z=a5(e.x,e.y,b,c,d)),e.prevZ=e.prev,e.nextZ=e.next,e=e.next;while(e!==a)e.prevZ.nextZ=null,e.prevZ=null,_4(e)}function _4(a){let b,c,d,e,f,g,h,i,j=1;do{for(c=a,a=null,f=null,g=0;c;){for(g++,d=c,h=0,b=0;b<j&&(h++,d=d.nextZ);b++);for(i=j;h>0||i>0&&d;)0!==h&&(0===i||!d||c.z<=d.z)?(e=c,c=c.nextZ,h--):(e=d,d=d.nextZ,i--),f?f.nextZ=e:a=e,e.prevZ=f,f=e;c=d}f.nextZ=null,j*=2}while(g>1)return a}function a5(a,b,c,d,e){return a=32767*(a-c)*e,b=32767*(b-d)*e,a=(a|a<<8)&16711935,a=(a|a<<4)&252645135,a=(a|a<<2)&858993459,a=(a|a<<1)&1431655765,b=(b|b<<8)&16711935,b=(b|b<<4)&252645135,b=(b|b<<2)&858993459,b=(b|b<<1)&1431655765,a|b<<1}function b5(a){let b=a,c=a;do(b.x<c.x||b.x===c.x&&b.y<c.y)&&(c=b),b=b.next;while(b!==a)return c}function c5(a,b,c,d,e,f,g,h){return(e-g)*(b-h)-(a-g)*(f-h)>=0&&(a-g)*(d-h)-(c-g)*(b-h)>=0&&(c-g)*(f-h)-(e-g)*(d-h)>=0}function d5(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!j5(a,b)&&(k5(a,b)&&k5(b,a)&&l5(a,b)&&(e5(a.prev,a,b.prev)||e5(a,b.prev,b))||f5(a,b)&&e5(a.prev,a,a.next)>0&&e5(b.prev,b,b.next)>0)}function e5(a,b,c){return(b.y-a.y)*(c.x-b.x)-(b.x-a.x)*(c.y-b.y)}function f5(a,b){return a.x===b.x&&a.y===b.y}function g5(a,b,c,d){const e=i5(e5(a,b,c)),f=i5(e5(a,b,d)),g=i5(e5(c,d,a)),h=i5(e5(c,d,b));return e!==f&&g!==h|| !!(0===e&&h5(a,c,b))|| !!(0===f&&h5(a,d,b))|| !!(0===g&&h5(c,a,d))||!!(0===h&&h5(c,b,d))}function h5(a,b,c){return b.x<=Math.max(a.x,c.x)&&b.x>=Math.min(a.x,c.x)&&b.y<=Math.max(a.y,c.y)&&b.y>=Math.min(a.y,c.y)}function i5(a){return a>0?1:a<0?-1:0}function j5(a,b){let c=a;do{if(c.i!==a.i&&c.next.i!==a.i&&c.i!==b.i&&c.next.i!==b.i&&g5(c,c.next,a,b))return!0;c=c.next}while(c!==a)return!1}function k5(a,b){return 0>e5(a.prev,a,a.next)?e5(a,b,a.next)>=0&&e5(a,a.prev,b)>=0:0>e5(a,b,a.prev)||0>e5(a,a.next,b)}function l5(a,b){let c=a,d=!1;const e=(a.x+b.x)/2,f=(a.y+b.y)/2;do c.y>f!=c.next.y>f&&c.next.y!==c.y&&e<(c.next.x-c.x)*(f-c.y)/(c.next.y-c.y)+c.x&&(d=!d),c=c.next;while(c!==a)return d}function m5(a,b){const c=new p5(a.i,a.x,a.y),d=new p5(b.i,b.x,b.y),e=a.next,f=b.prev;return a.next=b,b.prev=a,c.next=e,e.prev=c,d.next=c,c.prev=d,f.next=d,d.prev=f,d}function n5(a,b,c,d){const e=new p5(a,b,c);return d?(e.next=d.next,e.prev=d,d.next.prev=e,d.next=e):(e.prev=e,e.next=e),e}function o5(a){a.next.prev=a.prev,a.prev.next=a.next,a.prevZ&&(a.prevZ.nextZ=a.nextZ),a.nextZ&&(a.nextZ.prevZ=a.prevZ)}function p5(a,b,c){this.i=a,this.x=b,this.y=c,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function q5(a,b,c,d){let e=0;for(let f=b,g=c-d;f<c;f+=d)e+=(a[g]-a[f])*(a[f+1]+a[g+1]),g=f;return e}class r5{static area(s5){const t5=s5.length;let u5=0;for(let v5=t5-1,w5=0;w5<t5;v5=w5++)u5+=s5[v5].x*s5[w5].y-s5[w5].x*s5[v5].y;return 0.5*u5}static isClockWise(x5){return 0>r5.area(x5)}static triangulateShape(y5,z5){const A5=[],B5=[],C5=[];H5(y5),I5(A5,y5);let D5=y5.length;z5.forEach(H5);for(let E5=0;E5<z5.length;E5++)B5.push(D5),D5+=z5[E5].length,I5(A5,z5[E5]);const F5=N4.triangulate(A5,B5);for(let G5=0;G5<F5.length;G5+=3)C5.push(F5.slice(G5,G5+3));return C5}}function H5(a){const b=a.length;b>2&&a[b-1].equals(a[0])&&a.pop()}function I5(a,b){for(let c=0;c<b.length;c++)a.push(b[c].x),a.push(b[c].y)}class J5 extends HC{constructor(K5=new u4([new da(0.5,0.5),new da(-0.5,0.5),new da(-0.5,-0.5),new da(0.5,-0.5)]),L5={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:K5,options:L5},K5=Array.isArray(K5)?K5:[K5];const M5=this,N5=[],O5=[];for(let P5=0,Q5=K5.length;P5<Q5;P5++){const R5=K5[P5];S5(R5)}function S5(a){const b=[],c=void 0!==L5.curveSegments?L5.curveSegments:12,d=void 0!==L5.steps?L5.steps:1;let e=void 0!==L5.depth?L5.depth:1,f=void 0===L5.bevelEnabled||L5.bevelEnabled,g=void 0!==L5.bevelThickness?L5.bevelThickness:0.2,h=void 0!==L5.bevelSize?L5.bevelSize:g-0.1,i=void 0!==L5.bevelOffset?L5.bevelOffset:0,j=void 0!==L5.bevelSegments?L5.bevelSegments:3;const k=L5.extrudePath,l=void 0!==L5.UVGenerator?L5.UVGenerator:b6;void 0!==L5.amount&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),e=L5.amount);let m,n=!1,o,p,q,r;k&&(m=k.getSpacedPoints(d),n=!0,f=!1,o=k.computeFrenetFrames(d,!1),p=new Qi(),q=new Qi(),r=new Qi()),f||(j=0,g=0,h=0,i=0);const s=a.extractPoints(c);let t=s.shape;const u=s.holes,v=!r5.isClockWise(t);if(v){t=t.reverse();for(let w=0,x=u.length;w<x;w++){const y=u[w];r5.isClockWise(y)&&(u[w]=y.reverse())}}const z=r5.triangulateShape(t,u),A=t;for(let B=0,C=u.length;B<C;B++){const D=u[B];t=t.concat(D)}function E(a,b,c){return b||console.error("THREE.ExtrudeGeometry: vec does not exist"),b.clone().multiplyScalar(c).add(a)}const F=t.length,G=z.length;function H(a,b,c){let d,e,f;const g=a.x-b.x,h=a.y-b.y,i=c.x-a.x,j=c.y-a.y,k=g*g+h*h,l=g*j-h*i;if(Math.abs(l)>Number.EPSILON){const m=Math.sqrt(k),n=Math.sqrt(i*i+j*j),o=b.x-h/m,p=b.y+g/m,q=c.x-j/n,r=c.y+i/n,s=((q-o)*j-(r-p)*i)/(g*j-h*i);d=o+g*s-a.x,e=p+h*s-a.y;const t=d*d+e*e;if(t<=2)return new da(d,e);f=Math.sqrt(t/2)}else{let u=!1;g>Number.EPSILON?i>Number.EPSILON&&(u=!0):g< -Number.EPSILON?i< -Number.EPSILON&&(u=!0):Math.sign(h)===Math.sign(j)&&(u=!0),u?(d=-h,e=g,f=Math.sqrt(k)):(d=g,e=h,f=Math.sqrt(k/2))}return new da(d/f,e/f)}const I=[];for(let J=0,K=A.length,L=K-1,M=J+1;J<K;J++,L++,M++)L===K&&(L=0),M===K&&(M=0),I[J]=H(A[J],A[L],A[M]);const N=[];let O,P=I.concat();for(let Q=0,R=u.length;Q<R;Q++){const S=u[Q];O=[];for(let T=0,U=S.length,V=U-1,W=T+1;T<U;T++,V++,W++)V===U&&(V=0),W===U&&(W=0),O[T]=H(S[T],S[V],S[W]);N.push(O),P=P.concat(O)}for(let X=0;X<j;X++){const Y=X/j,Z=g*Math.cos(Y*Math.PI/2),$=h*Math.sin(Y*Math.PI/2)+i;for(let _=0,aa=A.length;_<aa;_++){const ba=E(A[_],I[_],$);Da(ba.x,ba.y,-Z)}for(let ca=0,ea=u.length;ca<ea;ca++){const fa=u[ca];O=N[ca];for(let ga=0,ha=fa.length;ga<ha;ga++){const ia=E(fa[ga],O[ga],$);Da(ia.x,ia.y,-Z)}}}const ja=h+i;for(let ka=0;ka<F;ka++){const la=f?E(t[ka],P[ka],ja):t[ka];n?(q.copy(o.normals[0]).multiplyScalar(la.x),p.copy(o.binormals[0]).multiplyScalar(la.y),r.copy(m[0]).add(q).add(p),Da(r.x,r.y,r.z)):Da(la.x,la.y,0)}for(let ma=1;ma<=d;ma++)for(let na=0;na<F;na++){const oa=f?E(t[na],P[na],ja):t[na];n?(q.copy(o.normals[ma]).multiplyScalar(oa.x),p.copy(o.binormals[ma]).multiplyScalar(oa.y),r.copy(m[ma]).add(q).add(p),Da(r.x,r.y,r.z)):Da(oa.x,oa.y,e/d*ma)}for(let pa=j-1;pa>=0;pa--){const qa=pa/j,ra=g*Math.cos(qa*Math.PI/2),sa=h*Math.sin(qa*Math.PI/2)+i;for(let ta=0,ua=A.length;ta<ua;ta++){const va=E(A[ta],I[ta],sa);Da(va.x,va.y,e+ra)}for(let wa=0,xa=u.length;wa<xa;wa++){const ya=u[wa];O=N[wa];for(let za=0,Aa=ya.length;za<Aa;za++){const Ba=E(ya[za],O[za],sa);n?Da(Ba.x,Ba.y+m[d-1].y,m[d-1].x+ra):Da(Ba.x,Ba.y,e+ra)}}}function Ca(a,b){let c=a.length;for(;--c>=0;){const e=c;let f=c-1;f<0&&(f=a.length-1);for(let g=0,h=d+2*j;g<h;g++){const i=F*g,k=F*(g+1),l=b+e+i,m=b+f+i,n=b+f+k,o=b+e+k;Fa(l,m,n,o)}}}function Da(a,c,d){b.push(a),b.push(c),b.push(d)}function Ea(a,b,c){Ga(a),Ga(b),Ga(c);const d=N5.length/3,e=l.generateTopUV(M5,N5,d-3,d-2,d-1);Ha(e[0]),Ha(e[1]),Ha(e[2])}function Fa(a,b,c,d){Ga(a),Ga(b),Ga(d),Ga(b),Ga(c),Ga(d);const e=N5.length/3,f=l.generateSideWallUV(M5,N5,e-6,e-3,e-2,e-1);Ha(f[0]),Ha(f[1]),Ha(f[3]),Ha(f[1]),Ha(f[2]),Ha(f[3])}function Ga(a){N5.push(b[3*a+0]),N5.push(b[3*a+1]),N5.push(b[3*a+2])}function Ha(a){O5.push(a.x),O5.push(a.y)}(function(){const a=N5.length/3;if(f){let b=0,c=F*b;for(let e=0;e<G;e++){const g=z[e];Ea(g[2]+c,g[1]+c,g[0]+c)}c=F*(b=d+2*j);for(let h=0;h<G;h++){const i=z[h];Ea(i[0]+c,i[1]+c,i[2]+c)}}else{for(let k=0;k<G;k++){const l=z[k];Ea(l[2],l[1],l[0])}for(let m=0;m<G;m++){const n=z[m];Ea(n[0]+F*d,n[1]+F*d,n[2]+F*d)}}M5.addGroup(a,N5.length/3-a,0)})(),(function(){const a=N5.length/3;let b=0;Ca(A,b),b+=A.length;for(let c=0,d=u.length;c<d;c++){const e=u[c];Ca(e,b),b+=e.length}M5.addGroup(a,N5.length/3-a,1)})()}this.setAttribute("position",new wC(N5,3)),this.setAttribute("uv",new wC(O5,2)),this.computeVertexNormals()}toJSON(){const T5=super.toJSON(),U5=this.parameters.shapes,V5=this.parameters.options;return c6(U5,V5,T5)}static fromJSON(W5,X5){const Y5=[];for(let Z5=0,$5=W5.shapes.length;Z5<$5;Z5++){const _5=X5[W5.shapes[Z5]];Y5.push(_5)}const a6=W5.options.extrudePath;return void 0!==a6&&(W5.options.extrudePath=new l2[a6.type]().fromJSON(a6)),new J5(Y5,W5.options)}}const b6={generateTopUV:function(a,b,c,d,e){const f=b[3*c],g=b[3*c+1],h=b[3*d],i=b[3*d+1],j=b[3*e],k=b[3*e+1];return[new da(f,g),new da(h,i),new da(j,k)]},generateSideWallUV:function(a,b,c,d,e,f){const g=b[3*c],h=b[3*c+1],i=b[3*c+2],j=b[3*d],k=b[3*d+1],l=b[3*d+2],m=b[3*e],n=b[3*e+1],o=b[3*e+2],p=b[3*f],q=b[3*f+1],r=b[3*f+2];return Math.abs(h-k)<Math.abs(g-j)?[new da(g,1-i),new da(j,1-l),new da(m,1-o),new da(p,1-r)]:[new da(h,1-i),new da(k,1-l),new da(n,1-o),new da(q,1-r)]}};function c6(a,b,c){if(c.shapes=[],Array.isArray(a))for(let d=0,e=a.length;d<e;d++){const f=a[d];c.shapes.push(f.uuid)}else c.shapes.push(a.uuid);return void 0!==b.extrudePath&&(c.options.extrudePath=b.extrudePath.toJSON()),c}class d6 extends DZ{constructor(e6=1,f6=0){const g6=(1+Math.sqrt(5))/2;super([-1,g6,0,1,g6,0,-1,-g6,0,1,-g6,0,0,-1,g6,0,1,g6,0,-1,-g6,0,1,-g6,g6,0,-1,g6,0,1,-g6,0,-1,-g6,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],e6,f6),this.type="IcosahedronGeometry",this.parameters={radius:e6,detail:f6}}static fromJSON(h6){return new d6(h6.radius,h6.detail)}}class i6 extends HC{constructor(j6=[new da(0,0.5),new da(0.5,0),new da(0,-0.5)],k6=12,l6=0,m6=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:j6,segments:k6,phiStart:l6,phiLength:m6},k6=Math.floor(k6),m6=Y(m6,0,2*Math.PI);const n6=[],o6=[],p6=[],q6=1/k6,r6=new Qi(),s6=new da();for(let t6=0;t6<=k6;t6++){const u6=l6+t6*q6*m6,v6=Math.sin(u6),w6=Math.cos(u6);for(let x6=0;x6<=j6.length-1;x6++)r6.x=j6[x6].x*v6,r6.y=j6[x6].y,r6.z=j6[x6].x*w6,o6.push(r6.x,r6.y,r6.z),s6.x=t6/k6,s6.y=x6/(j6.length-1),p6.push(s6.x,s6.y)}for(let y6=0;y6<k6;y6++)for(let z6=0;z6<j6.length-1;z6++){const A6=z6+y6*j6.length,B6=A6,C6=A6+j6.length,D6=A6+j6.length+1,E6=A6+1;n6.push(B6,C6,E6),n6.push(C6,D6,E6)}if(this.setIndex(n6),this.setAttribute("position",new wC(o6,3)),this.setAttribute("uv",new wC(p6,2)),this.computeVertexNormals(),m6===2*Math.PI){const F6=this.attributes.normal.array,G6=new Qi(),H6=new Qi(),I6=new Qi(),J6=k6*j6.length*3;for(let K6=0,L6=0;K6<j6.length;K6++,L6+=3)G6.x=F6[L6+0],G6.y=F6[L6+1],G6.z=F6[L6+2],H6.x=F6[J6+L6+0],H6.y=F6[J6+L6+1],H6.z=F6[J6+L6+2],I6.addVectors(G6,H6).normalize(),F6[L6+0]=F6[J6+L6+0]=I6.x,F6[L6+1]=F6[J6+L6+1]=I6.y,F6[L6+2]=F6[J6+L6+2]=I6.z}}static fromJSON(M6){return new i6(M6.points,M6.segments,M6.phiStart,M6.phiLength)}}class N6 extends DZ{constructor(O6=1,P6=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],O6,P6),this.type="OctahedronGeometry",this.parameters={radius:O6,detail:P6}}static fromJSON(Q6){return new N6(Q6.radius,Q6.detail)}}class R6 extends HC{constructor(S6=0.5,T6=1,U6=8,V6=1,W6=0,X6=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:S6,outerRadius:T6,thetaSegments:U6,phiSegments:V6,thetaStart:W6,thetaLength:X6},U6=Math.max(3,U6),V6=Math.max(1,V6);const Y6=[],Z6=[],$6=[],_6=[];let a7=S6;const b7=(T6-S6)/V6,c7=new Qi(),d7=new da();for(let e7=0;e7<=V6;e7++){for(let f7=0;f7<=U6;f7++){const g7=W6+f7/U6*X6;c7.x=a7*Math.cos(g7),c7.y=a7*Math.sin(g7),Z6.push(c7.x,c7.y,c7.z),$6.push(0,0,1),d7.x=(c7.x/T6+1)/2,d7.y=(c7.y/T6+1)/2,_6.push(d7.x,d7.y)}a7+=b7}for(let h7=0;h7<V6;h7++){const i7=h7*(U6+1);for(let j7=0;j7<U6;j7++){const k7=j7+i7,l7=k7,m7=k7+U6+1,n7=k7+U6+2,o7=k7+1;Y6.push(l7,m7,o7),Y6.push(m7,n7,o7)}}this.setIndex(Y6),this.setAttribute("position",new wC(Z6,3)),this.setAttribute("normal",new wC($6,3)),this.setAttribute("uv",new wC(_6,2))}static fromJSON(p7){return new R6(p7.innerRadius,p7.outerRadius,p7.thetaSegments,p7.phiSegments,p7.thetaStart,p7.thetaLength)}}class q7 extends HC{constructor(r7=new u4([new da(0,0.5),new da(-0.5,-0.5),new da(0.5,-0.5)]),s7=12){super(),this.type="ShapeGeometry",this.parameters={shapes:r7,curveSegments:s7};const t7=[],u7=[],v7=[],w7=[];let x7=0,y7=0;if(!1===Array.isArray(r7))A7(r7);else for(let z7=0;z7<r7.length;z7++)A7(r7[z7]),this.addGroup(x7,y7,z7),x7+=y7,y7=0;function A7(a){const b=u7.length/3,c=a.extractPoints(s7);let d=c.shape;const e=c.holes;!1===r5.isClockWise(d)&&(d=d.reverse());for(let f=0,g=e.length;f<g;f++){const h=e[f];!0===r5.isClockWise(h)&&(e[f]=h.reverse())}const i=r5.triangulateShape(d,e);for(let j=0,k=e.length;j<k;j++){const l=e[j];d=d.concat(l)}for(let m=0,n=d.length;m<n;m++){const o=d[m];u7.push(o.x,o.y,0),v7.push(0,0,1),w7.push(o.x,o.y)}for(let p=0,q=i.length;p<q;p++){const r=i[p],s=r[0]+b,t=r[1]+b,u=r[2]+b;t7.push(s,t,u),y7+=3}}this.setIndex(t7),this.setAttribute("position",new wC(u7,3)),this.setAttribute("normal",new wC(v7,3)),this.setAttribute("uv",new wC(w7,2))}toJSON(){const B7=super.toJSON(),C7=this.parameters.shapes;return J7(C7,B7)}static fromJSON(D7,E7){const F7=[];for(let G7=0,H7=D7.shapes.length;G7<H7;G7++){const I7=E7[D7.shapes[G7]];F7.push(I7)}return new q7(F7,D7.curveSegments)}}function J7(a,b){if(b.shapes=[],Array.isArray(a))for(let c=0,d=a.length;c<d;c++){const e=a[c];b.shapes.push(e.uuid)}else b.shapes.push(a.uuid);return b}class K7 extends HC{constructor(L7=1,M7=32,N7=16,O7=0,P7=2*Math.PI,Q7=0,R7=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:L7,widthSegments:M7,heightSegments:N7,phiStart:O7,phiLength:P7,thetaStart:Q7,thetaLength:R7},M7=Math.max(3,Math.floor(M7)),N7=Math.max(2,Math.floor(N7));const S7=Math.min(Q7+R7,Math.PI);let T7=0;const U7=[],V7=new Qi(),W7=new Qi(),X7=[],Y7=[],Z7=[],$7=[];for(let _7=0;_7<=N7;_7++){const a8=[],b8=_7/N7;let c8=0;0==_7&&0==Q7?c8=0.5/M7:_7==N7&&S7==Math.PI&&(c8=-0.5/M7);for(let d8=0;d8<=M7;d8++){const e8=d8/M7;V7.x=-L7*Math.cos(O7+e8*P7)*Math.sin(Q7+b8*R7),V7.y=L7*Math.cos(Q7+b8*R7),V7.z=L7*Math.sin(O7+e8*P7)*Math.sin(Q7+b8*R7),Y7.push(V7.x,V7.y,V7.z),W7.copy(V7).normalize(),Z7.push(W7.x,W7.y,W7.z),$7.push(e8+c8,1-b8),a8.push(T7++)}U7.push(a8)}for(let f8=0;f8<N7;f8++)for(let g8=0;g8<M7;g8++){const h8=U7[f8][g8+1],i8=U7[f8][g8],j8=U7[f8+1][g8],k8=U7[f8+1][g8+1];(0!==f8||Q7>0)&&X7.push(h8,i8,k8),(f8!==N7-1||S7<Math.PI)&&X7.push(i8,j8,k8)}this.setIndex(X7),this.setAttribute("position",new wC(Y7,3)),this.setAttribute("normal",new wC(Z7,3)),this.setAttribute("uv",new wC($7,2))}static fromJSON(l8){return new K7(l8.radius,l8.widthSegments,l8.heightSegments,l8.phiStart,l8.phiLength,l8.thetaStart,l8.thetaLength)}}class m8 extends DZ{constructor(n8=1,o8=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],n8,o8),this.type="TetrahedronGeometry",this.parameters={radius:n8,detail:o8}}static fromJSON(p8){return new m8(p8.radius,p8.detail)}}class q8 extends HC{constructor(r8=1,s8=0.4,t8=8,u8=6,v8=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:r8,tube:s8,radialSegments:t8,tubularSegments:u8,arc:v8},t8=Math.floor(t8),u8=Math.floor(u8);const w8=[],x8=[],y8=[],z8=[],A8=new Qi(),B8=new Qi(),C8=new Qi();for(let D8=0;D8<=t8;D8++)for(let E8=0;E8<=u8;E8++){const F8=E8/u8*v8,G8=D8/t8*Math.PI*2;B8.x=(r8+s8*Math.cos(G8))*Math.cos(F8),B8.y=(r8+s8*Math.cos(G8))*Math.sin(F8),B8.z=s8*Math.sin(G8),x8.push(B8.x,B8.y,B8.z),A8.x=r8*Math.cos(F8),A8.y=r8*Math.sin(F8),C8.subVectors(B8,A8).normalize(),y8.push(C8.x,C8.y,C8.z),z8.push(E8/u8),z8.push(D8/t8)}for(let H8=1;H8<=t8;H8++)for(let I8=1;I8<=u8;I8++){const J8=(u8+1)*H8+I8-1,K8=(u8+1)*(H8-1)+I8-1,L8=(u8+1)*(H8-1)+I8,M8=(u8+1)*H8+I8;w8.push(J8,K8,M8),w8.push(K8,L8,M8)}this.setIndex(w8),this.setAttribute("position",new wC(x8,3)),this.setAttribute("normal",new wC(y8,3)),this.setAttribute("uv",new wC(z8,2))}static fromJSON(N8){return new q8(N8.radius,N8.tube,N8.radialSegments,N8.tubularSegments,N8.arc)}}class O8 extends HC{constructor(P8=1,Q8=0.4,R8=64,S8=8,T8=2,U8=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:P8,tube:Q8,tubularSegments:R8,radialSegments:S8,p:T8,q:U8},R8=Math.floor(R8),S8=Math.floor(S8);const V8=[],W8=[],X8=[],Y8=[],Z8=new Qi(),$8=new Qi(),_8=new Qi(),a9=new Qi(),b9=new Qi(),c9=new Qi(),d9=new Qi();for(let e9=0;e9<=R8;++e9){const f9=e9/R8*T8*Math.PI*2;q9(f9,T8,U8,P8,_8),q9(f9+0.01,T8,U8,P8,a9),c9.subVectors(a9,_8),d9.addVectors(a9,_8),b9.crossVectors(c9,d9),d9.crossVectors(b9,c9),b9.normalize(),d9.normalize();for(let g9=0;g9<=S8;++g9){const h9=g9/S8*Math.PI*2,i9=-Q8*Math.cos(h9),j9=Q8*Math.sin(h9);Z8.x=_8.x+(i9*d9.x+j9*b9.x),Z8.y=_8.y+(i9*d9.y+j9*b9.y),Z8.z=_8.z+(i9*d9.z+j9*b9.z),W8.push(Z8.x,Z8.y,Z8.z),$8.subVectors(Z8,_8).normalize(),X8.push($8.x,$8.y,$8.z),Y8.push(e9/R8),Y8.push(g9/S8)}}for(let k9=1;k9<=R8;k9++)for(let l9=1;l9<=S8;l9++){const m9=(S8+1)*(k9-1)+(l9-1),n9=(S8+1)*k9+(l9-1),o9=(S8+1)*k9+l9,p9=(S8+1)*(k9-1)+l9;V8.push(m9,n9,p9),V8.push(n9,o9,p9)}function q9(a,b,c,d,e){const f=c/b*a,g=Math.cos(f);e.x=d*(2+g)*0.5*Math.cos(a),e.y=d*(2+g)*Math.sin(a)*0.5,e.z=d*Math.sin(f)*0.5}this.setIndex(V8),this.setAttribute("position",new wC(W8,3)),this.setAttribute("normal",new wC(X8,3)),this.setAttribute("uv",new wC(Y8,2))}static fromJSON(r9){return new O8(r9.radius,r9.tube,r9.tubularSegments,r9.radialSegments,r9.p,r9.q)}}class s9 extends HC{constructor(t9=new B1(new Qi(-1,-1,0),new Qi(-1,1,0),new Qi(1,1,0)),u9=64,v9=1,w9=8,x9=!1){super(),this.type="TubeGeometry",this.parameters={path:t9,tubularSegments:u9,radius:v9,radialSegments:w9,closed:x9};const y9=t9.computeFrenetFrames(u9,x9);this.tangents=y9.tangents,this.normals=y9.normals,this.binormals=y9.binormals;const z9=new Qi(),A9=new Qi(),B9=new da();let C9=new Qi();const D9=[],E9=[],F9=[],G9=[];function H9(a){C9=t9.getPointAt(a/u9,C9);const b=y9.normals[a],c=y9.binormals[a];for(let d=0;d<=w9;d++){const e=d/w9*Math.PI*2,f=Math.sin(e),g=-Math.cos(e);A9.x=g*b.x+f*c.x,A9.y=g*b.y+f*c.y,A9.z=g*b.z+f*c.z,A9.normalize(),E9.push(A9.x,A9.y,A9.z),z9.x=C9.x+v9*A9.x,z9.y=C9.y+v9*A9.y,z9.z=C9.z+v9*A9.z,D9.push(z9.x,z9.y,z9.z)}}(function(){for(let a=0;a<u9;a++)H9(a);H9(!1===x9?u9:0),(function(){for(let a=0;a<=u9;a++)for(let b=0;b<=w9;b++)B9.x=a/u9,B9.y=b/w9,F9.push(B9.x,B9.y)})(),(function(){for(let a=1;a<=u9;a++)for(let b=1;b<=w9;b++){const c=(w9+1)*(a-1)+(b-1),d=(w9+1)*a+(b-1),e=(w9+1)*a+b,f=(w9+1)*(a-1)+b;G9.push(c,d,f),G9.push(d,e,f)}})()})(),this.setIndex(G9),this.setAttribute("position",new wC(D9,3)),this.setAttribute("normal",new wC(E9,3)),this.setAttribute("uv",new wC(F9,2))}toJSON(){const I9=super.toJSON();return I9.path=this.parameters.path.toJSON(),I9}static fromJSON(J9){return new s9(new l2[J9.path.type]().fromJSON(J9.path),J9.tubularSegments,J9.radius,J9.radialSegments,J9.closed)}}function K9(a,b,c){const d=`${a.x},${a.y},${a.z}-${b.x},${b.y},${b.z}`,e=`${b.x},${b.y},${b.z}-${a.x},${a.y},${a.z}`;return!0!==c.has(d)&& !0!==c.has(e)&&(c.add(d,e),!0)}Object.freeze({__proto__:null,BoxGeometry:zH,BoxBufferGeometry:zH,CircleGeometry:MY,CircleBufferGeometry:MY,ConeGeometry:uZ,ConeBufferGeometry:uZ,CylinderGeometry:aZ,CylinderBufferGeometry:aZ,DodecahedronGeometry:RZ,DodecahedronBufferGeometry:RZ,EdgesGeometry:class extends HC{constructor(L9=null,M9=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:L9,thresholdAngle:M9},null!==L9){const N9=4,O9=Math.pow(10,N9),P9=Math.cos(S*M9),Q9=L9.getIndex(),R9=L9.getAttribute("position"),S9=Q9?Q9.count:R9.count,T9=[0,0,0],U9=["a","b","c"],V9=new Array(3),W9={},X9=[];for(let Y9=0;Y9<S9;Y9+=3){Q9?(T9[0]=Q9.getX(Y9),T9[1]=Q9.getX(Y9+1),T9[2]=Q9.getX(Y9+2)):(T9[0]=Y9,T9[1]=Y9+1,T9[2]=Y9+2);const{a:Z9,b:$9,c:_9}=$Z;if(Z9.fromBufferAttribute(R9,T9[0]),$9.fromBufferAttribute(R9,T9[1]),_9.fromBufferAttribute(R9,T9[2]),$Z.getNormal(ZZ),V9[0]=`${Math.round(Z9.x*O9)},${Math.round(Z9.y*O9)},${Math.round(Z9.z*O9)}`,V9[1]=`${Math.round($9.x*O9)},${Math.round($9.y*O9)},${Math.round($9.z*O9)}`,V9[2]=`${Math.round(_9.x*O9)},${Math.round(_9.y*O9)},${Math.round(_9.z*O9)}`,V9[0]!==V9[1]&&V9[1]!==V9[2]&&V9[2]!==V9[0])for(let aaa=0;aaa<3;aaa++){const baa=(aaa+1)%3,caa=V9[aaa],daa=V9[baa],eaa=$Z[U9[aaa]],faa=$Z[U9[baa]],gaa=`${caa}_${daa}`,haa=`${daa}_${caa}`;haa in W9&&W9[haa]?(ZZ.dot(W9[haa].normal)<=P9&&(X9.push(eaa.x,eaa.y,eaa.z),X9.push(faa.x,faa.y,faa.z)),W9[haa]=null):gaa in W9||(W9[gaa]={index0:T9[aaa],index1:T9[baa],normal:ZZ.clone()})}}for(const iaa in W9)if(W9[iaa]){const{index0:jaa,index1:kaa}=W9[iaa];XZ.fromBufferAttribute(R9,jaa),YZ.fromBufferAttribute(R9,kaa),X9.push(XZ.x,XZ.y,XZ.z),X9.push(YZ.x,YZ.y,YZ.z)}this.setAttribute("position",new wC(X9,3))}}},ExtrudeGeometry:J5,ExtrudeBufferGeometry:J5,IcosahedronGeometry:d6,IcosahedronBufferGeometry:d6,LatheGeometry:i6,LatheBufferGeometry:i6,OctahedronGeometry:N6,OctahedronBufferGeometry:N6,PlaneGeometry:xL,PlaneBufferGeometry:xL,PolyhedronGeometry:DZ,PolyhedronBufferGeometry:DZ,RingGeometry:R6,RingBufferGeometry:R6,ShapeGeometry:q7,ShapeBufferGeometry:q7,SphereGeometry:K7,SphereBufferGeometry:K7,TetrahedronGeometry:m8,TetrahedronBufferGeometry:m8,TorusGeometry:q8,TorusBufferGeometry:q8,TorusKnotGeometry:O8,TorusKnotBufferGeometry:O8,TubeGeometry:s9,TubeBufferGeometry:s9,WireframeGeometry:class extends HC{constructor(laa=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:laa},null!==laa){const maa=[],naa=new Set(),oaa=new Qi(),paa=new Qi();if(null!==laa.index){const qaa=laa.attributes.position,raa=laa.index;let saa=laa.groups;0===saa.length&&(saa=[{start:0,count:raa.count,materialIndex:0}]);for(let taa=0,uaa=saa.length;taa<uaa;++taa){const vaa=saa[taa],waa=vaa.start,xaa=vaa.count;for(let yaa=waa,zaa=waa+xaa;yaa<zaa;yaa+=3)for(let Aaa=0;Aaa<3;Aaa++){const Baa=raa.getX(yaa+Aaa),Caa=raa.getX(yaa+(Aaa+1)%3);oaa.fromBufferAttribute(qaa,Baa),paa.fromBufferAttribute(qaa,Caa),!0===K9(oaa,paa,naa)&&(maa.push(oaa.x,oaa.y,oaa.z),maa.push(paa.x,paa.y,paa.z))}}}else{const Daa=laa.attributes.position;for(let Eaa=0,Faa=Daa.count/3;Eaa<Faa;Eaa++)for(let Gaa=0;Gaa<3;Gaa++){const Haa=3*Eaa+Gaa,Iaa=3*Eaa+(Gaa+1)%3;oaa.fromBufferAttribute(Daa,Haa),paa.fromBufferAttribute(Daa,Iaa),!0===K9(oaa,paa,naa)&&(maa.push(oaa.x,oaa.y,oaa.z),maa.push(paa.x,paa.y,paa.z))}}this.setAttribute("position",new wC(maa,3))}}}});class Jaa extends Sy{constructor(Kaa){super(),this.type="ShadowMaterial",this.color=new oz(0),this.transparent=!0,this.setValues(Kaa)}copy(Laa){return super.copy(Laa),this.color.copy(Laa.color),this}}Jaa.prototype.isShadowMaterial=!0;class Maa extends Sy{constructor(Naa){super(),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new oz(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new oz(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=x,this.normalScale=new da(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=0.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(Naa)}copy(Oaa){return super.copy(Oaa),this.defines={STANDARD:""},this.color.copy(Oaa.color),this.roughness=Oaa.roughness,this.metalness=Oaa.metalness,this.map=Oaa.map,this.lightMap=Oaa.lightMap,this.lightMapIntensity=Oaa.lightMapIntensity,this.aoMap=Oaa.aoMap,this.aoMapIntensity=Oaa.aoMapIntensity,this.emissive.copy(Oaa.emissive),this.emissiveMap=Oaa.emissiveMap,this.emissiveIntensity=Oaa.emissiveIntensity,this.bumpMap=Oaa.bumpMap,this.bumpScale=Oaa.bumpScale,this.normalMap=Oaa.normalMap,this.normalMapType=Oaa.normalMapType,this.normalScale.copy(Oaa.normalScale),this.displacementMap=Oaa.displacementMap,this.displacementScale=Oaa.displacementScale,this.displacementBias=Oaa.displacementBias,this.roughnessMap=Oaa.roughnessMap,this.metalnessMap=Oaa.metalnessMap,this.alphaMap=Oaa.alphaMap,this.envMap=Oaa.envMap,this.envMapIntensity=Oaa.envMapIntensity,this.refractionRatio=Oaa.refractionRatio,this.wireframe=Oaa.wireframe,this.wireframeLinewidth=Oaa.wireframeLinewidth,this.wireframeLinecap=Oaa.wireframeLinecap,this.wireframeLinejoin=Oaa.wireframeLinejoin,this.flatShading=Oaa.flatShading,this}}Maa.prototype.isMeshStandardMaterial=!0;class Paa extends Maa{constructor(Qaa){super(),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new da(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Y(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(a){this.ior=(1+0.4*a)/(1-0.4*a)}}),this.sheenColor=new oz(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0.01,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new oz(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new oz(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(Qaa)}get sheen(){return this._sheen}set sheen(Raa){this._sheen>0!=Raa>0&&this.version++,this._sheen=Raa}get clearcoat(){return this._clearcoat}set clearcoat(Saa){this._clearcoat>0!=Saa>0&&this.version++,this._clearcoat=Saa}get transmission(){return this._transmission}set transmission(Taa){this._transmission>0!=Taa>0&&this.version++,this._transmission=Taa}copy(Uaa){return super.copy(Uaa),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=Uaa.clearcoat,this.clearcoatMap=Uaa.clearcoatMap,this.clearcoatRoughness=Uaa.clearcoatRoughness,this.clearcoatRoughnessMap=Uaa.clearcoatRoughnessMap,this.clearcoatNormalMap=Uaa.clearcoatNormalMap,this.clearcoatNormalScale.copy(Uaa.clearcoatNormalScale),this.ior=Uaa.ior,this.sheen=Uaa.sheen,this.sheenColor.copy(Uaa.sheenColor),this.sheenColorMap=Uaa.sheenColorMap,this.sheenRoughness=Uaa.sheenRoughness,this.sheenRoughnessMap=Uaa.sheenRoughnessMap,this.transmission=Uaa.transmission,this.transmissionMap=Uaa.transmissionMap,this.thickness=Uaa.thickness,this.thicknessMap=Uaa.thicknessMap,this.attenuationDistance=Uaa.attenuationDistance,this.attenuationColor.copy(Uaa.attenuationColor),this.specularIntensity=Uaa.specularIntensity,this.specularIntensityMap=Uaa.specularIntensityMap,this.specularColor.copy(Uaa.specularColor),this.specularColorMap=Uaa.specularColorMap,this}}Paa.prototype.isMeshPhysicalMaterial=!0;class Vaa extends Sy{constructor(Waa){super(),this.type="MeshPhongMaterial",this.color=new oz(16777215),this.specular=new oz(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new oz(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=x,this.normalScale=new da(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=0.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(Waa)}copy(Xaa){return super.copy(Xaa),this.color.copy(Xaa.color),this.specular.copy(Xaa.specular),this.shininess=Xaa.shininess,this.map=Xaa.map,this.lightMap=Xaa.lightMap,this.lightMapIntensity=Xaa.lightMapIntensity,this.aoMap=Xaa.aoMap,this.aoMapIntensity=Xaa.aoMapIntensity,this.emissive.copy(Xaa.emissive),this.emissiveMap=Xaa.emissiveMap,this.emissiveIntensity=Xaa.emissiveIntensity,this.bumpMap=Xaa.bumpMap,this.bumpScale=Xaa.bumpScale,this.normalMap=Xaa.normalMap,this.normalMapType=Xaa.normalMapType,this.normalScale.copy(Xaa.normalScale),this.displacementMap=Xaa.displacementMap,this.displacementScale=Xaa.displacementScale,this.displacementBias=Xaa.displacementBias,this.specularMap=Xaa.specularMap,this.alphaMap=Xaa.alphaMap,this.envMap=Xaa.envMap,this.combine=Xaa.combine,this.reflectivity=Xaa.reflectivity,this.refractionRatio=Xaa.refractionRatio,this.wireframe=Xaa.wireframe,this.wireframeLinewidth=Xaa.wireframeLinewidth,this.wireframeLinecap=Xaa.wireframeLinecap,this.wireframeLinejoin=Xaa.wireframeLinejoin,this.flatShading=Xaa.flatShading,this}}Vaa.prototype.isMeshPhongMaterial=!0;class Yaa extends Sy{constructor(Zaa){super(),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new oz(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new oz(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=x,this.normalScale=new da(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(Zaa)}copy($aa){return super.copy($aa),this.color.copy($aa.color),this.map=$aa.map,this.gradientMap=$aa.gradientMap,this.lightMap=$aa.lightMap,this.lightMapIntensity=$aa.lightMapIntensity,this.aoMap=$aa.aoMap,this.aoMapIntensity=$aa.aoMapIntensity,this.emissive.copy($aa.emissive),this.emissiveMap=$aa.emissiveMap,this.emissiveIntensity=$aa.emissiveIntensity,this.bumpMap=$aa.bumpMap,this.bumpScale=$aa.bumpScale,this.normalMap=$aa.normalMap,this.normalMapType=$aa.normalMapType,this.normalScale.copy($aa.normalScale),this.displacementMap=$aa.displacementMap,this.displacementScale=$aa.displacementScale,this.displacementBias=$aa.displacementBias,this.alphaMap=$aa.alphaMap,this.wireframe=$aa.wireframe,this.wireframeLinewidth=$aa.wireframeLinewidth,this.wireframeLinecap=$aa.wireframeLinecap,this.wireframeLinejoin=$aa.wireframeLinejoin,this}}Yaa.prototype.isMeshToonMaterial=!0;class _aa extends Sy{constructor(aba){super(),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=x,this.normalScale=new da(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(aba)}copy(bba){return super.copy(bba),this.bumpMap=bba.bumpMap,this.bumpScale=bba.bumpScale,this.normalMap=bba.normalMap,this.normalMapType=bba.normalMapType,this.normalScale.copy(bba.normalScale),this.displacementMap=bba.displacementMap,this.displacementScale=bba.displacementScale,this.displacementBias=bba.displacementBias,this.wireframe=bba.wireframe,this.wireframeLinewidth=bba.wireframeLinewidth,this.flatShading=bba.flatShading,this}}_aa.prototype.isMeshNormalMaterial=!0;class cba extends Sy{constructor(dba){super(),this.type="MeshLambertMaterial",this.color=new oz(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new oz(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=0,this.reflectivity=1,this.refractionRatio=0.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(dba)}copy(eba){return super.copy(eba),this.color.copy(eba.color),this.map=eba.map,this.lightMap=eba.lightMap,this.lightMapIntensity=eba.lightMapIntensity,this.aoMap=eba.aoMap,this.aoMapIntensity=eba.aoMapIntensity,this.emissive.copy(eba.emissive),this.emissiveMap=eba.emissiveMap,this.emissiveIntensity=eba.emissiveIntensity,this.specularMap=eba.specularMap,this.alphaMap=eba.alphaMap,this.envMap=eba.envMap,this.combine=eba.combine,this.reflectivity=eba.reflectivity,this.refractionRatio=eba.refractionRatio,this.wireframe=eba.wireframe,this.wireframeLinewidth=eba.wireframeLinewidth,this.wireframeLinecap=eba.wireframeLinecap,this.wireframeLinejoin=eba.wireframeLinejoin,this}}cba.prototype.isMeshLambertMaterial=!0;class fba extends Sy{constructor(gba){super(),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new oz(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=x,this.normalScale=new da(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(gba)}copy(hba){return super.copy(hba),this.defines={MATCAP:""},this.color.copy(hba.color),this.matcap=hba.matcap,this.map=hba.map,this.bumpMap=hba.bumpMap,this.bumpScale=hba.bumpScale,this.normalMap=hba.normalMap,this.normalMapType=hba.normalMapType,this.normalScale.copy(hba.normalScale),this.displacementMap=hba.displacementMap,this.displacementScale=hba.displacementScale,this.displacementBias=hba.displacementBias,this.alphaMap=hba.alphaMap,this.flatShading=hba.flatShading,this}}fba.prototype.isMeshMatcapMaterial=!0;class iba extends XV{constructor(jba){super(),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(jba)}copy(kba){return super.copy(kba),this.scale=kba.scale,this.dashSize=kba.dashSize,this.gapSize=kba.gapSize,this}}iba.prototype.isLineDashedMaterial=!0,Object.freeze({__proto__:null,ShadowMaterial:Jaa,SpriteMaterial:oT,RawShaderMaterial:HM,ShaderMaterial:SH,PointsMaterial:jX,MeshPhysicalMaterial:Paa,MeshStandardMaterial:Maa,MeshPhongMaterial:Vaa,MeshToonMaterial:Yaa,MeshNormalMaterial:_aa,MeshLambertMaterial:cba,MeshDepthMaterial:wQ,MeshDistanceMaterial:zQ,MeshBasicMaterial:JA,MeshMatcapMaterial:fba,LineDashedMaterial:iba,LineBasicMaterial:XV,Material:Sy});const lba={arraySlice:function(a,b,c){return lba.isTypedArray(a)?new a.constructor(a.subarray(b,void 0!==c?c:a.length)):a.slice(b,c)},convertArray:function(a,b,c){return a&&(c||a.constructor!==b)?"number"==typeof b.BYTES_PER_ELEMENT?new b(a):Array.prototype.slice.call(a):a},isTypedArray:function(a){return ArrayBuffer.isView(a)&&!(a instanceof DataView)},getKeyframeOrder:function(a){const b=a.length,c=new Array(b);for(let d=0;d!==b;++d)c[d]=d;return c.sort(function(b,c){return a[b]-a[c]}),c},sortedArray:function(a,b,c){const d=a.length,e=new a.constructor(d);for(let f=0,g=0;g!==d;++f){const h=c[f]*b;for(let i=0;i!==b;++i)e[g++]=a[h+i]}return e},flattenJSON:function(a,b,c,d){let e=1,f=a[0];for(;void 0!==f&& void 0===f[d];)f=a[e++];if(void 0===f)return;let g=f[d];if(void 0!==g)if(Array.isArray(g))do void 0!==(g=f[d])&&(b.push(f.time),c.push.apply(c,g)),f=a[e++];while(void 0!==f)else if(void 0!==g.toArray)do void 0!==(g=f[d])&&(b.push(f.time),g.toArray(c,c.length)),f=a[e++];while(void 0!==f)else do void 0!==(g=f[d])&&(b.push(f.time),c.push(g)),f=a[e++];while(void 0!==f)},subclip:function(a,b,c,d,e=30){const f=a.clone();f.name=b;const g=[];for(let h=0;h<f.tracks.length;++h){const i=f.tracks[h],j=i.getValueSize(),k=[],l=[];for(let m=0;m<i.times.length;++m){const n=i.times[m]*e;if(!(n<c)&&!(n>=d)){k.push(i.times[m]);for(let o=0;o<j;++o)l.push(i.values[m*j+o])}}0!==k.length&&(i.times=lba.convertArray(k,i.times.constructor),i.values=lba.convertArray(l,i.values.constructor),g.push(i))}f.tracks=g;let p=1/0;for(let q=0;q<f.tracks.length;++q)p>f.tracks[q].times[0]&&(p=f.tracks[q].times[0]);for(let r=0;r<f.tracks.length;++r)f.tracks[r].shift(-1*p);return f.resetDuration(),f},makeClipAdditive:function(a,b=0,c=a,d=30){d<=0&&(d=30);const e=c.tracks.length,f=b/d;for(let g=0;g<e;++g){const h=c.tracks[g],i=h.ValueTypeName;if("bool"===i||"string"===i)continue;const j=a.tracks.find(function(a){return a.name===h.name&&a.ValueTypeName===i});if(void 0===j)continue;let k=0;const l=h.getValueSize();h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(k=l/3);let m=0;const n=j.getValueSize();j.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(m=n/3);const o=h.times.length-1;let p;if(f<=h.times[0]){const q=k,r=l-k;p=lba.arraySlice(h.values,q,r)}else if(f>=h.times[o]){const s=o*l+k,t=s+l-k;p=lba.arraySlice(h.values,s,t)}else{const u=h.createInterpolant(),v=k,w=l-k;u.evaluate(f),p=lba.arraySlice(u.resultBuffer,v,w)}if("quaternion"===i){const x=new jg().fromArray(p).normalize().conjugate();x.toArray(p)}const y=j.times.length;for(let z=0;z<y;++z){const A=z*n+m;if("quaternion"===i)jg.multiplyQuaternionsFlat(j.values,A,p,0,j.values,A);else{const B=n-2*m;for(let C=0;C<B;++C)j.values[A+C]-=p[C]}}}return a.blendMode=2501,a}};class mba{constructor(nba,oba,pba,qba){this.parameterPositions=nba,this._cachedIndex=0,this.resultBuffer=void 0!==qba?qba:new oba.constructor(pba),this.sampleValues=oba,this.valueSize=pba,this.settings=null,this.DefaultSettings_={}}evaluate(rba){const sba=this.parameterPositions;let tba=this._cachedIndex,uba=sba[tba],vba=sba[tba-1];validate_interval:{seek:{let wba;linear_scan:{forward_scan:if(!(rba<uba)){for(let xba=tba+2;;){if(void 0===uba){if(rba<vba)break forward_scan;return tba=sba.length,this._cachedIndex=tba,this.afterEnd_(tba-1,rba,vba)}if(tba===xba)break;if(vba=uba,rba<(uba=sba[++tba]))break seek}wba=sba.length;break linear_scan}if(!(rba>=vba)){const yba=sba[1];rba<yba&&(tba=2,vba=yba);for(let zba=tba-2;;){if(void 0===vba)return this._cachedIndex=0,this.beforeStart_(0,rba,uba);if(tba===zba)break;if(uba=vba,rba>=(vba=sba[--tba-1]))break seek}wba=tba,tba=0;break linear_scan}break validate_interval}for(;tba<wba;){const Aba=tba+wba>>>1;rba<sba[Aba]?wba=Aba:tba=Aba+1}if(uba=sba[tba],vba=sba[tba-1],void 0===vba)return this._cachedIndex=0,this.beforeStart_(0,rba,uba);if(void 0===uba)return tba=sba.length,this._cachedIndex=tba,this.afterEnd_(tba-1,vba,rba)}this._cachedIndex=tba,this.intervalChanged_(tba,vba,uba)}return this.interpolate_(tba,vba,rba,uba)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(Bba){const Cba=this.resultBuffer,Dba=this.sampleValues,Eba=this.valueSize,Fba=Bba*Eba;for(let Gba=0;Gba!==Eba;++Gba)Cba[Gba]=Dba[Fba+Gba];return Cba}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}mba.prototype.beforeStart_=mba.prototype.copySampleValue_,mba.prototype.afterEnd_=mba.prototype.copySampleValue_;class Hba extends mba{constructor(Iba,Jba,Kba,Lba){super(Iba,Jba,Kba,Lba),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(Mba,Nba,Oba){const Pba=this.parameterPositions;let Qba=Mba-2,Rba=Mba+1,Sba=Pba[Qba],Tba=Pba[Rba];if(void 0===Sba)switch(this.getSettings_().endingStart){case 2401:Qba=Mba,Sba=2*Nba-Oba;break;case 2402:Qba=Pba.length-2,Sba=Nba+Pba[Qba]-Pba[Qba+1];break;default:Qba=Mba,Sba=Oba}if(void 0===Tba)switch(this.getSettings_().endingEnd){case 2401:Rba=Mba,Tba=2*Oba-Nba;break;case 2402:Rba=1,Tba=Oba+Pba[1]-Pba[0];break;default:Rba=Mba-1,Tba=Nba}const Uba=(Oba-Nba)*0.5,Vba=this.valueSize;this._weightPrev=Uba/(Nba-Sba),this._weightNext=Uba/(Tba-Oba),this._offsetPrev=Qba*Vba,this._offsetNext=Rba*Vba}interpolate_(Wba,Xba,Yba,Zba){const $ba=this.resultBuffer,_ba=this.sampleValues,aca=this.valueSize,bca=Wba*aca,cca=bca-aca,dca=this._offsetPrev,eca=this._offsetNext,fca=this._weightPrev,gca=this._weightNext,hca=(Yba-Xba)/(Zba-Xba),ica=hca*hca,jca=ica*hca,kca=-fca*jca+2*fca*ica-fca*hca,lca=(1+fca)*jca+(-1.5-2*fca)*ica+(-0.5+fca)*hca+1,mca=(-1-gca)*jca+(1.5+gca)*ica+0.5*hca,nca=gca*jca-gca*ica;for(let oca=0;oca!==aca;++oca)$ba[oca]=kca*_ba[dca+oca]+lca*_ba[cca+oca]+mca*_ba[bca+oca]+nca*_ba[eca+oca];return $ba}}class pca extends mba{constructor(qca,rca,sca,tca){super(qca,rca,sca,tca)}interpolate_(uca,vca,wca,xca){const yca=this.resultBuffer,zca=this.sampleValues,Aca=this.valueSize,Bca=uca*Aca,Cca=Bca-Aca,Dca=(wca-vca)/(xca-vca),Eca=1-Dca;for(let Fca=0;Fca!==Aca;++Fca)yca[Fca]=zca[Cca+Fca]*Eca+zca[Bca+Fca]*Dca;return yca}}class Gca extends mba{constructor(Hca,Ica,Jca,Kca){super(Hca,Ica,Jca,Kca)}interpolate_(Lca){return this.copySampleValue_(Lca-1)}}class Mca{constructor(Nca,Oca,Pca,Qca){if(void 0===Nca)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===Oca||0===Oca.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+Nca);this.name=Nca,this.times=lba.convertArray(Oca,this.TimeBufferType),this.values=lba.convertArray(Pca,this.ValueBufferType),this.setInterpolation(Qca||this.DefaultInterpolation)}static toJSON(Rca){const Sca=Rca.constructor;let Tca;if(Sca.toJSON!==this.toJSON)Tca=Sca.toJSON(Rca);else{Tca={name:Rca.name,times:lba.convertArray(Rca.times,Array),values:lba.convertArray(Rca.values,Array)};const Uca=Rca.getInterpolation();Uca!==Rca.DefaultInterpolation&&(Tca.interpolation=Uca)}return Tca.type=Rca.ValueTypeName,Tca}InterpolantFactoryMethodDiscrete(Vca){return new Gca(this.times,this.values,this.getValueSize(),Vca)}InterpolantFactoryMethodLinear(Wca){return new pca(this.times,this.values,this.getValueSize(),Wca)}InterpolantFactoryMethodSmooth(Xca){return new Hba(this.times,this.values,this.getValueSize(),Xca)}setInterpolation(Yca){let Zca;switch(Yca){case s:Zca=this.InterpolantFactoryMethodDiscrete;break;case t:Zca=this.InterpolantFactoryMethodLinear;break;case 2302:Zca=this.InterpolantFactoryMethodSmooth;break}if(void 0===Zca){const $ca="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant)if(Yca!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error($ca);return console.warn("THREE.KeyframeTrack:",$ca),this}return this.createInterpolant=Zca,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return s;case this.InterpolantFactoryMethodLinear:return t;case this.InterpolantFactoryMethodSmooth:return 2302}}getValueSize(){return this.values.length/this.times.length}shift(_ca){if(0!==_ca){const ada=this.times;for(let bda=0,cda=ada.length;bda!==cda;++bda)ada[bda]+=_ca}return this}scale(dda){if(1!==dda){const eda=this.times;for(let fda=0,gda=eda.length;fda!==gda;++fda)eda[fda]*=dda}return this}trim(hda,ida){const jda=this.times,kda=jda.length;let lda=0,mda=kda-1;for(;lda!==kda&&jda[lda]<hda;)++lda;for(;-1!==mda&&jda[mda]>ida;)--mda;if(++mda,0!==lda||mda!==kda){lda>=mda&&(lda=(mda=Math.max(mda,1))-1);const nda=this.getValueSize();this.times=lba.arraySlice(jda,lda,mda),this.values=lba.arraySlice(this.values,lda*nda,mda*nda)}return this}validate(){let oda=!0;const pda=this.getValueSize();pda-Math.floor(pda)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),oda=!1);const qda=this.times,rda=this.values,sda=qda.length;0===sda&&(console.error("THREE.KeyframeTrack: Track is empty.",this),oda=!1);let tda=null;for(let uda=0;uda!==sda;uda++){const vda=qda[uda];if("number"==typeof vda&&isNaN(vda)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,uda,vda),oda=!1;break}if(null!==tda&&tda>vda){console.error("THREE.KeyframeTrack: Out of order keys.",this,uda,vda,tda),oda=!1;break}tda=vda}if(void 0!==rda&&lba.isTypedArray(rda))for(let wda=0,xda=rda.length;wda!==xda;++wda){const yda=rda[wda];if(isNaN(yda)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,wda,yda),oda=!1;break}}return oda}optimize(){const zda=lba.arraySlice(this.times),Ada=lba.arraySlice(this.values),Bda=this.getValueSize(),Cda=2302===this.getInterpolation(),Dda=zda.length-1;let Eda=1;for(let Fda=1;Fda<Dda;++Fda){let Gda=!1;const Hda=zda[Fda],Ida=zda[Fda+1];if(Hda!==Ida&&(1!==Fda||Hda!==zda[0]))if(Cda)Gda=!0;else{const Jda=Fda*Bda,Kda=Jda-Bda,Lda=Jda+Bda;for(let Mda=0;Mda!==Bda;++Mda){const Nda=Ada[Jda+Mda];if(Nda!==Ada[Kda+Mda]||Nda!==Ada[Lda+Mda]){Gda=!0;break}}}if(Gda){if(Fda!==Eda){zda[Eda]=zda[Fda];const Oda=Fda*Bda,Pda=Eda*Bda;for(let Qda=0;Qda!==Bda;++Qda)Ada[Pda+Qda]=Ada[Oda+Qda]}++Eda}}if(Dda>0){zda[Eda]=zda[Dda];for(let Rda=Dda*Bda,Sda=Eda*Bda,Tda=0;Tda!==Bda;++Tda)Ada[Sda+Tda]=Ada[Rda+Tda];++Eda}return Eda!==zda.length?(this.times=lba.arraySlice(zda,0,Eda),this.values=lba.arraySlice(Ada,0,Eda*Bda)):(this.times=zda,this.values=Ada),this}clone(){const Uda=lba.arraySlice(this.times,0),Vda=lba.arraySlice(this.values,0),Wda=this.constructor,Xda=new Wda(this.name,Uda,Vda);return Xda.createInterpolant=this.createInterpolant,Xda}}Mca.prototype.TimeBufferType=Float32Array,Mca.prototype.ValueBufferType=Float32Array,Mca.prototype.DefaultInterpolation=t;class Yda extends Mca{}Yda.prototype.ValueTypeName="bool",Yda.prototype.ValueBufferType=Array,Yda.prototype.DefaultInterpolation=s,Yda.prototype.InterpolantFactoryMethodLinear=void 0,Yda.prototype.InterpolantFactoryMethodSmooth=void 0;class Zda extends Mca{}Zda.prototype.ValueTypeName="color";class $da extends Mca{}$da.prototype.ValueTypeName="number";class _da extends mba{constructor(aea,bea,cea,dea){super(aea,bea,cea,dea)}interpolate_(eea,fea,gea,hea){const iea=this.resultBuffer,jea=this.sampleValues,kea=this.valueSize,lea=(gea-fea)/(hea-fea);let mea=eea*kea;for(let nea=mea+kea;mea!==nea;mea+=4)jg.slerpFlat(iea,0,jea,mea-kea,jea,mea,lea);return iea}}class oea extends Mca{InterpolantFactoryMethodLinear(pea){return new _da(this.times,this.values,this.getValueSize(),pea)}}oea.prototype.ValueTypeName="quaternion",oea.prototype.DefaultInterpolation=t,oea.prototype.InterpolantFactoryMethodSmooth=void 0;class qea extends Mca{}qea.prototype.ValueTypeName="string",qea.prototype.ValueBufferType=Array,qea.prototype.DefaultInterpolation=s,qea.prototype.InterpolantFactoryMethodLinear=void 0,qea.prototype.InterpolantFactoryMethodSmooth=void 0;class rea extends Mca{}rea.prototype.ValueTypeName="vector";class sea{constructor(tea,uea=-1,vea,wea=2500){this.name=tea,this.tracks=vea,this.duration=uea,this.blendMode=wea,this.uuid=X(),this.duration<0&&this.resetDuration()}static parse(xea){const yea=[],zea=xea.tracks,Aea=1/(xea.fps||1);for(let Bea=0,Cea=zea.length;Bea!==Cea;++Bea)yea.push(Qfa(zea[Bea]).scale(Aea));const Dea=new this(xea.name,xea.duration,yea,xea.blendMode);return Dea.uuid=xea.uuid,Dea}static toJSON(Eea){const Fea=[],Gea=Eea.tracks,Hea={name:Eea.name,duration:Eea.duration,tracks:Fea,uuid:Eea.uuid,blendMode:Eea.blendMode};for(let Iea=0,Jea=Gea.length;Iea!==Jea;++Iea)Fea.push(Mca.toJSON(Gea[Iea]));return Hea}static CreateFromMorphTargetSequence(Kea,Lea,Mea,Nea){const Oea=Lea.length,Pea=[];for(let Qea=0;Qea<Oea;Qea++){let Rea=[],Sea=[];Rea.push((Qea+Oea-1)%Oea,Qea,(Qea+1)%Oea),Sea.push(0,1,0);const Tea=lba.getKeyframeOrder(Rea);Rea=lba.sortedArray(Rea,1,Tea),Sea=lba.sortedArray(Sea,1,Tea),Nea||0!==Rea[0]||(Rea.push(Oea),Sea.push(Sea[0])),Pea.push(new $da(".morphTargetInfluences["+Lea[Qea].name+"]",Rea,Sea).scale(1/Mea))}return new this(Kea,-1,Pea)}static findByName(Uea,Vea){let Wea=Uea;if(!Array.isArray(Uea)){const Xea=Uea;Wea=Xea.geometry&&Xea.geometry.animations||Xea.animations}for(let Yea=0;Yea<Wea.length;Yea++)if(Wea[Yea].name===Vea)return Wea[Yea];return null}static CreateClipsFromMorphTargetSequences(Zea,$ea,_ea){const afa={},bfa=/^([\w-]*?)([\d]+)$/;for(let cfa=0,dfa=Zea.length;cfa<dfa;cfa++){const efa=Zea[cfa],ffa=efa.name.match(bfa);if(ffa&&ffa.length>1){const gfa=ffa[1];let hfa=afa[gfa];hfa||(afa[gfa]=hfa=[]),hfa.push(efa)}}const ifa=[];for(const jfa in afa)ifa.push(this.CreateFromMorphTargetSequence(jfa,afa[jfa],$ea,_ea));return ifa}static parseAnimation(kfa,lfa){if(!kfa)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const mfa=function(a,b,c,d,e){if(0!==c.length){const f=[],g=[];lba.flattenJSON(c,f,g,d),0!==f.length&&e.push(new a(b,f,g))}},nfa=[],ofa=kfa.name||"default",pfa=kfa.fps||30,qfa=kfa.blendMode;let rfa=kfa.length|| -1;const sfa=kfa.hierarchy||[];for(let tfa=0;tfa<sfa.length;tfa++){const ufa=sfa[tfa].keys;if(ufa&&0!==ufa.length)if(ufa[0].morphTargets){const vfa={};let wfa;for(wfa=0;wfa<ufa.length;wfa++)if(ufa[wfa].morphTargets)for(let xfa=0;xfa<ufa[wfa].morphTargets.length;xfa++)vfa[ufa[wfa].morphTargets[xfa]]=-1;for(const yfa in vfa){const zfa=[],Afa=[];for(let Bfa=0;Bfa!==ufa[wfa].morphTargets.length;++Bfa){const Cfa=ufa[wfa];zfa.push(Cfa.time),Afa.push(Cfa.morphTarget===yfa?1:0)}nfa.push(new $da(".morphTargetInfluence["+yfa+"]",zfa,Afa))}rfa=vfa.length*(pfa||1)}else{const Dfa=".bones["+lfa[tfa].name+"]";mfa(rea,Dfa+".position",ufa,"pos",nfa),mfa(oea,Dfa+".quaternion",ufa,"rot",nfa),mfa(rea,Dfa+".scale",ufa,"scl",nfa)}}if(0===nfa.length)return null;const Efa=new this(ofa,rfa,nfa,qfa);return Efa}resetDuration(){const Ffa=this.tracks;let Gfa=0;for(let Hfa=0,Ifa=Ffa.length;Hfa!==Ifa;++Hfa){const Jfa=this.tracks[Hfa];Gfa=Math.max(Gfa,Jfa.times[Jfa.times.length-1])}return this.duration=Gfa,this}trim(){for(let Kfa=0;Kfa<this.tracks.length;Kfa++)this.tracks[Kfa].trim(0,this.duration);return this}validate(){let Lfa=!0;for(let Mfa=0;Mfa<this.tracks.length;Mfa++)Lfa=Lfa&&this.tracks[Mfa].validate();return Lfa}optimize(){for(let Nfa=0;Nfa<this.tracks.length;Nfa++)this.tracks[Nfa].optimize();return this}clone(){const Ofa=[];for(let Pfa=0;Pfa<this.tracks.length;Pfa++)Ofa.push(this.tracks[Pfa].clone());return new this.constructor(this.name,this.duration,Ofa,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Qfa(a){if(void 0===a.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const b=function(a){switch(a.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return $da;case"vector":case"vector2":case"vector3":case"vector4":return rea;case"color":return Zda;case"quaternion":return oea;case"bool":case"boolean":return Yda;case"string":return qea}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+a)}(a.type);if(void 0===a.times){const c=[],d=[];lba.flattenJSON(a.keys,c,d,"value"),a.times=c,a.values=d}return void 0!==b.parse?b.parse(a):new b(a.name,a.times,a.values,a.interpolation)}const Rfa={enabled:!1,files:{},add:function(a,b){!1!==this.enabled&&(this.files[a]=b)},get:function(a){if(!1!==this.enabled)return this.files[a]},remove:function(a){delete this.files[a]},clear:function(){this.files={}}},Sfa=new class{constructor(Tfa,Ufa,Vfa){const Wfa=this;let Xfa=!1,Yfa=0,Zfa=0,$fa;const _fa=[];this.onStart=void 0,this.onLoad=Tfa,this.onProgress=Ufa,this.onError=Vfa,this.itemStart=function(a){Zfa++,!1===Xfa&& void 0!==Wfa.onStart&&Wfa.onStart(a,Yfa,Zfa),Xfa=!0},this.itemEnd=function(a){Yfa++,void 0!==Wfa.onProgress&&Wfa.onProgress(a,Yfa,Zfa),Yfa===Zfa&&(Xfa=!1,void 0!==Wfa.onLoad&&Wfa.onLoad())},this.itemError=function(a){void 0!==Wfa.onError&&Wfa.onError(a)},this.resolveURL=function(a){return $fa?$fa(a):a},this.setURLModifier=function(a){return $fa=a,this},this.addHandler=function(a,b){return _fa.push(a,b),this},this.removeHandler=function(a){const b=_fa.indexOf(a);return -1!==b&&_fa.splice(b,2),this},this.getHandler=function(a){for(let b=0,c=_fa.length;b<c;b+=2){const d=_fa[b],e=_fa[b+1];if(d.global&&(d.lastIndex=0),d.test(a))return e}return null}}}();class aga{constructor(bga){this.manager=void 0!==bga?bga:Sfa,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(cga,dga){const ega=this;return new Promise(function(a,b){ega.load(cga,a,dga,b)})}parse(){}setCrossOrigin(fga){return this.crossOrigin=fga,this}setWithCredentials(gga){return this.withCredentials=gga,this}setPath(hga){return this.path=hga,this}setResourcePath(iga){return this.resourcePath=iga,this}setRequestHeader(jga){return this.requestHeader=jga,this}}const kga={};class lga extends aga{constructor(mga){super(mga)}load(nga,oga,pga,qga){void 0===nga&&(nga=""),void 0!==this.path&&(nga=this.path+nga),nga=this.manager.resolveURL(nga);const rga=Rfa.get(nga);if(void 0!==rga)return this.manager.itemStart(nga),setTimeout(()=>{oga&&oga(rga),this.manager.itemEnd(nga)},0),rga;if(void 0!==kga[nga]){kga[nga].push({onLoad:oga,onProgress:pga,onError:qga});return}kga[nga]=[],kga[nga].push({onLoad:oga,onProgress:pga,onError:qga});const sga=new Request(nga,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"});fetch(sga).then(a=>{if(200===a.status||0===a.status){0===a.status&&console.warn("THREE.FileLoader: HTTP Status 0 received.");const b=kga[nga],c=a.body.getReader(),d=a.headers.get("Content-Length"),e=d?parseInt(d):0,f=0!==e;let g=0;return new ReadableStream({start(a){d();function d(){c.read().then(({done:c,value:h})=>{if(c)a.close();else{g+=h.byteLength;const i=new ProgressEvent("progress",{lengthComputable:f,loaded:g,total:e});for(let j=0,k=b.length;j<k;j++){const l=b[j];l.onProgress&&l.onProgress(i)}a.enqueue(h),d()}})}}})}throw Error(`fetch for "${a.url}" responded with ${a.status}: ${a.statusText}`)}).then(a=>{const b=new Response(a);switch(this.responseType){case"arraybuffer":return b.arrayBuffer();case"blob":return b.blob();case"document":return b.text().then(a=>{const b=new DOMParser();return b.parseFromString(a,this.mimeType)});case"json":return b.json();default:return b.text()}}).then(a=>{Rfa.add(nga,a);const b=kga[nga];delete kga[nga];for(let c=0,d=b.length;c<d;c++){const e=b[c];e.onLoad&&e.onLoad(a)}this.manager.itemEnd(nga)}).catch(a=>{const b=kga[nga];delete kga[nga];for(let c=0,d=b.length;c<d;c++){const e=b[c];e.onError&&e.onError(a)}this.manager.itemError(nga),this.manager.itemEnd(nga)}),this.manager.itemStart(nga)}setResponseType(tga){return this.responseType=tga,this}setMimeType(uga){return this.mimeType=uga,this}}class vga extends aga{constructor(wga){super(wga)}load(xga,yga,zga,Aga){void 0!==this.path&&(xga=this.path+xga),xga=this.manager.resolveURL(xga);const Bga=this,Cga=Rfa.get(xga);if(void 0!==Cga)return Bga.manager.itemStart(xga),setTimeout(function(){yga&&yga(Cga),Bga.manager.itemEnd(xga)},0),Cga;const Dga=yd("img");function Ega(){Gga(),Rfa.add(xga,this),yga&&yga(this),Bga.manager.itemEnd(xga)}function Fga(a){Gga(),Aga&&Aga(a),Bga.manager.itemError(xga),Bga.manager.itemEnd(xga)}function Gga(){Dga.removeEventListener("load",Ega,!1),Dga.removeEventListener("error",Fga,!1)}return Dga.addEventListener("load",Ega,!1),Dga.addEventListener("error",Fga,!1),"data:"!==xga.substr(0,5)&& void 0!==this.crossOrigin&&(Dga.crossOrigin=this.crossOrigin),Bga.manager.itemStart(xga),Dga.src=xga,Dga}}class Hga extends aga{constructor(Iga){super(Iga)}load(Jga,Kga,Lga,Mga){const Nga=new dJ(),Oga=new vga(this.manager);Oga.setCrossOrigin(this.crossOrigin),Oga.setPath(this.path);let Pga=0;function Qga(a){Oga.load(Jga[a],function(b){Nga.images[a]=b,Pga++,6===Pga&&(Nga.needsUpdate=!0,Kga&&Kga(Nga))},void 0,Mga)}for(let Rga=0;Rga<Jga.length;++Rga)Qga(Rga);return Nga}}class Sga extends aga{constructor(Tga){super(Tga)}load(Uga,Vga,Wga,Xga){const Yga=new Gd(),Zga=new vga(this.manager);return Zga.setCrossOrigin(this.crossOrigin),Zga.setPath(this.path),Zga.load(Uga,function(a){Yga.image=a,Yga.needsUpdate=!0,void 0!==Vga&&Vga(Yga)},Wga,Xga),Yga}}class $ga extends hv{constructor(_ga,aha=1){super(),this.type="Light",this.color=new oz(_ga),this.intensity=aha}dispose(){}copy(bha){return super.copy(bha),this.color.copy(bha.color),this.intensity=bha.intensity,this}toJSON(cha){const dha=super.toJSON(cha);return dha.object.color=this.color.getHex(),dha.object.intensity=this.intensity,void 0!==this.groundColor&&(dha.object.groundColor=this.groundColor.getHex()),void 0!==this.distance&&(dha.object.distance=this.distance),void 0!==this.angle&&(dha.object.angle=this.angle),void 0!==this.decay&&(dha.object.decay=this.decay),void 0!==this.penumbra&&(dha.object.penumbra=this.penumbra),void 0!==this.shadow&&(dha.object.shadow=this.shadow.toJSON()),dha}}$ga.prototype.isLight=!0,(class extends $ga{constructor(eha,fha,gha){super(eha,gha),this.type="HemisphereLight",this.position.copy(hv.DefaultUp),this.updateMatrix(),this.groundColor=new oz(fha)}copy(hha){return $ga.prototype.copy.call(this,hha),this.groundColor.copy(hha.groundColor),this}}).prototype.isHemisphereLight=!0;const iha=new dp(),jha=new Qi(),kha=new Qi();class lha{constructor(mha){this.camera=mha,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new da(512,512),this.map=null,this.mapPass=null,this.matrix=new dp(),this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new xK(),this._frameExtents=new da(1,1),this._viewportCount=1,this._viewports=[new ae(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(nha){const oha=this.camera,pha=this.matrix;jha.setFromMatrixPosition(nha.matrixWorld),oha.position.copy(jha),kha.setFromMatrixPosition(nha.target.matrixWorld),oha.lookAt(kha),oha.updateMatrixWorld(),iha.multiplyMatrices(oha.projectionMatrix,oha.matrixWorldInverse),this._frustum.setFromProjectionMatrix(iha),pha.set(0.5,0,0,0.5,0,0.5,0,0.5,0,0,0.5,0.5,0,0,0,1),pha.multiply(oha.projectionMatrix),pha.multiply(oha.matrixWorldInverse)}getViewport(qha){return this._viewports[qha]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(rha){return this.camera=rha.camera.clone(),this.bias=rha.bias,this.radius=rha.radius,this.mapSize.copy(rha.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const sha={};return 0!==this.bias&&(sha.bias=this.bias),0!==this.normalBias&&(sha.normalBias=this.normalBias),1!==this.radius&&(sha.radius=this.radius),(512!==this.mapSize.x||512!==this.mapSize.y)&&(sha.mapSize=this.mapSize.toArray()),sha.camera=this.camera.toJSON(!1).object,delete sha.camera.matrix,sha}}class tha extends lha{constructor(){super(new iI(50,1,0.5,500)),this.focus=1}updateMatrices(uha){const vha=this.camera,wha=2*T*uha.angle*this.focus,xha=this.mapSize.width/this.mapSize.height,yha=uha.distance||vha.far;(wha!==vha.fov||xha!==vha.aspect||yha!==vha.far)&&(vha.fov=wha,vha.aspect=xha,vha.far=yha,vha.updateProjectionMatrix()),super.updateMatrices(uha)}copy(zha){return super.copy(zha),this.focus=zha.focus,this}}tha.prototype.isSpotLightShadow=!0;class Aha extends $ga{constructor(Bha,Cha,Dha=0,Eha=Math.PI/3,Fha=0,Gha=1){super(Bha,Cha),this.type="SpotLight",this.position.copy(hv.DefaultUp),this.updateMatrix(),this.target=new hv(),this.distance=Dha,this.angle=Eha,this.penumbra=Fha,this.decay=Gha,this.shadow=new tha()}get power(){return this.intensity*Math.PI}set power(Hha){this.intensity=Hha/Math.PI}dispose(){this.shadow.dispose()}copy(Iha){return super.copy(Iha),this.distance=Iha.distance,this.angle=Iha.angle,this.penumbra=Iha.penumbra,this.decay=Iha.decay,this.target=Iha.target.clone(),this.shadow=Iha.shadow.clone(),this}}Aha.prototype.isSpotLight=!0;const Jha=new dp(),Kha=new Qi(),Lha=new Qi();class Mha extends lha{constructor(){super(new iI(90,1,0.5,500)),this._frameExtents=new da(4,2),this._viewportCount=6,this._viewports=[new ae(2,1,1,1),new ae(0,1,1,1),new ae(3,1,1,1),new ae(1,1,1,1),new ae(3,0,1,1),new ae(1,0,1,1)],this._cubeDirections=[new Qi(1,0,0),new Qi(-1,0,0),new Qi(0,0,1),new Qi(0,0,-1),new Qi(0,1,0),new Qi(0,-1,0)],this._cubeUps=[new Qi(0,1,0),new Qi(0,1,0),new Qi(0,1,0),new Qi(0,1,0),new Qi(0,0,1),new Qi(0,0,-1)]}updateMatrices(Nha,Oha=0){const Pha=this.camera,Qha=this.matrix,Rha=Nha.distance||Pha.far;Rha!==Pha.far&&(Pha.far=Rha,Pha.updateProjectionMatrix()),Kha.setFromMatrixPosition(Nha.matrixWorld),Pha.position.copy(Kha),Lha.copy(Pha.position),Lha.add(this._cubeDirections[Oha]),Pha.up.copy(this._cubeUps[Oha]),Pha.lookAt(Lha),Pha.updateMatrixWorld(),Qha.makeTranslation(-Kha.x,-Kha.y,-Kha.z),Jha.multiplyMatrices(Pha.projectionMatrix,Pha.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Jha)}}Mha.prototype.isPointLightShadow=!0;class Sha extends $ga{constructor(Tha,Uha,Vha=0,Wha=1){super(Tha,Uha),this.type="PointLight",this.distance=Vha,this.decay=Wha,this.shadow=new Mha()}get power(){return 4*this.intensity*Math.PI}set power(Xha){this.intensity=Xha/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(Yha){return super.copy(Yha),this.distance=Yha.distance,this.decay=Yha.decay,this.shadow=Yha.shadow.clone(),this}}Sha.prototype.isPointLight=!0;class Zha extends lha{constructor(){super(new gM(-5,5,5,-5,0.5,500))}}Zha.prototype.isDirectionalLightShadow=!0;class $ha extends $ga{constructor(_ha,aia){super(_ha,aia),this.type="DirectionalLight",this.position.copy(hv.DefaultUp),this.updateMatrix(),this.target=new hv(),this.shadow=new Zha()}dispose(){this.shadow.dispose()}copy(bia){return super.copy(bia),this.target=bia.target.clone(),this.shadow=bia.shadow.clone(),this}}$ha.prototype.isDirectionalLight=!0;class cia extends $ga{constructor(dia,eia){super(dia,eia),this.type="AmbientLight"}}cia.prototype.isAmbientLight=!0,(class extends $ga{constructor(fia,gia,hia=10,iia=10){super(fia,gia),this.type="RectAreaLight",this.width=hia,this.height=iia}get power(){return this.intensity*this.width*this.height*Math.PI}set power(jia){this.intensity=jia/(this.width*this.height*Math.PI)}copy(kia){return super.copy(kia),this.width=kia.width,this.height=kia.height,this}toJSON(lia){const mia=super.toJSON(lia);return mia.object.width=this.width,mia.object.height=this.height,mia}}).prototype.isRectAreaLight=!0;class nia{constructor(){this.coefficients=[];for(let oia=0;oia<9;oia++)this.coefficients.push(new Qi())}set(pia){for(let qia=0;qia<9;qia++)this.coefficients[qia].copy(pia[qia]);return this}zero(){for(let ria=0;ria<9;ria++)this.coefficients[ria].set(0,0,0);return this}getAt(sia,tia){const uia=sia.x,via=sia.y,wia=sia.z,xia=this.coefficients;return tia.copy(xia[0]).multiplyScalar(0.282095),tia.addScaledVector(xia[1],0.488603*via),tia.addScaledVector(xia[2],0.488603*wia),tia.addScaledVector(xia[3],0.488603*uia),tia.addScaledVector(xia[4],1.092548*(uia*via)),tia.addScaledVector(xia[5],1.092548*(via*wia)),tia.addScaledVector(xia[6],0.315392*(3*wia*wia-1)),tia.addScaledVector(xia[7],1.092548*(uia*wia)),tia.addScaledVector(xia[8],0.546274*(uia*uia-via*via)),tia}getIrradianceAt(yia,zia){const Aia=yia.x,Bia=yia.y,Cia=yia.z,Dia=this.coefficients;return zia.copy(Dia[0]).multiplyScalar(0.886227),zia.addScaledVector(Dia[1],1.023328*Bia),zia.addScaledVector(Dia[2],1.023328*Cia),zia.addScaledVector(Dia[3],1.023328*Aia),zia.addScaledVector(Dia[4],0.858086*Aia*Bia),zia.addScaledVector(Dia[5],0.858086*Bia*Cia),zia.addScaledVector(Dia[6],0.743125*Cia*Cia-0.247708),zia.addScaledVector(Dia[7],0.858086*Aia*Cia),zia.addScaledVector(Dia[8],0.429043*(Aia*Aia-Bia*Bia)),zia}add(Eia){for(let Fia=0;Fia<9;Fia++)this.coefficients[Fia].add(Eia.coefficients[Fia]);return this}addScaledSH(Gia,Hia){for(let Iia=0;Iia<9;Iia++)this.coefficients[Iia].addScaledVector(Gia.coefficients[Iia],Hia);return this}scale(Jia){for(let Kia=0;Kia<9;Kia++)this.coefficients[Kia].multiplyScalar(Jia);return this}lerp(Lia,Mia){for(let Nia=0;Nia<9;Nia++)this.coefficients[Nia].lerp(Lia.coefficients[Nia],Mia);return this}equals(Oia){for(let Pia=0;Pia<9;Pia++)if(!this.coefficients[Pia].equals(Oia.coefficients[Pia]))return!1;return!0}copy(Qia){return this.set(Qia.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(Ria,Sia=0){const Tia=this.coefficients;for(let Uia=0;Uia<9;Uia++)Tia[Uia].fromArray(Ria,Sia+3*Uia);return this}toArray(Via=[],Wia=0){const Xia=this.coefficients;for(let Yia=0;Yia<9;Yia++)Xia[Yia].toArray(Via,Wia+3*Yia);return Via}static getBasisAt(Zia,$ia){const _ia=Zia.x,aja=Zia.y,bja=Zia.z;$ia[0]=0.282095,$ia[1]=0.488603*aja,$ia[2]=0.488603*bja,$ia[3]=0.488603*_ia,$ia[4]=1.092548*_ia*aja,$ia[5]=1.092548*aja*bja,$ia[6]=0.315392*(3*bja*bja-1),$ia[7]=1.092548*_ia*bja,$ia[8]=0.546274*(_ia*_ia-aja*aja)}}nia.prototype.isSphericalHarmonics3=!0;class cja extends $ga{constructor(dja=new nia(),eja=1){super(void 0,eja),this.sh=dja}copy(fja){return super.copy(fja),this.sh.copy(fja.sh),this}fromJSON(gja){return this.intensity=gja.intensity,this.sh.fromArray(gja.sh),this}toJSON(hja){const ija=super.toJSON(hja);return ija.object.sh=this.sh.toArray(),ija}}cja.prototype.isLightProbe=!0;class jja{static decodeText(kja){if("undefined"!=typeof TextDecoder)return new TextDecoder().decode(kja);let lja="";for(let mja=0,nja=kja.length;mja<nja;mja++)lja+=String.fromCharCode(kja[mja]);try{return decodeURIComponent(escape(lja))}catch(oja){return lja}}static extractUrlBase(pja){const qja=pja.lastIndexOf("/");return -1===qja?"./":pja.substr(0,qja+1)}static resolveURL(rja,sja){return"string"!=typeof rja||""===rja?"":(/^https?:\/\//i.test(sja)&&/^\//.test(rja)&&(sja=sja.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(rja))?rja:/^data:.*,.*$/i.test(rja)?rja:/^blob:.*$/i.test(rja)?rja:sja+rja}}(class extends HC{constructor(){super(),this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(tja){return super.copy(tja),this.instanceCount=tja.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const uja=super.toJSON(this);return uja.instanceCount=this.instanceCount,uja.isInstancedBufferGeometry=!0,uja}}).prototype.isInstancedBufferGeometry=!0;class vja extends aga{constructor(wja){super(wja),"undefined"==typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(xja){return this.options=xja,this}load(yja,zja,Aja,Bja){void 0===yja&&(yja=""),void 0!==this.path&&(yja=this.path+yja),yja=this.manager.resolveURL(yja);const Cja=this,Dja=Rfa.get(yja);if(void 0!==Dja)return Cja.manager.itemStart(yja),setTimeout(function(){zja&&zja(Dja),Cja.manager.itemEnd(yja)},0),Dja;const Eja={};Eja.credentials="anonymous"===this.crossOrigin?"same-origin":"include",Eja.headers=this.requestHeader,fetch(yja,Eja).then(function(a){return a.blob()}).then(function(a){return createImageBitmap(a,Object.assign(Cja.options,{colorSpaceConversion:"none"}))}).then(function(a){Rfa.add(yja,a),zja&&zja(a),Cja.manager.itemEnd(yja)}).catch(function(a){Bja&&Bja(a),Cja.manager.itemError(yja),Cja.manager.itemEnd(yja)}),Cja.manager.itemStart(yja)}}vja.prototype.isImageBitmapLoader=!0;let Fja;const Gja={getContext:function(){return void 0===Fja&&(Fja=new(window.AudioContext||window.webkitAudioContext)()),Fja},setContext:function(a){Fja=a}};class Hja extends aga{constructor(Ija){super(Ija)}load(Jja,Kja,Lja,Mja){const Nja=this,Oja=new lga(this.manager);Oja.setResponseType("arraybuffer"),Oja.setPath(this.path),Oja.setRequestHeader(this.requestHeader),Oja.setWithCredentials(this.withCredentials),Oja.load(Jja,function(a){try{const b=a.slice(0),c=Gja.getContext();c.decodeAudioData(b,function(a){Kja(a)})}catch(d){Mja?Mja(d):console.error(d),Nja.manager.itemError(Jja)}},Lja,Mja)}}(class extends cja{constructor(Pja,Qja,Rja=1){super(void 0,Rja);const Sja=new oz().set(Pja),Tja=new oz().set(Qja),Uja=new Qi(Sja.r,Sja.g,Sja.b),Vja=new Qi(Tja.r,Tja.g,Tja.b),Wja=Math.sqrt(Math.PI);this.sh.coefficients[0].copy(Uja).add(Vja).multiplyScalar(Wja),this.sh.coefficients[1].copy(Uja).sub(Vja).multiplyScalar(Wja*Math.sqrt(0.75))}}).prototype.isHemisphereLightProbe=!0,(class extends cja{constructor(Xja,Yja=1){super(void 0,Yja);const Zja=new oz().set(Xja);this.sh.coefficients[0].set(Zja.r,Zja.g,Zja.b).multiplyScalar(2*Math.sqrt(Math.PI))}}).prototype.isAmbientLightProbe=!0,new dp(),new dp(),new Qi(),new jg(),new Qi(),new Qi(),new Qi(),new jg(),new Qi(),new Qi();class $ja{constructor(_ja,aka,bka){this.binding=_ja,this.valueSize=bka;let cka,dka,eka;switch(aka){case"quaternion":cka=this._slerp,dka=this._slerpAdditive,eka=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*bka),this._workIndex=5;break;case"string":case"bool":cka=this._select,dka=this._select,eka=this._setAdditiveIdentityOther,this.buffer=new Array(5*bka);break;default:cka=this._lerp,dka=this._lerpAdditive,eka=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*bka)}this._mixBufferRegion=cka,this._mixBufferRegionAdditive=dka,this._setIdentity=eka,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(fka,gka){const hka=this.buffer,ika=this.valueSize,jka=fka*ika+ika;let kka=this.cumulativeWeight;if(0===kka){for(let lka=0;lka!==ika;++lka)hka[jka+lka]=hka[lka];kka=gka}else{kka+=gka;const mka=gka/kka;this._mixBufferRegion(hka,jka,0,mka,ika)}this.cumulativeWeight=kka}accumulateAdditive(nka){const oka=this.buffer,pka=this.valueSize,qka=pka*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(oka,qka,0,nka,pka),this.cumulativeWeightAdditive+=nka}apply(rka){const ska=this.valueSize,tka=this.buffer,uka=rka*ska+ska,vka=this.cumulativeWeight,wka=this.cumulativeWeightAdditive,xka=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,vka<1){const yka=ska*this._origIndex;this._mixBufferRegion(tka,uka,yka,1-vka,ska)}wka>0&&this._mixBufferRegionAdditive(tka,uka,this._addIndex*ska,1,ska);for(let zka=ska,Aka=ska+ska;zka!==Aka;++zka)if(tka[zka]!==tka[zka+ska]){xka.setValue(tka,uka);break}}saveOriginalState(){const Bka=this.binding,Cka=this.buffer,Dka=this.valueSize,Eka=Dka*this._origIndex;Bka.getValue(Cka,Eka);for(let Fka=Dka,Gka=Eka;Fka!==Gka;++Fka)Cka[Fka]=Cka[Eka+Fka%Dka];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const Hka=3*this.valueSize;this.binding.setValue(this.buffer,Hka)}_setAdditiveIdentityNumeric(){const Ika=this._addIndex*this.valueSize,Jka=Ika+this.valueSize;for(let Kka=Ika;Kka<Jka;Kka++)this.buffer[Kka]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const Lka=this._origIndex*this.valueSize,Mka=this._addIndex*this.valueSize;for(let Nka=0;Nka<this.valueSize;Nka++)this.buffer[Mka+Nka]=this.buffer[Lka+Nka]}_select(Oka,Pka,Qka,Rka,Ska){if(Rka>=0.5)for(let Tka=0;Tka!==Ska;++Tka)Oka[Pka+Tka]=Oka[Qka+Tka]}_slerp(Uka,Vka,Wka,Xka){jg.slerpFlat(Uka,Vka,Uka,Vka,Uka,Wka,Xka)}_slerpAdditive(Yka,Zka,$ka,_ka,ala){const bla=this._workIndex*ala;jg.multiplyQuaternionsFlat(Yka,bla,Yka,Zka,Yka,$ka),jg.slerpFlat(Yka,Zka,Yka,Zka,Yka,bla,_ka)}_lerp(cla,dla,ela,fla,gla){const hla=1-fla;for(let ila=0;ila!==gla;++ila){const jla=dla+ila;cla[jla]=cla[jla]*hla+cla[ela+ila]*fla}}_lerpAdditive(kla,lla,mla,nla,ola){for(let pla=0;pla!==ola;++pla){const qla=lla+pla;kla[qla]=kla[qla]+kla[mla+pla]*nla}}}const rla="\\[\\]\\.:\\/",sla=new RegExp("["+rla+"]","g"),tla="[^"+rla+"]",ula="[^"+rla.replace("\\.","")+"]",vla=/((?:WC+[\/:])*)/.source.replace("WC",tla),wla=/(WCOD+)?/.source.replace("WCOD",ula),xla=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",tla),yla=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",tla),zla=new RegExp("^"+vla+wla+xla+yla+"$"),Ala=["material","materials","bones"];class Bla{constructor(Cla,Dla,Ela){this.path=Dla,this.parsedPath=Ela||Bla.parseTrackName(Dla),this.node=Bla.findNode(Cla,this.parsedPath.nodeName)||Cla,this.rootNode=Cla,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(Fla,Gla,Hla){return Fla&&Fla.isAnimationObjectGroup?new Bla.Composite(Fla,Gla,Hla):new Bla(Fla,Gla,Hla)}static sanitizeNodeName(Ila){return Ila.replace(/\s/g,"_").replace(sla,"")}static parseTrackName(Jla){const Kla=zla.exec(Jla);if(!Kla)throw new Error("PropertyBinding: Cannot parse trackName: "+Jla);const Lla={nodeName:Kla[2],objectName:Kla[3],objectIndex:Kla[4],propertyName:Kla[5],propertyIndex:Kla[6]},Mla=Lla.nodeName&&Lla.nodeName.lastIndexOf(".");if(void 0!==Mla&& -1!==Mla){const Nla=Lla.nodeName.substring(Mla+1);-1!==Ala.indexOf(Nla)&&(Lla.nodeName=Lla.nodeName.substring(0,Mla),Lla.objectName=Nla)}if(null===Lla.propertyName||0===Lla.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+Jla);return Lla}static findNode(Ola,Pla){if(!Pla||""===Pla||"."===Pla|| -1===Pla||Pla===Ola.name||Pla===Ola.uuid)return Ola;if(Ola.skeleton){const Qla=Ola.skeleton.getBoneByName(Pla);if(void 0!==Qla)return Qla}if(Ola.children){const Rla=function(a){for(let b=0;b<a.length;b++){const c=a[b];if(c.name===Pla||c.uuid===Pla)return c;const d=Rla(c.children);if(d)return d}return null},Sla=Rla(Ola.children);if(Sla)return Sla}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(Tla,Ula){Tla[Ula]=this.targetObject[this.propertyName]}_getValue_array(Vla,Wla){const Xla=this.resolvedProperty;for(let Yla=0,Zla=Xla.length;Yla!==Zla;++Yla)Vla[Wla++]=Xla[Yla]}_getValue_arrayElement($la,_la){$la[_la]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(ama,bma){this.resolvedProperty.toArray(ama,bma)}_setValue_direct(cma,dma){this.targetObject[this.propertyName]=cma[dma]}_setValue_direct_setNeedsUpdate(ema,fma){this.targetObject[this.propertyName]=ema[fma],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(gma,hma){this.targetObject[this.propertyName]=gma[hma],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(ima,jma){const kma=this.resolvedProperty;for(let lma=0,mma=kma.length;lma!==mma;++lma)kma[lma]=ima[jma++]}_setValue_array_setNeedsUpdate(nma,oma){const pma=this.resolvedProperty;for(let qma=0,rma=pma.length;qma!==rma;++qma)pma[qma]=nma[oma++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(sma,tma){const uma=this.resolvedProperty;for(let vma=0,wma=uma.length;vma!==wma;++vma)uma[vma]=sma[tma++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(xma,yma){this.resolvedProperty[this.propertyIndex]=xma[yma]}_setValue_arrayElement_setNeedsUpdate(zma,Ama){this.resolvedProperty[this.propertyIndex]=zma[Ama],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(Bma,Cma){this.resolvedProperty[this.propertyIndex]=Bma[Cma],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(Dma,Ema){this.resolvedProperty.fromArray(Dma,Ema)}_setValue_fromArray_setNeedsUpdate(Fma,Gma){this.resolvedProperty.fromArray(Fma,Gma),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(Hma,Ima){this.resolvedProperty.fromArray(Hma,Ima),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(Jma,Kma){this.bind(),this.getValue(Jma,Kma)}_setValue_unbound(Lma,Mma){this.bind(),this.setValue(Lma,Mma)}bind(){let Nma=this.node;const Oma=this.parsedPath,Pma=Oma.objectName,Qma=Oma.propertyName;let Rma=Oma.propertyIndex;if(Nma||(Nma=Bla.findNode(this.rootNode,Oma.nodeName)||this.rootNode,this.node=Nma),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!Nma){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(Pma){let Sma=Oma.objectIndex;switch(Pma){case"materials":if(!Nma.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!Nma.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}Nma=Nma.material.materials;break;case"bones":if(!Nma.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}Nma=Nma.skeleton.bones;for(let Tma=0;Tma<Nma.length;Tma++)if(Nma[Tma].name===Sma){Sma=Tma;break}break;default:if(void 0===Nma[Pma]){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}Nma=Nma[Pma]}if(void 0!==Sma){if(void 0===Nma[Sma]){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,Nma);return}Nma=Nma[Sma]}}const Uma=Nma[Qma];if(void 0===Uma){const Vma=Oma.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+Vma+"."+Qma+" but it wasn't found.",Nma);return}let Wma=this.Versioning.None;this.targetObject=Nma,void 0!==Nma.needsUpdate?Wma=this.Versioning.NeedsUpdate:void 0!==Nma.matrixWorldNeedsUpdate&&(Wma=this.Versioning.MatrixWorldNeedsUpdate);let Xma=this.BindingType.Direct;if(void 0!==Rma){if("morphTargetInfluences"===Qma){if(!Nma.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(Nma.geometry.isBufferGeometry){if(!Nma.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}void 0!==Nma.morphTargetDictionary[Rma]&&(Rma=Nma.morphTargetDictionary[Rma])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}Xma=this.BindingType.ArrayElement,this.resolvedProperty=Uma,this.propertyIndex=Rma}else void 0!==Uma.fromArray&& void 0!==Uma.toArray?(Xma=this.BindingType.HasFromToArray,this.resolvedProperty=Uma):Array.isArray(Uma)?(Xma=this.BindingType.EntireArray,this.resolvedProperty=Uma):this.propertyName=Qma;this.getValue=this.GetterByBindingType[Xma],this.setValue=this.SetterByBindingTypeAndVersioning[Xma][Wma]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Bla.Composite=class{constructor(Yma,Zma,$ma){const _ma=$ma||Bla.parseTrackName(Zma);this._targetGroup=Yma,this._bindings=Yma.subscribe_(Zma,_ma)}getValue(ana,bna){this.bind();const cna=this._targetGroup.nCachedObjects_,dna=this._bindings[cna];void 0!==dna&&dna.getValue(ana,bna)}setValue(ena,fna){const gna=this._bindings;for(let hna=this._targetGroup.nCachedObjects_,ina=gna.length;hna!==ina;++hna)gna[hna].setValue(ena,fna)}bind(){const jna=this._bindings;for(let kna=this._targetGroup.nCachedObjects_,lna=jna.length;kna!==lna;++kna)jna[kna].bind()}unbind(){const mna=this._bindings;for(let nna=this._targetGroup.nCachedObjects_,ona=mna.length;nna!==ona;++nna)mna[nna].unbind()}},Bla.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Bla.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},Bla.prototype.GetterByBindingType=[Bla.prototype._getValue_direct,Bla.prototype._getValue_array,Bla.prototype._getValue_arrayElement,Bla.prototype._getValue_toArray,],Bla.prototype.SetterByBindingTypeAndVersioning=[[Bla.prototype._setValue_direct,Bla.prototype._setValue_direct_setNeedsUpdate,Bla.prototype._setValue_direct_setMatrixWorldNeedsUpdate,],[Bla.prototype._setValue_array,Bla.prototype._setValue_array_setNeedsUpdate,Bla.prototype._setValue_array_setMatrixWorldNeedsUpdate,],[Bla.prototype._setValue_arrayElement,Bla.prototype._setValue_arrayElement_setNeedsUpdate,Bla.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,],[Bla.prototype._setValue_fromArray,Bla.prototype._setValue_fromArray_setNeedsUpdate,Bla.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,]],(class{constructor(){this.uuid=X(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const pna={};this._indicesByUUID=pna;for(let qna=0,rna=arguments.length;qna!==rna;++qna)pna[arguments[qna].uuid]=qna;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={},this.stats={objects:{get total(){return this._objects.length},get inUse(){return this.total-this.nCachedObjects_}},get bindingsPerObject(){return this._bindings.length}}}add(){const sna=this._objects,tna=this._indicesByUUID,una=this._paths,vna=this._parsedPaths,wna=this._bindings,xna=wna.length;let yna,zna=sna.length,Ana=this.nCachedObjects_;for(let Bna=0,Cna=arguments.length;Bna!==Cna;++Bna){const Dna=arguments[Bna],Ena=Dna.uuid;let Fna=tna[Ena];if(void 0===Fna){Fna=zna++,tna[Ena]=Fna,sna.push(Dna);for(let Gna=0,Hna=xna;Gna!==Hna;++Gna)wna[Gna].push(new Bla(Dna,una[Gna],vna[Gna]))}else if(Fna<Ana){yna=sna[Fna];const Ina=--Ana,Jna=sna[Ina];tna[Jna.uuid]=Fna,sna[Fna]=Jna,tna[Ena]=Ina,sna[Ina]=Dna;for(let Kna=0,Lna=xna;Kna!==Lna;++Kna){const Mna=wna[Kna],Nna=Mna[Ina];let Ona=Mna[Fna];Mna[Fna]=Nna,void 0===Ona&&(Ona=new Bla(Dna,una[Kna],vna[Kna])),Mna[Ina]=Ona}}else sna[Fna]!==yna&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=Ana}remove(){const Pna=this._objects,Qna=this._indicesByUUID,Rna=this._bindings,Sna=Rna.length;let Tna=this.nCachedObjects_;for(let Una=0,Vna=arguments.length;Una!==Vna;++Una){const Wna=arguments[Una],Xna=Wna.uuid,Yna=Qna[Xna];if(void 0!==Yna&&Yna>=Tna){const Zna=Tna++,$na=Pna[Zna];Qna[$na.uuid]=Yna,Pna[Yna]=$na,Qna[Xna]=Zna,Pna[Zna]=Wna;for(let _na=0,aoa=Sna;_na!==aoa;++_na){const boa=Rna[_na],coa=boa[Zna],doa=boa[Yna];boa[Yna]=coa,boa[Zna]=doa}}}this.nCachedObjects_=Tna}uncache(){const eoa=this._objects,foa=this._indicesByUUID,goa=this._bindings,hoa=goa.length;let ioa=this.nCachedObjects_,joa=eoa.length;for(let koa=0,loa=arguments.length;koa!==loa;++koa){const moa=arguments[koa],noa=moa.uuid,ooa=foa[noa];if(void 0!==ooa)if(delete foa[noa],ooa<ioa){const poa=--ioa,qoa=eoa[poa],roa=--joa,soa=eoa[roa];foa[qoa.uuid]=ooa,eoa[ooa]=qoa,foa[soa.uuid]=poa,eoa[poa]=soa,eoa.pop();for(let toa=0,uoa=hoa;toa!==uoa;++toa){const voa=goa[toa],woa=voa[poa],xoa=voa[roa];voa[ooa]=woa,voa[poa]=xoa,voa.pop()}}else{const yoa=--joa,zoa=eoa[yoa];yoa>0&&(foa[zoa.uuid]=ooa),eoa[ooa]=zoa,eoa.pop();for(let Aoa=0,Boa=hoa;Aoa!==Boa;++Aoa){const Coa=goa[Aoa];Coa[ooa]=Coa[yoa],Coa.pop()}}}this.nCachedObjects_=ioa}subscribe_(Doa,Eoa){const Foa=this._bindingsIndicesByPath;let Goa=Foa[Doa];const Hoa=this._bindings;if(void 0!==Goa)return Hoa[Goa];const Ioa=this._paths,Joa=this._parsedPaths,Koa=this._objects,Loa=Koa.length,Moa=this.nCachedObjects_,Noa=new Array(Loa);Goa=Hoa.length,Foa[Doa]=Goa,Ioa.push(Doa),Joa.push(Eoa),Hoa.push(Noa);for(let Ooa=Moa,Poa=Koa.length;Ooa!==Poa;++Ooa){const Qoa=Koa[Ooa];Noa[Ooa]=new Bla(Qoa,Doa,Eoa)}return Noa}unsubscribe_(Roa){const Soa=this._bindingsIndicesByPath,Toa=Soa[Roa];if(void 0!==Toa){const Uoa=this._paths,Voa=this._parsedPaths,Woa=this._bindings,Xoa=Woa.length-1,Yoa=Woa[Xoa],Zoa=Roa[Xoa];Soa[Zoa]=Toa,Woa[Toa]=Yoa,Woa.pop(),Voa[Toa]=Voa[Xoa],Voa.pop(),Uoa[Toa]=Uoa[Xoa],Uoa.pop()}}}).prototype.isAnimationObjectGroup=!0;class $oa{constructor(_oa,apa,bpa=null,cpa=apa.blendMode){this._mixer=_oa,this._clip=apa,this._localRoot=bpa,this.blendMode=cpa;const dpa=apa.tracks,epa=dpa.length,fpa=new Array(epa),gpa={endingStart:2400,endingEnd:2400};for(let hpa=0;hpa!==epa;++hpa){const ipa=dpa[hpa].createInterpolant(null);fpa[hpa]=ipa,ipa.settings=gpa}this._interpolantSettings=gpa,this._interpolants=fpa,this._propertyBindings=new Array(epa),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(jpa){return this._startTime=jpa,this}setLoop(kpa,lpa){return this.loop=kpa,this.repetitions=lpa,this}setEffectiveWeight(mpa){return this.weight=mpa,this._effectiveWeight=this.enabled?mpa:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(npa){return this._scheduleFading(npa,0,1)}fadeOut(opa){return this._scheduleFading(opa,1,0)}crossFadeFrom(ppa,qpa,rpa){if(ppa.fadeOut(qpa),this.fadeIn(qpa),rpa){const spa=this._clip.duration,tpa=ppa._clip.duration,upa=tpa/spa,vpa=spa/tpa;ppa.warp(1,upa,qpa),this.warp(vpa,1,qpa)}return this}crossFadeTo(wpa,xpa,ypa){return wpa.crossFadeFrom(this,xpa,ypa)}stopFading(){const zpa=this._weightInterpolant;return null!==zpa&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(zpa)),this}setEffectiveTimeScale(Apa){return this.timeScale=Apa,this._effectiveTimeScale=this.paused?0:Apa,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(Bpa){return this.timeScale=this._clip.duration/Bpa,this.stopWarping()}syncWith(Cpa){return this.time=Cpa.time,this.timeScale=Cpa.timeScale,this.stopWarping()}halt(Dpa){return this.warp(this._effectiveTimeScale,0,Dpa)}warp(Epa,Fpa,Gpa){const Hpa=this._mixer,Ipa=Hpa.time,Jpa=this.timeScale;let Kpa=this._timeScaleInterpolant;null===Kpa&&(Kpa=Hpa._lendControlInterpolant(),this._timeScaleInterpolant=Kpa);const Lpa=Kpa.parameterPositions,Mpa=Kpa.sampleValues;return Lpa[0]=Ipa,Lpa[1]=Ipa+Gpa,Mpa[0]=Epa/Jpa,Mpa[1]=Fpa/Jpa,this}stopWarping(){const Npa=this._timeScaleInterpolant;return null!==Npa&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(Npa)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(Opa,Ppa,Qpa,Rpa){if(!this.enabled){this._updateWeight(Opa);return}const Spa=this._startTime;if(null!==Spa){const Tpa=(Opa-Spa)*Qpa;if(Tpa<0||0===Qpa)return;this._startTime=null,Ppa=Qpa*Tpa}Ppa*=this._updateTimeScale(Opa);const Upa=this._updateTime(Ppa),Vpa=this._updateWeight(Opa);if(Vpa>0){const Wpa=this._interpolants,Xpa=this._propertyBindings;switch(this.blendMode){case 2501:for(let Ypa=0,Zpa=Wpa.length;Ypa!==Zpa;++Ypa)Wpa[Ypa].evaluate(Upa),Xpa[Ypa].accumulateAdditive(Vpa);break;case 2500:default:for(let $pa=0,_pa=Wpa.length;$pa!==_pa;++$pa)Wpa[$pa].evaluate(Upa),Xpa[$pa].accumulate(Rpa,Vpa)}}}_updateWeight(aqa){let bqa=0;if(this.enabled){bqa=this.weight;const cqa=this._weightInterpolant;if(null!==cqa){const dqa=cqa.evaluate(aqa)[0];bqa*=dqa,aqa>cqa.parameterPositions[1]&&(this.stopFading(),0===dqa&&(this.enabled=!1))}}return this._effectiveWeight=bqa,bqa}_updateTimeScale(eqa){let fqa=0;if(!this.paused){fqa=this.timeScale;const gqa=this._timeScaleInterpolant;if(null!==gqa){const hqa=gqa.evaluate(eqa)[0];fqa*=hqa,eqa>gqa.parameterPositions[1]&&(this.stopWarping(),0===fqa?this.paused=!0:this.timeScale=fqa)}}return this._effectiveTimeScale=fqa,fqa}_updateTime(iqa){const jqa=this._clip.duration,kqa=this.loop;let lqa=this.time+iqa,mqa=this._loopCount;const nqa=2202===kqa;if(0===iqa)return -1===mqa?lqa:nqa&&(1&mqa)==1?jqa-lqa:lqa;if(2200===kqa){-1===mqa&&(this._loopCount=0,this._setEndings(!0,!0,!1));handle_stop:{if(lqa>=jqa)lqa=jqa;else if(lqa<0)lqa=0;else{this.time=lqa;break handle_stop}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=lqa,this._mixer.dispatchEvent({type:"finished",action:this,direction:iqa<0?-1:1})}}else{if(-1===mqa&&(iqa>=0?(mqa=0,this._setEndings(!0,0===this.repetitions,nqa)):this._setEndings(0===this.repetitions,!0,nqa)),lqa>=jqa||lqa<0){const oqa=Math.floor(lqa/jqa);lqa-=jqa*oqa,mqa+=Math.abs(oqa);const pqa=this.repetitions-mqa;if(pqa<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,lqa=iqa>0?jqa:0,this.time=lqa,this._mixer.dispatchEvent({type:"finished",action:this,direction:iqa>0?1:-1});else{if(1===pqa){const qqa=iqa<0;this._setEndings(qqa,!qqa,nqa)}else this._setEndings(!1,!1,nqa);this._loopCount=mqa,this.time=lqa,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:oqa})}}else this.time=lqa;if(nqa&&(1&mqa)==1)return jqa-lqa}return lqa}_setEndings(rqa,sqa,tqa){const uqa=this._interpolantSettings;tqa?(uqa.endingStart=2401,uqa.endingEnd=2401):(rqa?uqa.endingStart=this.zeroSlopeAtStart?2401:2400:uqa.endingStart=2402,sqa?uqa.endingEnd=this.zeroSlopeAtEnd?2401:2400:uqa.endingEnd=2402)}_scheduleFading(vqa,wqa,xqa){const yqa=this._mixer,zqa=yqa.time;let Aqa=this._weightInterpolant;null===Aqa&&(Aqa=yqa._lendControlInterpolant(),this._weightInterpolant=Aqa);const Bqa=Aqa.parameterPositions,Cqa=Aqa.sampleValues;return Bqa[0]=zqa,Cqa[0]=wqa,Bqa[1]=zqa+vqa,Cqa[1]=xqa,this}}(class extends z{constructor(Dqa){super(),this._root=Dqa,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(Eqa,Fqa){const Gqa=Eqa._localRoot||this._root,Hqa=Eqa._clip.tracks,Iqa=Hqa.length,Jqa=Eqa._propertyBindings,Kqa=Eqa._interpolants,Lqa=Gqa.uuid,Mqa=this._bindingsByRootAndName;let Nqa=Mqa[Lqa];void 0===Nqa&&(Nqa={},Mqa[Lqa]=Nqa);for(let Oqa=0;Oqa!==Iqa;++Oqa){const Pqa=Hqa[Oqa],Qqa=Pqa.name;let Rqa=Nqa[Qqa];if(void 0!==Rqa)Jqa[Oqa]=Rqa;else{if(void 0!==(Rqa=Jqa[Oqa])){null===Rqa._cacheIndex&&(++Rqa.referenceCount,this._addInactiveBinding(Rqa,Lqa,Qqa));continue}const Sqa=Fqa&&Fqa._propertyBindings[Oqa].binding.parsedPath;Rqa=new $ja(Bla.create(Gqa,Qqa,Sqa),Pqa.ValueTypeName,Pqa.getValueSize()),++Rqa.referenceCount,this._addInactiveBinding(Rqa,Lqa,Qqa),Jqa[Oqa]=Rqa}Kqa[Oqa].resultBuffer=Rqa.buffer}}_activateAction(Tqa){if(!this._isActiveAction(Tqa)){if(null===Tqa._cacheIndex){const Uqa=(Tqa._localRoot||this._root).uuid,Vqa=Tqa._clip.uuid,Wqa=this._actionsByClip[Vqa];this._bindAction(Tqa,Wqa&&Wqa.knownActions[0]),this._addInactiveAction(Tqa,Vqa,Uqa)}const Xqa=Tqa._propertyBindings;for(let Yqa=0,Zqa=Xqa.length;Yqa!==Zqa;++Yqa){const $qa=Xqa[Yqa];0==$qa.useCount++&&(this._lendBinding($qa),$qa.saveOriginalState())}this._lendAction(Tqa)}}_deactivateAction(_qa){if(this._isActiveAction(_qa)){const ara=_qa._propertyBindings;for(let bra=0,cra=ara.length;bra!==cra;++bra){const dra=ara[bra];0== --dra.useCount&&(dra.restoreOriginalState(),this._takeBackBinding(dra))}this._takeBackAction(_qa)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0,this.stats={actions:{get total(){return this._actions.length},get inUse(){return this._nActiveActions}},bindings:{get total(){return this._bindings.length},get inUse(){return this._nActiveBindings}},controlInterpolants:{get total(){return this._controlInterpolants.length},get inUse(){return this._nActiveControlInterpolants}}}}_isActiveAction(era){const fra=era._cacheIndex;return null!==fra&&fra<this._nActiveActions}_addInactiveAction(gra,hra,ira){const jra=this._actions,kra=this._actionsByClip;let lra=kra[hra];if(void 0===lra)lra={knownActions:[gra],actionByRoot:{}},gra._byClipCacheIndex=0,kra[hra]=lra;else{const mra=lra.knownActions;gra._byClipCacheIndex=mra.length,mra.push(gra)}gra._cacheIndex=jra.length,jra.push(gra),lra.actionByRoot[ira]=gra}_removeInactiveAction(nra){const ora=this._actions,pra=ora[ora.length-1],qra=nra._cacheIndex;pra._cacheIndex=qra,ora[qra]=pra,ora.pop(),nra._cacheIndex=null;const rra=nra._clip.uuid,sra=this._actionsByClip,tra=sra[rra],ura=tra.knownActions,vra=ura[ura.length-1],wra=nra._byClipCacheIndex;vra._byClipCacheIndex=wra,ura[wra]=vra,ura.pop(),nra._byClipCacheIndex=null;const xra=tra.actionByRoot,yra=(nra._localRoot||this._root).uuid;delete xra[yra],0===ura.length&&delete sra[rra],this._removeInactiveBindingsForAction(nra)}_removeInactiveBindingsForAction(zra){const Ara=zra._propertyBindings;for(let Bra=0,Cra=Ara.length;Bra!==Cra;++Bra){const Dra=Ara[Bra];0== --Dra.referenceCount&&this._removeInactiveBinding(Dra)}}_lendAction(Era){const Fra=this._actions,Gra=Era._cacheIndex,Hra=this._nActiveActions++,Ira=Fra[Hra];Era._cacheIndex=Hra,Fra[Hra]=Era,Ira._cacheIndex=Gra,Fra[Gra]=Ira}_takeBackAction(Jra){const Kra=this._actions,Lra=Jra._cacheIndex,Mra=--this._nActiveActions,Nra=Kra[Mra];Jra._cacheIndex=Mra,Kra[Mra]=Jra,Nra._cacheIndex=Lra,Kra[Lra]=Nra}_addInactiveBinding(Ora,Pra,Qra){const Rra=this._bindingsByRootAndName,Sra=this._bindings;let Tra=Rra[Pra];void 0===Tra&&(Tra={},Rra[Pra]=Tra),Tra[Qra]=Ora,Ora._cacheIndex=Sra.length,Sra.push(Ora)}_removeInactiveBinding(Ura){const Vra=this._bindings,Wra=Ura.binding,Xra=Wra.rootNode.uuid,Yra=Wra.path,Zra=this._bindingsByRootAndName,$ra=Zra[Xra],_ra=Vra[Vra.length-1],asa=Ura._cacheIndex;_ra._cacheIndex=asa,Vra[asa]=_ra,Vra.pop(),delete $ra[Yra],0===Object.keys($ra).length&&delete Zra[Xra]}_lendBinding(bsa){const csa=this._bindings,dsa=bsa._cacheIndex,esa=this._nActiveBindings++,fsa=csa[esa];bsa._cacheIndex=esa,csa[esa]=bsa,fsa._cacheIndex=dsa,csa[dsa]=fsa}_takeBackBinding(gsa){const hsa=this._bindings,isa=gsa._cacheIndex,jsa=--this._nActiveBindings,ksa=hsa[jsa];gsa._cacheIndex=jsa,hsa[jsa]=gsa,ksa._cacheIndex=isa,hsa[isa]=ksa}_lendControlInterpolant(){const lsa=this._controlInterpolants,msa=this._nActiveControlInterpolants++;let nsa=lsa[msa];return void 0===nsa&&((nsa=new pca(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer)).__cacheIndex=msa,lsa[msa]=nsa),nsa}_takeBackControlInterpolant(osa){const psa=this._controlInterpolants,qsa=osa.__cacheIndex,rsa=--this._nActiveControlInterpolants,ssa=psa[rsa];osa.__cacheIndex=rsa,psa[rsa]=osa,ssa.__cacheIndex=qsa,psa[qsa]=ssa}clipAction(tsa,usa,vsa){const wsa=usa||this._root,xsa=wsa.uuid;let ysa="string"==typeof tsa?sea.findByName(wsa,tsa):tsa;const zsa=null!==ysa?ysa.uuid:tsa,Asa=this._actionsByClip[zsa];let Bsa=null;if(void 0===vsa&&(vsa=null!==ysa?ysa.blendMode:2500),void 0!==Asa){const Csa=Asa.actionByRoot[xsa];if(void 0!==Csa&&Csa.blendMode===vsa)return Csa;Bsa=Asa.knownActions[0],null===ysa&&(ysa=Bsa._clip)}if(null===ysa)return null;const Dsa=new $oa(this,ysa,usa,vsa);return this._bindAction(Dsa,Bsa),this._addInactiveAction(Dsa,zsa,xsa),Dsa}existingAction(Esa,Fsa){const Gsa=Fsa||this._root,Hsa=Gsa.uuid,Isa="string"==typeof Esa?sea.findByName(Gsa,Esa):Esa,Jsa=Isa?Isa.uuid:Esa,Ksa=this._actionsByClip[Jsa];return void 0!==Ksa?Ksa.actionByRoot[Hsa]||null:null}stopAllAction(){const Lsa=this._actions,Msa=this._nActiveActions;for(let Nsa=Msa-1;Nsa>=0;--Nsa)Lsa[Nsa].stop();return this}update(Osa){Osa*=this.timeScale;const Psa=this._actions,Qsa=this._nActiveActions,Rsa=this.time+=Osa,Ssa=Math.sign(Osa),Tsa=this._accuIndex^=1;for(let Usa=0;Usa!==Qsa;++Usa){const Vsa=Psa[Usa];Vsa._update(Rsa,Osa,Ssa,Tsa)}const Wsa=this._bindings,Xsa=this._nActiveBindings;for(let Ysa=0;Ysa!==Xsa;++Ysa)Wsa[Ysa].apply(Tsa);return this}setTime(Zsa){this.time=0;for(let $sa=0;$sa<this._actions.length;$sa++)this._actions[$sa].time=0;return this.update(Zsa)}getRoot(){return this._root}uncacheClip(_sa){const ata=this._actions,bta=_sa.uuid,cta=this._actionsByClip,dta=cta[bta];if(void 0!==dta){const eta=dta.knownActions;for(let fta=0,gta=eta.length;fta!==gta;++fta){const hta=eta[fta];this._deactivateAction(hta);const ita=hta._cacheIndex,jta=ata[ata.length-1];hta._cacheIndex=null,hta._byClipCacheIndex=null,jta._cacheIndex=ita,ata[ita]=jta,ata.pop(),this._removeInactiveBindingsForAction(hta)}delete cta[bta]}}uncacheRoot(kta){const lta=kta.uuid,mta=this._actionsByClip;for(const nta in mta){const ota=mta[nta].actionByRoot,pta=ota[lta];void 0!==pta&&(this._deactivateAction(pta),this._removeInactiveAction(pta))}const qta=this._bindingsByRootAndName,rta=qta[lta];if(void 0!==rta)for(const sta in rta){const tta=rta[sta];tta.restoreOriginalState(),this._removeInactiveBinding(tta)}}uncacheAction(uta,vta){const wta=this.existingAction(uta,vta);null!==wta&&(this._deactivateAction(wta),this._removeInactiveAction(wta))}}).prototype._controlInterpolantsResultBuffer=new Float32Array(1);class xta{constructor(yta){"string"==typeof yta&&(console.warn("THREE.Uniform: Type parameter is no longer needed."),yta=arguments[1]),this.value=yta}clone(){return new xta(void 0===this.value.clone?this.value:this.value.clone())}}function zta(a,b,c,d){if(a.layers.test(b.layers)&&a.raycast(b,c),!0===d){const e=a.children;for(let f=0,g=e.length;f<g;f++)zta(e[f],b,c,!0)}}(class extends aS{constructor(Ata,Bta,Cta=1){super(Ata,Bta),this.meshPerAttribute=Cta}copy(Dta){return super.copy(Dta),this.meshPerAttribute=Dta.meshPerAttribute,this}clone(Eta){const Fta=super.clone(Eta);return Fta.meshPerAttribute=this.meshPerAttribute,Fta}toJSON(Gta){const Hta=super.toJSON(Gta);return Hta.isInstancedInterleavedBuffer=!0,Hta.meshPerAttribute=this.meshPerAttribute,Hta}}).prototype.isInstancedInterleavedBuffer=!0,(class{constructor(Ita,Jta,Kta,Lta,Mta){this.buffer=Ita,this.type=Jta,this.itemSize=Kta,this.elementSize=Lta,this.count=Mta,this.version=0}set needsUpdate(Nta){!0===Nta&&this.version++}setBuffer(Ota){return this.buffer=Ota,this}setType(Pta,Qta){return this.type=Pta,this.elementSize=Qta,this}setItemSize(Rta){return this.itemSize=Rta,this}setCount(Sta){return this.count=Sta,this}}).prototype.isGLBufferAttribute=!0;class Tta{constructor(Uta=1,Vta=0,Wta=0){return this.radius=Uta,this.phi=Vta,this.theta=Wta,this}set(Xta,Yta,Zta){return this.radius=Xta,this.phi=Yta,this.theta=Zta,this}copy($ta){return this.radius=$ta.radius,this.phi=$ta.phi,this.theta=$ta.theta,this}makeSafe(){return this.phi=Math.max(0.000001,Math.min(Math.PI-0.000001,this.phi)),this}setFromVector3(_ta){return this.setFromCartesianCoords(_ta.x,_ta.y,_ta.z)}setFromCartesianCoords(aua,bua,cua){return this.radius=Math.sqrt(aua*aua+bua*bua+cua*cua),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(aua,cua),this.phi=Math.acos(Y(bua/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}const dua=new da();class eua{constructor(fua=new da(Infinity,Infinity),gua=new da(-1/0,-1/0)){this.min=fua,this.max=gua}set(hua,iua){return this.min.copy(hua),this.max.copy(iua),this}setFromPoints(jua){this.makeEmpty();for(let kua=0,lua=jua.length;kua<lua;kua++)this.expandByPoint(jua[kua]);return this}setFromCenterAndSize(mua,nua){const oua=dua.copy(nua).multiplyScalar(0.5);return this.min.copy(mua).sub(oua),this.max.copy(mua).add(oua),this}clone(){return new this.constructor().copy(this)}copy(pua){return this.min.copy(pua.min),this.max.copy(pua.max),this}makeEmpty(){return this.min.x=this.min.y=Infinity,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(qua){return this.isEmpty()?qua.set(0,0):qua.addVectors(this.min,this.max).multiplyScalar(0.5)}getSize(rua){return this.isEmpty()?rua.set(0,0):rua.subVectors(this.max,this.min)}expandByPoint(sua){return this.min.min(sua),this.max.max(sua),this}expandByVector(tua){return this.min.sub(tua),this.max.add(tua),this}expandByScalar(uua){return this.min.addScalar(-uua),this.max.addScalar(uua),this}containsPoint(vua){return!(vua.x<this.min.x)&&!(vua.x>this.max.x)&&!(vua.y<this.min.y)&&!(vua.y>this.max.y)}containsBox(wua){return this.min.x<=wua.min.x&&wua.max.x<=this.max.x&&this.min.y<=wua.min.y&&wua.max.y<=this.max.y}getParameter(xua,yua){return yua.set((xua.x-this.min.x)/(this.max.x-this.min.x),(xua.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(zua){return!(zua.max.x<this.min.x)&&!(zua.min.x>this.max.x)&&!(zua.max.y<this.min.y)&&!(zua.min.y>this.max.y)}clampPoint(Aua,Bua){return Bua.copy(Aua).clamp(this.min,this.max)}distanceToPoint(Cua){const Dua=dua.copy(Cua).clamp(this.min,this.max);return Dua.sub(Cua).length()}intersect(Eua){return this.min.max(Eua.min),this.max.min(Eua.max),this}union(Fua){return this.min.min(Fua.min),this.max.max(Fua.max),this}translate(Gua){return this.min.add(Gua),this.max.add(Gua),this}equals(Hua){return Hua.min.equals(this.min)&&Hua.max.equals(this.max)}}eua.prototype.isBox2=!0;const Iua=new Qi(),Jua=new Qi(),Kua=new Qi(),Lua=new Qi(),Mua=new dp(),Nua=new dp();function Oua(a){const b=[];a&&a.isBone&&b.push(a);for(let c=0;c<a.children.length;c++)b.push.apply(b,Oua(a.children[c]));return b}new Qi(),new oz(),new oz(),new Qi(),new Qi(),new Qi(),new Qi(),new aI(),new ul(),new Qi();const Pua=new Float32Array(1);new Int32Array(Pua.buffer),_Z.create=function(a,b){return console.log("THREE.Curve.create() has been deprecated"),a.prototype=Object.create(_Z.prototype),a.prototype.constructor=a,a.prototype.getPoint=b,a},l3.prototype.fromPoints=function(a){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(a)},(class extends $W{constructor(Qua=10,Rua=10,Sua=4473924,Tua=8947848){Sua=new oz(Sua),Tua=new oz(Tua);const Uua=Rua/2,Vua=Qua/Rua,Wua=Qua/2,Xua=[],Yua=[];for(let Zua=0,$ua=0,_ua=-Wua;Zua<=Rua;Zua++,_ua+=Vua){Xua.push(-Wua,0,_ua,Wua,0,_ua),Xua.push(_ua,0,-Wua,_ua,0,Wua);const ava=Zua===Uua?Sua:Tua;ava.toArray(Yua,$ua),$ua+=3,ava.toArray(Yua,$ua),$ua+=3,ava.toArray(Yua,$ua),$ua+=3,ava.toArray(Yua,$ua),$ua+=3}const bva=new HC();bva.setAttribute("position",new wC(Xua,3)),bva.setAttribute("color",new wC(Yua,3));const cva=new XV({vertexColors:!0,toneMapped:!1});super(bva,cva),this.type="GridHelper"}}).prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")},(class extends $W{constructor(dva){const eva=Oua(dva),fva=new HC(),gva=[],hva=[],iva=new oz(0,0,1),jva=new oz(0,1,0);for(let kva=0;kva<eva.length;kva++){const lva=eva[kva];lva.parent&&lva.parent.isBone&&(gva.push(0,0,0),gva.push(0,0,0),hva.push(iva.r,iva.g,iva.b),hva.push(jva.r,jva.g,jva.b))}fva.setAttribute("position",new wC(gva,3)),fva.setAttribute("color",new wC(hva,3));const mva=new XV({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(fva,mva),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=dva,this.bones=eva,this.matrix=dva.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(nva){const ova=this.bones,pva=this.geometry,qva=pva.getAttribute("position");Nua.copy(this.root.matrixWorld).invert();for(let rva=0,sva=0;rva<ova.length;rva++){const tva=ova[rva];tva.parent&&tva.parent.isBone&&(Mua.multiplyMatrices(Nua,tva.matrixWorld),Lua.setFromMatrixPosition(Mua),qva.setXYZ(sva,Lua.x,Lua.y,Lua.z),Mua.multiplyMatrices(Nua,tva.parent.matrixWorld),Lua.setFromMatrixPosition(Mua),qva.setXYZ(sva+1,Lua.x,Lua.y,Lua.z),sva+=2)}pva.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(nva)}}).prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")},aga.prototype.extractUrlBase=function(a){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),jja.extractUrlBase(a)},aga.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}},eua.prototype.center=function(a){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(a)},eua.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},eua.prototype.isIntersectionBox=function(a){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(a)},eua.prototype.size=function(a){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(a)},ul.prototype.center=function(a){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(a)},ul.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},ul.prototype.isIntersectionBox=function(a){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(a)},ul.prototype.isIntersectionSphere=function(a){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(a)},ul.prototype.size=function(a){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(a)},$m.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()},xK.prototype.setFromMatrix=function(a){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(a)},(class{constructor(uva=new Qi(),vva=new Qi()){this.start=uva,this.end=vva}set(wva,xva){return this.start.copy(wva),this.end.copy(xva),this}copy(yva){return this.start.copy(yva.start),this.end.copy(yva.end),this}getCenter(zva){return zva.addVectors(this.start,this.end).multiplyScalar(0.5)}delta(Ava){return Ava.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(Bva,Cva){return this.delta(Cva).multiplyScalar(Bva).add(this.start)}closestPointToPointParameter(Dva,Eva){Iua.subVectors(Dva,this.start),Jua.subVectors(this.end,this.start);const Fva=Jua.dot(Jua),Gva=Jua.dot(Iua);let Hva=Gva/Fva;return Eva&&(Hva=Y(Hva,0,1)),Hva}closestPointToPoint(Iva,Jva,Kva){const Lva=this.closestPointToPointParameter(Iva,Jva);return this.delta(Kva).multiplyScalar(Lva).add(this.start)}applyMatrix4(Mva){return this.start.applyMatrix4(Mva),this.end.applyMatrix4(Mva),this}equals(Nva){return Nva.start.equals(this.start)&&Nva.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}).prototype.center=function(a){return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."),this.getCenter(a)},ub.prototype.flattenToArrayOffset=function(a,b){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(a,b)},ub.prototype.multiplyVector3=function(a){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),a.applyMatrix3(this)},ub.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},ub.prototype.applyToBufferAttribute=function(a){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),a.applyMatrix3(this)},ub.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},ub.prototype.getInverse=function(a){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(a).invert()},dp.prototype.extractPosition=function(a){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(a)},dp.prototype.flattenToArrayOffset=function(a,b){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(a,b)},dp.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new Qi().setFromMatrixColumn(this,3)},dp.prototype.setRotationFromQuaternion=function(a){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(a)},dp.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},dp.prototype.multiplyVector3=function(a){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)},dp.prototype.multiplyVector4=function(a){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)},dp.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},dp.prototype.rotateAxis=function(a){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),a.transformDirection(this)},dp.prototype.crossVector=function(a){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)},dp.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")},dp.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},dp.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},dp.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},dp.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},dp.prototype.applyToBufferAttribute=function(a){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),a.applyMatrix4(this)},dp.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},dp.prototype.makeFrustum=function(a,b,c,d,e,f){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(a,b,d,c,e,f)},dp.prototype.getInverse=function(a){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(a).invert()},KJ.prototype.isIntersectionLine=function(a){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(a)},jg.prototype.multiplyVector3=function(a){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),a.applyQuaternion(this)},jg.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()},Kn.prototype.isIntersectionBox=function(a){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(a)},Kn.prototype.isIntersectionPlane=function(a){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(a)},Kn.prototype.isIntersectionSphere=function(a){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(a)},px.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},px.prototype.barycoordFromPoint=function(a,b){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(a,b)},px.prototype.midpoint=function(a){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(a)},px.prototypenormal=function(a){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(a)},px.prototype.plane=function(a){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(a)},px.barycoordFromPoint=function(a,b,c,d,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),px.getBarycoord(a,b,c,d,e)},px.normal=function(a,b,c,d){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),px.getNormal(a,b,c,d)},u4.prototype.extractAllPoints=function(a){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(a)},u4.prototype.extrude=function(a){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new J5(this,a)},u4.prototype.makeGeometry=function(a){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new q7(this,a)},da.prototype.fromAttribute=function(a,b,c){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(a,b,c)},da.prototype.distanceToManhattan=function(a){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(a)},da.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},Qi.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},Qi.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},Qi.prototype.getPositionFromMatrix=function(a){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(a)},Qi.prototype.getScaleFromMatrix=function(a){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(a)},Qi.prototype.getColumnFromMatrix=function(a,b){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(b,a)},Qi.prototype.applyProjection=function(a){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(a)},Qi.prototype.fromAttribute=function(a,b,c){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(a,b,c)},Qi.prototype.distanceToManhattan=function(a){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(a)},Qi.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},ae.prototype.fromAttribute=function(a,b,c){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(a,b,c)},ae.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()},hv.prototype.getChildByName=function(a){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(a)},hv.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},hv.prototype.translate=function(a,b){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(b,a)},hv.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},hv.prototype.applyMatrix=function(a){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(a)},Object.defineProperties(hv.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(a){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=a}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}}),qG.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")},Object.defineProperties(qG.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),0},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}}),WT.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")},iI.prototype.setLens=function(a,b){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),void 0!==b&&(this.filmGauge=b),this.setFocalLength(a)},Object.defineProperties($ga.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(a){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=a}},shadowCameraLeft:{set:function(a){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=a}},shadowCameraRight:{set:function(a){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=a}},shadowCameraTop:{set:function(a){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=a}},shadowCameraBottom:{set:function(a){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=a}},shadowCameraNear:{set:function(a){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=a}},shadowCameraFar:{set:function(a){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=a}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(a){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=a}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(a){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=a}},shadowMapHeight:{set:function(a){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=a}}}),Object.defineProperties(OA.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),35048===this.usage},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(35048)}}}),OA.prototype.setDynamic=function(a){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===a?35048:35044),this},OA.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},OA.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},HC.prototype.addIndex=function(a){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(a)},HC.prototype.addAttribute=function(a,b){return(console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),b&&b.isBufferAttribute||b&&b.isInterleavedBufferAttribute)?"index"===a?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(b),this):this.setAttribute(a,b):(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(a,new OA(arguments[1],arguments[2])))},HC.prototype.addDrawCall=function(a,b,c){void 0!==c&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(a,b)},HC.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},HC.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},HC.prototype.removeAttribute=function(a){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(a)},HC.prototype.applyMatrix=function(a){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(a)},Object.defineProperties(HC.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}}),aS.prototype.setDynamic=function(a){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(!0===a?35048:35044),this},aS.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")},J5.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")},J5.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")},J5.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")},XR.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")},xta.prototype.onUpdate=function(){return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."),this},Object.defineProperties(Sy.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new oz()}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(a){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=1===a}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(a){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=a}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}}),Object.defineProperties(SH.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(a){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=a}}}),PR.prototype.clearTarget=function(a,b,c,d){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(a),this.clear(b,c,d)},PR.prototype.animate=function(a){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(a)},PR.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},PR.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},PR.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},PR.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},PR.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},PR.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},PR.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},PR.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},PR.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},PR.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},PR.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},PR.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},PR.prototype.enableScissorTest=function(a){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(a)},PR.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},PR.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},PR.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},PR.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},PR.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},PR.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},PR.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},PR.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},PR.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},PR.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()},Object.defineProperties(PR.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=a}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(a){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=a}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(a){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=!0===a?w:3000}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}}),Object.defineProperties(CQ.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}}),Object.defineProperties(Kf.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=a}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(a){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=a}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=a}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(a){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=a}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(a){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=a}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(a){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=a}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(a){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=a}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(a){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=a}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(a){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=a}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(a){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=a}}}),(class extends hv{constructor(Ova){super(),this.type="Audio",this.listener=Ova,this.context=Ova.context,this.gain=this.context.createGain(),this.gain.connect(Ova.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(Pva){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=Pva,this.connect(),this}setMediaElementSource(Qva){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(Qva),this.connect(),this}setMediaStreamSource(Rva){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(Rva),this.connect(),this}setBuffer(Sva){return this.buffer=Sva,this.sourceType="buffer",this.autoplay&&this.play(),this}play(Tva=0){if(!0===this.isPlaying){console.warn("THREE.Audio: Audio is already playing.");return}if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+Tva;const Uva=this.context.createBufferSource();return Uva.buffer=this.buffer,Uva.loop=this.loop,Uva.loopStart=this.loopStart,Uva.loopEnd=this.loopEnd,Uva.onended=this.onEnded.bind(this),Uva.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=Uva,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let Vva=1,Wva=this.filters.length;Vva<Wva;Vva++)this.filters[Vva-1].connect(this.filters[Vva]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let Xva=1,Yva=this.filters.length;Xva<Yva;Xva++)this.filters[Xva-1].disconnect(this.filters[Xva]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(Zva){return Zva||(Zva=[]),!0===this._connected?(this.disconnect(),this.filters=Zva.slice(),this.connect()):this.filters=Zva.slice(),this}setDetune($va){if(this.detune=$va,void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,0.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(_va){return this.setFilters(_va?[_va]:[])}setPlaybackRate(awa){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=awa,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,0.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(bwa){if(!1===this.hasPlaybackControl){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=bwa,!0===this.isPlaying&&(this.source.loop=this.loop),this}setLoopStart(cwa){return this.loopStart=cwa,this}setLoopEnd(dwa){return this.loopEnd=dwa,this}getVolume(){return this.gain.gain.value}setVolume(ewa){return this.gain.gain.setTargetAtTime(ewa,this.context.currentTime,0.01),this}}).prototype.load=function(a){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const b=this,c=new Hja();return c.load(a,function(a){b.setBuffer(a)}),this},(class{constructor(fwa,gwa=2048){this.analyser=fwa.context.createAnalyser(),this.analyser.fftSize=gwa,this.data=new Uint8Array(this.analyser.frequencyBinCount),fwa.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let hwa=0;const iwa=this.getFrequencyData();for(let jwa=0;jwa<iwa.length;jwa++)hwa+=iwa[jwa];return hwa/iwa.length}}).prototype.getData=function(){return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."),this.getFrequencyData()},JI.prototype.updateCubeMap=function(a,b){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(a,b)},JI.prototype.clear=function(a,b,c,d){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(a,b,c,d)},Bd.crossOrigin=void 0,Bd.loadTexture=function(a,b,c,d){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const e=new Sga();e.setCrossOrigin(this.crossOrigin);const f=e.load(a,c,void 0,d);return b&&(f.mapping=b),f},Bd.loadTextureCube=function(a,b,c,d){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const e=new Hga();e.setCrossOrigin(this.crossOrigin);const f=e.load(a,c,void 0,d);return b&&(f.mapping=b),f},Bd.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},Bd.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")},"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"134"}})),"undefined"!=typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="134")}}])